{"version":3,"file":"TextUtils.js","sourceRoot":"","sources":["../../../../../../front_end/models/text_utils/TextUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport {SearchMatch} from './ContentProvider.js';\nimport {Text} from './Text.js';\n\nconst KEY_VALUE_FILTER_REGEXP = /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\nconst REGEXP_FILTER_REGEXP = /(?:^|\\s)(\\-)?\\/([^\\/\\\\]+(\\\\.[^\\/]*)*)\\//;\nconst TEXT_FILTER_REGEXP = /(?:^|\\s)(\\-)?([^\\s]+)/;\nconst SPACE_CHAR_REGEXP = /\\s/;\n\nexport const Utils = {\n  isSpaceChar: function(char: string): boolean {\n    return SPACE_CHAR_REGEXP.test(char);\n  },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): {\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }[] {\n    const matches: {\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: (string|undefined)[],\n    }[] = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex: regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters =\n        Utils.splitStringByRegexes(query, [KEY_VALUE_FILTER_REGEXP, REGEXP_FILTER_REGEXP, TEXT_FILTER_REGEXP]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'i'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch (e) {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\n/**\n * Detects the indentation used by a given text document, based on the _Comparing\n * lines_ approach suggested by Heather Arthur (and also found in Firefox DevTools).\n *\n * This implementation differs from the original proposal in that tab indentation\n * isn't detected by checking if at least 50% of the lines start with a tab, but\n * instead by comparing the number of lines that start with a tab to the frequency\n * of the other indentation patterns. This way we also detect small snippets with\n * long leading comments correctly, when tab indentation is used for the snippets\n * of code.\n *\n * @param lines The input document lines.\n * @return The indentation detected for the lines as string or `null` if it's inconclusive.\n *\n * @see https://heathermoor.medium.com/detecting-code-indentation-eff3ed0fb56b\n */\nexport const detectIndentation = function(lines: Iterable<string>): string|null {\n  const frequencies: Array<number> = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let tabs = 0, previous = 0;\n\n  for (const line of lines) {\n    let current = 0;\n    if (line.length !== 0) {\n      let char = line.charAt(0);\n      if (char === '\\t') {\n        tabs++;\n        continue;\n      }\n      while (char === ' ') {\n        char = line.charAt(++current);\n      }\n    }\n\n    if (current === line.length) {\n      // Don't consider empty lines.\n      previous = 0;\n      continue;\n    }\n\n    const delta = Math.abs(current - previous);\n    if (delta < frequencies.length) {\n      // Don't consider deltas above 8 characters.\n      frequencies[delta] = frequencies[delta] + 1;\n    }\n    previous = current;\n  }\n\n  // Find most frequent non-zero width difference between adjacent lines.\n  let mostFrequentDelta = 0, highestFrequency = 0;\n  for (let delta = 1; delta < frequencies.length; ++delta) {\n    const frequency = frequencies[delta];\n    if (frequency > highestFrequency) {\n      highestFrequency = frequency;\n      mostFrequentDelta = delta;\n    }\n  }\n\n  if (tabs > mostFrequentDelta) {\n    // If more lines start with tabs than any other indentation,\n    // we assume that the document was written with tab indentation\n    // in mind. This differs from the original algorithm.\n    return '\\t';\n  }\n\n  if (!mostFrequentDelta) {\n    return null;\n  }\n\n  return ' '.repeat(mostFrequentDelta);\n};\n\n/**\n * Heuristic to check whether a given text was likely minified. Intended to\n * be used for HTML, CSS, and JavaScript inputs.\n *\n * A text is considered to be the result of minification if the average\n * line length for the whole text is 80 characters or more.\n *\n * @param text The input text to check.\n * @returns\n */\nexport const isMinified = function(text: string): boolean {\n  let lineCount = 0;\n  for (let lastIndex = 0; lastIndex < text.length; ++lineCount) {\n    let eolIndex = text.indexOf('\\n', lastIndex);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    lastIndex = eolIndex + 1;\n  }\n  return (text.length - lineCount) / lineCount >= 80;\n};\n\n/**\n * Small wrapper around {@link performSearchInContent} to reduce boilerplate when searching\n * in {@link ContentDataOrError}.\n *\n * @returns empty search matches if `contentData` is an error or not text content.\n */\nexport const performSearchInContentData = function(\n    contentData: ContentDataOrError, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  if (ContentData.isError(contentData) || !contentData.isTextContent) {\n    return [];\n  }\n  return performSearchInContent(contentData.text, query, caseSensitive, isRegex);\n};\n\n/**\n * @returns One {@link SearchMatch} per match. Multiple matches on the same line each\n * result in their own `SearchMatchExact` instance.\n */\nexport const performSearchInContent = function(\n    content: string, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const text = new Text(content);\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(i, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Similar to {@link performSearchInContent} but doesn't search in a whole text but rather\n * finds the exact matches on a prelminiary search result (i.e. lines with known matches).\n * @param matches is deliberatedly typed as an object literal so we can pass the\n *                CDP search result type.\n */\nexport const performSearchInSearchMatches = function(\n    matches: {lineNumber: number, lineContent: string}[], query: string, caseSensitive: boolean,\n    isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n  const result = [];\n\n  for (const {lineNumber, lineContent} of matches) {\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(lineNumber, lineContent, match.index as number, match[0].length));\n    }\n  }\n  return result;\n};\n\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n"]}