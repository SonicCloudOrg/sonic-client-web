{"version":3,"file":"LayoutShift.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/root-causes/LayoutShift.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport {type TraceParseData} from '../handlers/types.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {type RootCauseProtocolInterface} from './RootCauses.js';\n\nexport type CSSDimensions = {\n  width?: string,\n  height?: string,\n  aspectRatio?: string,\n};\n\nexport interface UnsizedMedia {\n  node: Protocol.DOM.Node;\n  authoredDimensions?: CSSDimensions;\n  computedDimensions: CSSDimensions;\n}\n\nexport interface InjectedIframe {\n  iframe: Protocol.DOM.Node;\n}\n\nexport interface RootCauseRequest {\n  request: Types.TraceEvents.SyntheticNetworkRequest;\n  initiator?: Protocol.Network.Initiator;\n}\n\nexport interface FontChange extends RootCauseRequest {\n  fontFace: Protocol.CSS.FontFace;\n}\n\nexport interface RenderBlockingRequest extends RootCauseRequest {}\n\nexport interface LayoutShiftRootCausesData {\n  unsizedMedia: UnsizedMedia[];\n  iframes: InjectedIframe[];\n  fontChanges: FontChange[];\n  renderBlockingRequests: RenderBlockingRequest[];\n  scriptStackTrace: Types.TraceEvents.TraceEventCallFrame[];\n}\n\nconst fontRequestsByPrePaint = new Map<Types.TraceEvents.TraceEventPrePaint, FontChange[]|null>();\nconst renderBlocksByPrePaint = new Map<Types.TraceEvents.TraceEventPrePaint, RenderBlockingRequest[]|null>();\n\nfunction setDefaultValue(\n    map: Map<Types.TraceEvents.TraceEventLayoutShift, LayoutShiftRootCausesData>,\n    shift: Types.TraceEvents.TraceEventLayoutShift): void {\n  Platform.MapUtilities.getWithDefault(map, shift, () => {\n    return {\n      unsizedMedia: [],\n      iframes: [],\n      fontChanges: [],\n      renderBlockingRequests: [],\n      scriptStackTrace: [],\n    };\n  });\n}\n\n// Important: we purposefully treat `potentially_blocking` as\n// non-render-blocking here because:\n// 1. An async script can run on the main thread at any point, including before\n//    the page is loaded\n// 2. An async script will never block the parsing and rendering process of the\n//    browser.\n// 3. Therefore, from a developer's point of view, there is nothing more they\n//    can do if they've put `async` on, and within the context of Insights, we\n//    shouldn't report an async script as render blocking.\n// In the future we may want to consider suggesting the use of `defer` over\n// `async`, as it doesn't have this concern, but for now we'll allow `async`\n// and not report it as an issue.\nconst NON_RENDER_BLOCKING_VALUES = new Set<Types.TraceEvents.RenderBlocking>([\n  'non_blocking',\n  'potentially_blocking',\n]);\nfunction networkRequestIsRenderBlockingInFrame(\n    event: Types.TraceEvents.SyntheticNetworkRequest, frameId: string): boolean {\n  const isRenderBlocking = !NON_RENDER_BLOCKING_VALUES.has(event.args.data.renderBlocking);\n  return isRenderBlocking && event.args.data.frame === frameId;\n}\n\ninterface Options {\n  /** Checking iframe root causes can be an expensive operation, so it is disabled by default. */\n  enableIframeRootCauses?: boolean;\n}\n\nexport class LayoutShiftRootCauses {\n  #protocolInterface: RootCauseProtocolInterface;\n  #rootCauseCacheMap = new Map<Types.TraceEvents.TraceEventLayoutShift, LayoutShiftRootCausesData>();\n  #nodeDetailsCache = new Map<Protocol.DOM.NodeId, Protocol.DOM.Node|null>();\n  #iframeRootCausesEnabled: boolean;\n\n  constructor(protocolInterface: RootCauseProtocolInterface, options?: Options) {\n    this.#protocolInterface = protocolInterface;\n    this.#iframeRootCausesEnabled = options?.enableIframeRootCauses ?? false;\n  }\n\n  /**\n   * Calculates the potential root causes for a given layout shift event. Once\n   * calculated, this data is cached.\n   * Note: because you need all layout shift data at once to calculate these\n   * correctly, this function will parse the root causes for _all_ layout shift\n   * events the first time that it's called. That then populates the cache for\n   * each shift, so any subsequent calls are just a constant lookup.\n   */\n  async rootCausesForEvent(modelData: TraceParseData, event: Types.TraceEvents.TraceEventLayoutShift):\n      Promise<Readonly<LayoutShiftRootCausesData>|null> {\n    const cachedResult = this.#rootCauseCacheMap.get(event);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    const allLayoutShifts = modelData.LayoutShifts.clusters.flatMap(cluster => cluster.events);\n    // Make sure a value in the cache is set even for shifts that don't have a root cause,\n    // so that we don't have to recompute when no root causes are found. In case a cause\n    // for a shift is found, the default value is replaced.\n    allLayoutShifts.forEach(shift => setDefaultValue(this.#rootCauseCacheMap, shift));\n\n    // Populate the cache\n    await this.blameShifts(\n        allLayoutShifts,\n        modelData,\n    );\n\n    const resultForEvent = this.#rootCauseCacheMap.get(event);\n    if (!resultForEvent) {\n      // No root causes available for this layout shift.\n      return null;\n    }\n    return resultForEvent;\n  }\n\n  /**\n   * Determines potential root causes for shifts\n   */\n  async blameShifts(\n      layoutShifts: Types.TraceEvents.TraceEventLayoutShift[],\n      modelData: TraceParseData,\n      ): Promise<void> {\n    await this.linkShiftsToLayoutInvalidations(layoutShifts, modelData);\n    this.linkShiftsToLayoutEvents(layoutShifts, modelData);\n  }\n\n  /**\n   * \"LayoutInvalidations\" are a set of trace events dispatched in Blink under the name\n   * \"layoutInvalidationTracking\", which track invalidations on the \"Layout\"stage of the\n   * rendering pipeline. This function utilizes this event to flag potential root causes\n   * to layout shifts.\n   */\n  async linkShiftsToLayoutInvalidations(\n      layoutShifts: Types.TraceEvents.TraceEventLayoutShift[], modelData: TraceParseData): Promise<void> {\n    const {prePaintEvents, layoutInvalidationEvents, scheduleStyleInvalidationEvents, backendNodeIds} =\n        modelData.LayoutShifts;\n\n    // For the purposes of determining root causes of layout shifts, we\n    // consider scheduleStyleInvalidationTracking and\n    // LayoutInvalidationTracking events as events that could have been the\n    // cause of the layout shift.\n    const eventsForLayoutInvalidation: Array<Types.TraceEvents.TraceEventLayoutInvalidationTracking|\n                                             Types.TraceEvents.TraceEventScheduleStyleInvalidationTracking> =\n        [...layoutInvalidationEvents, ...scheduleStyleInvalidationEvents];\n\n    const nodes = await this.#protocolInterface.pushNodesByBackendIdsToFrontend(backendNodeIds);\n    const nodeIdsByBackendIdMap = new Map<Protocol.DOM.BackendNodeId, Protocol.DOM.NodeId>();\n    for (let i = 0; i < backendNodeIds.length; i++) {\n      nodeIdsByBackendIdMap.set(backendNodeIds[i], nodes[i]);\n    }\n\n    // Maps from PrePaint events to LayoutShifts that occured in each one.\n    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents);\n    for (const layoutInvalidation of eventsForLayoutInvalidation) {\n      // Get the first PrePaint event that happened after the current LayoutInvalidation event.\n      const nextPrePaintIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(\n          prePaintEvents, prePaint => prePaint.ts > layoutInvalidation.ts);\n      if (nextPrePaintIndex === null) {\n        // No PrePaint event registered after this LayoutInvalidation. Continue.\n        continue;\n      }\n      const nextPrePaint = prePaintEvents[nextPrePaintIndex];\n      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);\n      if (!subsequentShifts) {\n        // The PrePaint after the current LayoutInvalidation doesn't contain shifts.\n        continue;\n      }\n      const fontChangeRootCause = this.getFontChangeRootCause(layoutInvalidation, nextPrePaint, modelData);\n      const renderBlockRootCause = this.getRenderBlockRootCause(layoutInvalidation, nextPrePaint, modelData);\n      const layoutInvalidationNodeId = nodeIdsByBackendIdMap.get(layoutInvalidation.args.data.nodeId);\n      let unsizedMediaRootCause: UnsizedMedia|null = null;\n      let iframeRootCause: InjectedIframe|null = null;\n      if (layoutInvalidationNodeId !== undefined &&\n          Types.TraceEvents.isTraceEventLayoutInvalidationTracking(layoutInvalidation)) {\n        unsizedMediaRootCause = await this.getUnsizedMediaRootCause(layoutInvalidation, layoutInvalidationNodeId);\n        iframeRootCause = await this.getIframeRootCause(layoutInvalidation, layoutInvalidationNodeId);\n      }\n\n      if (!unsizedMediaRootCause && !iframeRootCause && !fontChangeRootCause && !renderBlockRootCause) {\n        continue;\n      }\n\n      // Add found potential root causes to all the shifts in this PrePaint and populate the cache.\n      for (const shift of subsequentShifts) {\n        const rootCausesForShift = Platform.MapUtilities.getWithDefault(this.#rootCauseCacheMap, shift, () => {\n          return {\n            unsizedMedia: [],\n            iframes: [],\n            fontChanges: [],\n            renderBlockingRequests: [],\n            scriptStackTrace: [],\n          };\n        });\n        if (unsizedMediaRootCause &&\n            !rootCausesForShift.unsizedMedia.some(media => media.node.nodeId === unsizedMediaRootCause?.node.nodeId) &&\n            shift.args.frame === layoutInvalidation.args.data.frame) {\n          rootCausesForShift.unsizedMedia.push(unsizedMediaRootCause);\n        }\n        if (iframeRootCause &&\n            !rootCausesForShift.iframes.some(\n                injectedIframe => injectedIframe.iframe.nodeId === iframeRootCause?.iframe.nodeId)) {\n          rootCausesForShift.iframes.push(iframeRootCause);\n        }\n        if (fontChangeRootCause) {\n          // Unlike other root causes, we calculate fonts causing a shift only once,\n          // which means we assign the built array instead of appending new objects\n          // to it.\n          rootCausesForShift.fontChanges = fontChangeRootCause;\n        }\n        if (renderBlockRootCause) {\n          rootCausesForShift.renderBlockingRequests = renderBlockRootCause;\n        }\n      }\n    }\n  }\n\n  /**\n   * For every shift looks up the initiator of its corresponding Layout event. This initiator\n   * is assigned by the RendererHandler and contains the stack trace of the point in a script\n   * that caused a style recalculation or a relayout. This stack trace is added to the shift's\n   * potential root causes.\n   * Note that a Layout cannot always be linked to a script, in that case, we cannot add a\n   * \"script causing reflow\" as a potential root cause to the corresponding shift.\n   */\n  linkShiftsToLayoutEvents(layoutShifts: Types.TraceEvents.TraceEventLayoutShift[], modelData: TraceParseData): void {\n    const {prePaintEvents} = modelData.LayoutShifts;\n    // Maps from PrePaint events to LayoutShifts that occured in each one.\n    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents);\n\n    const eventTriggersLayout = ({name}: {name: string}): boolean => {\n      const knownName = name as Types.TraceEvents.KnownEventName;\n      return knownName === Types.TraceEvents.KnownEventName.Layout;\n    };\n    const layoutEvents = modelData.Renderer.allTraceEntries.filter(eventTriggersLayout);\n    for (const layout of layoutEvents) {\n      // Get the first PrePaint event that happened after the current layout event.\n      const nextPrePaintIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(\n          prePaintEvents, prePaint => prePaint.ts > layout.ts + (layout.dur || 0));\n      if (nextPrePaintIndex === null) {\n        // No PrePaint event registered after this LayoutInvalidation. Continue.\n        continue;\n      }\n      const nextPrePaint = prePaintEvents[nextPrePaintIndex];\n      const subsequentShifts = shiftsByPrePaint.get(nextPrePaint);\n      if (!subsequentShifts) {\n        // The PrePaint after the current LayoutInvalidation doesn't contain shifts.\n        continue;\n      }\n      const layoutNode = modelData.Renderer.entryToNode.get(layout);\n      const initiator = layoutNode ? modelData.Initiators.eventToInitiator.get(layoutNode.entry) : null;\n      const stackTrace = initiator?.args?.data?.stackTrace;\n      if (!stackTrace) {\n        continue;\n      }\n      // Add found potential root causes to all the shifts in this PrePaint and populate the cache.\n      for (const shift of subsequentShifts) {\n        const rootCausesForShift = Platform.MapUtilities.getWithDefault(this.#rootCauseCacheMap, shift, () => {\n          return {\n            unsizedMedia: [],\n            iframes: [],\n            fontChanges: [],\n            renderBlockingRequests: [],\n            scriptStackTrace: [],\n          };\n        });\n        if (rootCausesForShift.scriptStackTrace.length === 0) {\n          rootCausesForShift.scriptStackTrace = stackTrace;\n        }\n      }\n    }\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because a media element without dimensions was resized.\n   */\n  async getUnsizedMediaRootCause(\n      layoutInvalidation: Types.TraceEvents.TraceEventLayoutInvalidationTracking,\n      layoutInvalidationNodeId: Protocol.DOM.NodeId): Promise<UnsizedMedia|null> {\n    // Filter events to resizes only.\n    if (layoutInvalidation.args.data.reason !== Types.TraceEvents.LayoutInvalidationReason.SIZE_CHANGED) {\n      return null;\n    }\n\n    const layoutInvalidationNode = await this.getNodeDetails(layoutInvalidationNodeId);\n    if (!layoutInvalidationNode) {\n      return null;\n    }\n\n    const computedStylesList = await this.#protocolInterface.getComputedStyleForNode(layoutInvalidationNode.nodeId);\n    const computedStyles = new Map(computedStylesList.map(item => [item.name, item.value]));\n    if (computedStyles && !(await nodeIsUnfixedMedia(layoutInvalidationNode, computedStyles))) {\n      return null;\n    }\n    const authoredDimensions = await this.getNodeAuthoredDimensions(layoutInvalidationNode);\n    if (dimensionsAreExplicit(authoredDimensions)) {\n      return null;\n    }\n    const computedDimensions = computedStyles ? getNodeComputedDimensions(computedStyles) : {};\n\n    return {node: layoutInvalidationNode, authoredDimensions, computedDimensions};\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because a node, which is an ancestor to an iframe, was injected.\n   */\n  async getIframeRootCause(\n      layoutInvalidation: Types.TraceEvents.TraceEventLayoutInvalidationTracking,\n      layoutInvalidationNodeId: Protocol.DOM.NodeId): Promise<InjectedIframe|null> {\n    if (!this.#iframeRootCausesEnabled) {\n      return null;\n    }\n\n    if (!layoutInvalidation.args.data.nodeName?.startsWith('IFRAME') &&\n        layoutInvalidation.args.data.reason !== Types.TraceEvents.LayoutInvalidationReason.STYLE_CHANGED &&\n        layoutInvalidation.args.data.reason !== Types.TraceEvents.LayoutInvalidationReason.ADDED_TO_LAYOUT) {\n      return null;\n    }\n\n    const layoutInvalidationNode = await this.getNodeDetails(layoutInvalidationNodeId);\n    if (!layoutInvalidationNode) {\n      return null;\n    }\n\n    const iframe = firstIframeInDOMTree(layoutInvalidationNode);\n    if (!iframe) {\n      return null;\n    }\n    return {iframe};\n  }\n\n  async getNodeDetails(nodeId: Protocol.DOM.NodeId): Promise<Protocol.DOM.Node|null> {\n    let nodeDetails = this.#nodeDetailsCache.get(nodeId);\n    if (nodeDetails !== undefined) {\n      return nodeDetails;\n    }\n\n    nodeDetails = await this.#protocolInterface.getNode(nodeId);\n    this.#nodeDetailsCache.set(nodeId, nodeDetails);\n\n    return nodeDetails;\n  }\n\n  /**\n   * Given a layout invalidation event and a sorted array, returns the subset of requests that arrived within a\n   * 500ms window before the layout invalidation.\n   */\n  requestsInInvalidationWindow(\n      layoutInvalidation: Types.TraceEvents.TraceEventLayoutInvalidationTracking|\n      Types.TraceEvents.TraceEventScheduleStyleInvalidationTracking,\n      modelData: TraceParseData): RootCauseRequest[] {\n    const requestsSortedByEndTime = modelData.NetworkRequests.byTime.sort((req1, req2) => {\n      const req1EndTime = req1.ts + req1.dur;\n      const req2EndTime = req2.ts + req2.dur;\n      return req1EndTime - req2EndTime;\n    });\n\n    const lastRequestIndex = Platform.ArrayUtilities.nearestIndexFromEnd(\n        requestsSortedByEndTime, request => request.ts + request.dur < layoutInvalidation.ts);\n    if (lastRequestIndex === null) {\n      return [];\n    }\n\n    const MAX_DELTA_FOR_FONT_REQUEST = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(0.5));\n\n    const requestsInInvalidationWindow: RootCauseRequest[] = [];\n\n    // Get all requests finished within the valid window.\n    for (let i = lastRequestIndex; i > -1; i--) {\n      const previousRequest = requestsSortedByEndTime[i];\n      const previousRequestEndTime = previousRequest.ts + previousRequest.dur;\n      if (layoutInvalidation.ts - previousRequestEndTime < MAX_DELTA_FOR_FONT_REQUEST) {\n        const requestInInvalidationWindow: RootCauseRequest = {request: previousRequest};\n\n        const initiator = this.#protocolInterface.getInitiatorForRequest(\n            previousRequest.args.data.url as Platform.DevToolsPath.UrlString);\n        requestInInvalidationWindow.initiator = initiator || undefined;\n        requestsInInvalidationWindow.push(requestInInvalidationWindow);\n      } else {\n        // No more requests fit in the time window.\n        break;\n      }\n    }\n    return requestsInInvalidationWindow;\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it was dispatched\n   * because fonts were changed and if so returns the information of all network\n   * request with which the fonts were possibly fetched, if any. The computed\n   * network requests are cached for the corresponding prepaint event, meaning\n   * that other LayoutInvalidation events that correspond to the same prepaint\n   * are not processed and the cached network requests for the prepaint is\n   * returned instead.\n   */\n  getFontChangeRootCause(\n      layoutInvalidation: Types.TraceEvents.TraceEventLayoutInvalidationTracking|\n      Types.TraceEvents.TraceEventScheduleStyleInvalidationTracking,\n      nextPrePaint: Types.TraceEvents.TraceEventPrePaint, modelData: TraceParseData): FontChange[]|null {\n    if (layoutInvalidation.args.data.reason !== Types.TraceEvents.LayoutInvalidationReason.FONTS_CHANGED) {\n      return null;\n    }\n    // Prevent computing the result of this function multiple times per PrePaint event.\n    const fontRequestsForPrepaint = fontRequestsByPrePaint.get(nextPrePaint);\n    if (fontRequestsForPrepaint !== undefined) {\n      return fontRequestsForPrepaint;\n    }\n\n    const fontRequestsInThisPrepaint =\n        this.getFontRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));\n    fontRequestsByPrePaint.set(nextPrePaint, fontRequestsInThisPrepaint);\n    return fontRequestsInThisPrepaint;\n  }\n\n  /**\n   * Given the requests that arrived within a 500ms window before the layout invalidation, returns the font\n   * requests of them.\n   */\n  getFontRequestsInInvalidationWindow(requestsInInvalidationWindow: RootCauseRequest[]): FontChange[] {\n    const fontRequests: FontChange[] = [];\n\n    // Get all requests finished within the valid window.\n    for (let i = 0; i < requestsInInvalidationWindow.length; i++) {\n      const fontRequest = requestsInInvalidationWindow[i] as FontChange;\n      if (!fontRequest.request.args.data.mimeType.startsWith('font')) {\n        continue;\n      }\n\n      const fontFace = this.#protocolInterface.fontFaceForSource(fontRequest.request.args.data.url);\n      if (!fontFace || fontFace.fontDisplay === 'optional') {\n        // Setting font-display to optional is part of what the developer\n        // can do to avoid layout shifts due to FOIT/FOUT, as such we cannot\n        // suggest any actionable insight here.\n        continue;\n      }\n      fontRequest.fontFace = fontFace;\n      fontRequests.push(fontRequest);\n    }\n    return fontRequests;\n  }\n\n  /**\n   * Given a LayoutInvalidation trace event, determines if it arrived within a 500ms window before the layout\n   * invalidation and if so returns the information of all network request, if any. The computed network\n   * requests are cached for the corresponding prepaint event, meaning that other LayoutInvalidation events\n   * that correspond to the same prepaint are not processed and the cached network requests for the prepaint is\n   *  returned instead.\n   */\n  getRenderBlockRootCause(\n      layoutInvalidation: Types.TraceEvents.TraceEventLayoutInvalidationTracking|\n      Types.TraceEvents.TraceEventScheduleStyleInvalidationTracking,\n      nextPrePaint: Types.TraceEvents.TraceEventPrePaint, modelData: TraceParseData): RenderBlockingRequest[]|null {\n    // Prevent computing the result of this function multiple times per PrePaint event.\n    const renderBlocksInPrepaint = renderBlocksByPrePaint.get(nextPrePaint);\n    if (renderBlocksInPrepaint !== undefined) {\n      return renderBlocksInPrepaint;\n    }\n\n    const renderBlocksInThisPrepaint =\n        getRenderBlockRequestsInInvalidationWindow(this.requestsInInvalidationWindow(layoutInvalidation, modelData));\n    renderBlocksByPrePaint.set(nextPrePaint, renderBlocksInThisPrepaint);\n    return renderBlocksInThisPrepaint;\n  }\n\n  /**\n   * Returns a function that retrieves the active value of a given\n   * CSS property within the matched styles of the param node.\n   * The first occurence within the matched styles is returned and the\n   * value is looked up in the following order, which follows CSS\n   * specificity:\n   * 1. Inline styles.\n   * 2. CSS rules matching this node, from all applicable stylesheets.\n   * 3. Attribute defined styles.\n   */\n  async nodeMatchedStylesPropertyGetter(node: Protocol.DOM.Node): Promise<((property: string) => string | null)> {\n    const response = await this.#protocolInterface.getMatchedStylesForNode(node.nodeId);\n\n    function cssPropertyValueGetter(cssProperty: string): string|null {\n      let prop = response.inlineStyle?.cssProperties.find(prop => prop.name === cssProperty);\n      if (prop) {\n        return prop.value;\n      }\n\n      for (const {rule} of response.matchedCSSRules || []) {\n        const prop = rule.style.cssProperties.find(prop => prop.name === cssProperty);\n        if (prop) {\n          return prop.value;\n        }\n      }\n\n      prop = response.attributesStyle?.cssProperties.find(prop => prop.name === cssProperty);\n      if (prop) {\n        return prop.value;\n      }\n\n      return null;\n    }\n    return cssPropertyValueGetter;\n  }\n\n  /**\n   * Returns the CSS dimensions set to the node from its matched styles.\n   */\n  async getNodeAuthoredDimensions(node: Protocol.DOM.Node): Promise<CSSDimensions> {\n    const authoredDimensions: CSSDimensions = {};\n\n    const cssMatchedRulesGetter = await this.nodeMatchedStylesPropertyGetter(node);\n    if (!cssMatchedRulesGetter) {\n      return authoredDimensions;\n    }\n\n    const attributesFlat = node.attributes || [];\n    const attributes = [];\n    for (let i = 0; i < attributesFlat.length; i += 2) {\n      attributes.push({name: attributesFlat[i], value: attributesFlat[i + 1]});\n    }\n\n    const htmlHeight = attributes.find(attr => attr.name === 'height' && htmlAttributeIsExplicit(attr));\n    const htmlWidth = attributes.find(attr => attr.name === 'width' && htmlAttributeIsExplicit(attr));\n\n    const cssExplicitAspectRatio = cssMatchedRulesGetter('aspect-ratio') || undefined;\n\n    if (htmlHeight && htmlWidth && cssExplicitAspectRatio) {\n      return {height: htmlHeight.value, width: htmlWidth.value, aspectRatio: cssExplicitAspectRatio};\n    }\n\n    const cssHeight = cssMatchedRulesGetter('height') || undefined;\n    const cssWidth = cssMatchedRulesGetter('width') || undefined;\n    return {height: cssHeight, width: cssWidth, aspectRatio: cssExplicitAspectRatio};\n  }\n}\n\n/**\n * Given the requests that arrived within a 500ms window before the layout invalidation, returns the render\n * block requests of them.\n */\nfunction getRenderBlockRequestsInInvalidationWindow(requestsInInvalidationWindow: RootCauseRequest[]):\n    RenderBlockingRequest[] {\n  const renderBlockingRequests: RenderBlockingRequest[] = [];\n\n  // Get all requests finished within the valid window.\n  for (let i = 0; i < requestsInInvalidationWindow.length; i++) {\n    const mainFrameId = requestsInInvalidationWindow[i].request.args.data.frame;\n    if (!networkRequestIsRenderBlockingInFrame(requestsInInvalidationWindow[i].request, mainFrameId)) {\n      continue;\n    }\n    renderBlockingRequests.push(requestsInInvalidationWindow[i] as RenderBlockingRequest);\n  }\n  return renderBlockingRequests;\n}\n\nfunction firstIframeInDOMTree(root: Protocol.DOM.Node): Protocol.DOM.Node|null {\n  if (root.nodeName === 'IFRAME') {\n    return root;\n  }\n  const children = root.children;\n  if (!children) {\n    return null;\n  }\n  for (const child of children) {\n    const iFrameInChild = firstIframeInDOMTree(child);\n    if (iFrameInChild) {\n      return iFrameInChild;\n    }\n  }\n  return null;\n}\n\nfunction cssPropertyIsExplicitlySet(propertyValue: string): boolean {\n  return !['auto', 'initial', 'unset', 'inherit'].includes(propertyValue);\n}\n\nfunction htmlAttributeIsExplicit(attr: {value: string}): boolean {\n  return parseInt(attr.value, 10) >= 0;\n}\n\nfunction computedStyleHasBackroundImage(computedStyle: Map<string, string>): boolean {\n  const CSS_URL_REGEX = /^url\\(\"([^\"]+)\"\\)$/;\n  const backgroundImage = computedStyle.get('background-image');\n  if (!backgroundImage) {\n    return false;\n  }\n  return CSS_URL_REGEX.test(backgroundImage);\n}\n\nfunction computedStyleHasFixedPosition(computedStyle: Map<string, string>): boolean {\n  const position = computedStyle.get('position');\n  if (!position) {\n    return false;\n  }\n  return position === 'fixed' || position === 'absolute';\n}\n\nfunction getNodeComputedDimensions(computedStyle: Map<string, string>): CSSDimensions {\n  const computedDimensions: CSSDimensions = {};\n  computedDimensions.height = computedStyle.get('height');\n  computedDimensions.width = computedStyle.get('width');\n  computedDimensions.aspectRatio = computedStyle.get('aspect-ratio');\n  return computedDimensions;\n}\n\n/**\n * Determines if a node is a media element and is not fixed positioned\n * (i.e. \"position: fixed;\" or \"position: absolute;\")\n */\nasync function nodeIsUnfixedMedia(node: Protocol.DOM.Node, computedStyle: Map<string, string>): Promise<boolean> {\n  const localName = node.localName;\n  const isBackgroundImage = computedStyleHasBackroundImage(computedStyle);\n  if (localName !== 'img' && localName !== 'video' && !isBackgroundImage) {\n    // Not a media element.\n    return false;\n  }\n  const isFixed = computedStyleHasFixedPosition(computedStyle);\n  return !isFixed;\n}\n\n/**\n * Determines if a CSS dimensions object explicitly defines both width and height\n * (i.e. not set to auto, inherit, etc.)\n */\nfunction dimensionsAreExplicit(dimensions: CSSDimensions): boolean {\n  const {height, width, aspectRatio} = dimensions;\n\n  const explicitHeight = Boolean(height && cssPropertyIsExplicitlySet(height));\n  const explicitWidth = Boolean(width && cssPropertyIsExplicitlySet(width));\n  const explicitAspectRatio = Boolean(aspectRatio && cssPropertyIsExplicitlySet(aspectRatio));\n\n  const explicitWithAR = (explicitHeight || explicitWidth) && explicitAspectRatio;\n  return (explicitHeight && explicitWidth) || explicitWithAR;\n}\n\n/**\n * Given an array of layout shift and PrePaint events, returns a mapping from\n * PrePaint events to layout shifts dispatched within it.\n */\nfunction getShiftsByPrePaintEvents(\n    layoutShifts: Types.TraceEvents.TraceEventLayoutShift[],\n    prePaintEvents: Types.TraceEvents.TraceEventPrePaint[],\n    ): Map<Types.TraceEvents.TraceEventPrePaint, Types.TraceEvents.TraceEventLayoutShift[]> {\n  // Maps from PrePaint events to LayoutShifts that occured in each one.\n  const shiftsByPrePaint = new Map<Types.TraceEvents.TraceEventPrePaint, Types.TraceEvents.TraceEventLayoutShift[]>();\n\n  // Associate all shifts to their corresponding PrePaint.\n  for (const prePaintEvent of prePaintEvents) {\n    const firstShiftIndex =\n        Platform.ArrayUtilities.nearestIndexFromBeginning(layoutShifts, shift => shift.ts >= prePaintEvent.ts);\n    if (firstShiftIndex === null) {\n      // No layout shifts registered after this PrePaint start. Continue.\n      continue;\n    }\n    for (let i = firstShiftIndex; i < layoutShifts.length; i++) {\n      const shift = layoutShifts[i];\n      if (shift.ts >= prePaintEvent.ts && shift.ts <= prePaintEvent.ts + prePaintEvent.dur) {\n        const shiftsInPrePaint = Platform.MapUtilities.getWithDefault(shiftsByPrePaint, prePaintEvent, () => []);\n        shiftsInPrePaint.push(shift);\n      }\n      if (shift.ts > prePaintEvent.ts + prePaintEvent.dur) {\n        // Reached the end of this PrePaint. Continue to the next one.\n        break;\n      }\n    }\n  }\n  return shiftsByPrePaint;\n}\n"]}