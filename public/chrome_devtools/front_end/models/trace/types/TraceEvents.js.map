{"version":3,"file":"TraceEvents.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/types/TraceEvents.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable no-unused-private-class-members */\nimport type * as Protocol from '../../../generated/protocol.js';\n\nimport {type MicroSeconds, type MilliSeconds, type Seconds} from './Timing.js';\n\n// Trace Events.\nexport const enum Phase {\n  // Standard\n  BEGIN = 'B',\n  END = 'E',\n  COMPLETE = 'X',\n  INSTANT = 'I',\n  COUNTER = 'C',\n\n  // Async\n  ASYNC_NESTABLE_START = 'b',\n  ASYNC_NESTABLE_INSTANT = 'n',\n  ASYNC_NESTABLE_END = 'e',\n  ASYNC_STEP_INTO = 'T',\n  ASYNC_BEGIN = 'S',\n  ASYNC_END = 'F',\n  ASYNC_STEP_PAST = 'p',\n\n  // Flow\n  FLOW_START = 's',\n  FLOW_STEP = 't',\n  FLOW_END = 'f',\n\n  // Sample\n  SAMPLE = 'P',\n\n  // Object\n  OBJECT_CREATED = 'N',\n  OBJECT_SNAPSHOT = 'O',\n  OBJECT_DESTROYED = 'D',\n\n  // Metadata\n  METADATA = 'M',\n\n  // Memory Dump\n  MEMORY_DUMP_GLOBAL = 'V',\n  MEMORY_DUMP_PROCESS = 'v',\n\n  // Mark\n  MARK = 'R',\n\n  // Clock sync\n  CLOCK_SYNC = 'c',\n}\n\nexport function isNestableAsyncPhase(phase: Phase): boolean {\n  return phase === Phase.ASYNC_NESTABLE_START || phase === Phase.ASYNC_NESTABLE_END ||\n      phase === Phase.ASYNC_NESTABLE_INSTANT;\n}\n\nexport function isAsyncPhase(phase: Phase): boolean {\n  return isNestableAsyncPhase(phase) || phase === Phase.ASYNC_BEGIN || phase === Phase.ASYNC_STEP_INTO ||\n      phase === Phase.ASYNC_END || phase === Phase.ASYNC_STEP_PAST;\n}\n\nexport function isFlowPhase(phase: Phase): boolean {\n  return phase === Phase.FLOW_START || phase === Phase.FLOW_STEP || phase === Phase.FLOW_END;\n}\n\nexport const enum TraceEventScope {\n  THREAD = 't',\n  PROCESS = 'p',\n  GLOBAL = 'g',\n}\n\nexport interface TraceEventData {\n  args?: TraceEventArgs;\n  cat: string;\n  name: string;\n  ph: Phase;\n  pid: ProcessID;\n  tid: ThreadID;\n  tts?: MicroSeconds;\n  ts: MicroSeconds;\n  tdur?: MicroSeconds;\n  dur?: MicroSeconds;\n}\n\nexport interface TraceEventArgs {\n  data?: TraceEventArgsData;\n}\n\nexport interface TraceEventArgsData {\n  stackTrace?: TraceEventCallFrame[];\n  url?: string;\n  navigationId?: string;\n  frame?: string;\n}\n\nexport interface TraceEventCallFrame {\n  codeType?: string;\n  functionName: string;\n  // Trace events are inconsistent here sadly :(\n  scriptId: number|string;\n  columnNumber: number;\n  lineNumber: number;\n  url: string;\n}\n\nexport function objectIsTraceEventCallFrame(object: {}): object is TraceEventCallFrame {\n  return ('functionName' in object && typeof object.functionName === 'string') &&\n      ('scriptId' in object && (typeof object.scriptId === 'string' || typeof object.scriptId === 'number')) &&\n      ('columnNumber' in object && typeof object.columnNumber === 'number') &&\n      ('lineNumber' in object && typeof object.lineNumber === 'number') &&\n      ('url' in object && typeof object.url === 'string');\n}\n\nexport interface TraceFrame {\n  frame: string;\n  name: string;\n  processId: ProcessID;\n  url: string;\n  parent?: string;\n  // Added to Chromium in April 2024:\n  // crrev.com/c/5424783\n  isOutermostMainFrame?: boolean;\n  // Added to Chromium in June 2024:\n  // crrev.com/c/5595033\n  isInPrimaryMainFrame?: boolean;\n}\n\n// Sample events.\n\nexport interface TraceEventSample extends TraceEventData {\n  ph: Phase.SAMPLE;\n}\n\n/**\n * A fake trace event created to support CDP.Profiler.Profiles in the\n * trace engine.\n */\nexport interface SyntheticCpuProfile extends TraceEventInstant, SyntheticBasedEvent<Phase.INSTANT> {\n  name: 'CpuProfile';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      cpuProfile: Protocol.Profiler.Profile,\n    },\n  };\n}\n\nexport interface TraceEventProfile extends TraceEventSample {\n  name: 'Profile';\n  id: ProfileID;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      startTime: MicroSeconds,\n    },\n  };\n}\n\nexport interface TraceEventProfileChunk extends TraceEventSample {\n  name: 'ProfileChunk';\n  id: ProfileID;\n  args: TraceEventArgs&{\n    // `data` is only missing in \"fake\" traces\n    data?: TraceEventArgsData & {\n      cpuProfile?: TraceEventPartialProfile,\n      timeDeltas?: MicroSeconds[],\n      lines?: MicroSeconds[],\n    },\n  };\n}\n\nexport interface TraceEventPartialProfile {\n  nodes?: TraceEventPartialNode[];\n  samples: CallFrameID[];\n}\n\nexport interface TraceEventPartialNode {\n  callFrame: TraceEventCallFrame;\n  id: CallFrameID;\n  parent?: CallFrameID;\n}\n\n// Complete events.\n\nexport interface TraceEventComplete extends TraceEventData {\n  ph: Phase.COMPLETE;\n  dur: MicroSeconds;\n}\n\nexport interface TraceEventRunTask extends TraceEventComplete {\n  name: KnownEventName.RunTask;\n}\nexport function isTraceEventRunTask(event: TraceEventData): event is TraceEventRunTask {\n  return event.name === KnownEventName.RunTask;\n}\n\nexport interface TraceEventFireIdleCallback extends TraceEventComplete {\n  name: KnownEventName.FireIdleCallback;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      allottedMilliseconds: MilliSeconds,\n      frame: string,\n      id: number,\n      timedOut: boolean,\n    },\n  };\n}\n\nexport interface TraceEventSchedulePostMessage extends TraceEventInstant {\n  name: KnownEventName.SchedulePostMessage;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      traceId: string,\n    },\n  };\n}\n\nexport interface TraceEventHandlePostMessage extends TraceEventComplete {\n  name: KnownEventName.HandlePostMessage;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      traceId: string,\n    },\n  };\n}\n\nexport interface TraceEventDispatch extends TraceEventComplete {\n  name: 'EventDispatch';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      type: string,\n    },\n  };\n}\n\nexport interface TraceEventParseHTML extends TraceEventComplete {\n  name: 'ParseHTML';\n  args: TraceEventArgs&{\n    beginData: {\n      frame: string,\n      startLine: number,\n      url: string,\n    },\n    endData?: {\n      endLine: number,\n    },\n  };\n}\n\nexport interface TraceEventBegin extends TraceEventData {\n  ph: Phase.BEGIN;\n}\n\nexport interface TraceEventEnd extends TraceEventData {\n  ph: Phase.END;\n}\n\n/**\n * This denotes a complete event created from a pair of begin and end\n * events. For practicality, instead of always having to look for the\n * end event corresponding to a begin event, we create a synthetic\n * complete event that comprises the data of both from the beginning in\n * the RendererHandler.\n */\nexport type SyntheticCompleteEvent = TraceEventComplete;\n\nexport interface TraceEventEventTiming extends TraceEventData {\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_END;\n  name: KnownEventName.EventTiming;\n  id: string;\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      cancelable: boolean,\n      duration: MilliSeconds,\n      processingEnd: MilliSeconds,\n      processingStart: MilliSeconds,\n      timeStamp: MilliSeconds,\n      interactionId?: number, type: string,\n    },\n  };\n}\n\nexport interface TraceEventEventTimingBegin extends TraceEventEventTiming {\n  ph: Phase.ASYNC_NESTABLE_START;\n}\nexport interface TraceEventEventTimingEnd extends TraceEventEventTiming {\n  ph: Phase.ASYNC_NESTABLE_END;\n}\n\nexport interface TraceEventGPUTask extends TraceEventComplete {\n  name: 'GPUTask';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      /* eslint-disable @typescript-eslint/naming-convention */\n      renderer_pid: ProcessID,\n      used_bytes: number,\n      /* eslint-enable @typescript-eslint/naming-convention */\n    },\n  };\n}\n\nexport interface SyntheticNetworkRedirect {\n  url: string;\n  priority: string;\n  requestMethod?: string;\n  ts: MicroSeconds;\n  dur: MicroSeconds;\n}\n\n// TraceEventProcessedArgsData is used to store the processed data of a network\n// request. Which is used to distinguish from the date we extract from the\n// trace event directly.\ninterface SyntheticArgsData {\n  dnsLookup: MicroSeconds;\n  download: MicroSeconds;\n  downloadStart: MicroSeconds;\n  finishTime: MicroSeconds;\n  initialConnection: MicroSeconds;\n  isDiskCached: boolean;\n  isHttps: boolean;\n  isMemoryCached: boolean;\n  isPushedResource: boolean;\n  networkDuration: MicroSeconds;\n  processingDuration: MicroSeconds;\n  proxyNegotiation: MicroSeconds;\n  queueing: MicroSeconds;\n  redirectionDuration: MicroSeconds;\n  requestSent: MicroSeconds;\n  sendStartTime: MicroSeconds;\n  ssl: MicroSeconds;\n  stalled: MicroSeconds;\n  totalTime: MicroSeconds;\n  waiting: MicroSeconds;\n}\n\nexport interface SyntheticNetworkRequest extends TraceEventComplete, SyntheticBasedEvent<Phase.COMPLETE> {\n  rawSourceEvent: TraceEventData;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      syntheticData: SyntheticArgsData,\n      // All fields below are from TraceEventsForNetworkRequest,\n      // Required fields\n      decodedBodyLength: number,\n      encodedDataLength: number,\n      frame: string,\n      fromServiceWorker: boolean,\n      isLinkPreload: boolean,\n      mimeType: string,\n      priority: Protocol.Network.ResourcePriority,\n      initialPriority: Protocol.Network.ResourcePriority,\n      /**\n       * This is the protocol used to resolve the request.\n       *\n       * Note, this is not the same as URL.protocol.\n       *\n       * Example values (not exhaustive): http/0.9, http/1.0, http/1.1, http, h2, h3-Q050, data, blob\n       */\n      protocol: string,\n      redirects: SyntheticNetworkRedirect[],\n      renderBlocking: RenderBlocking,\n      requestId: string,\n      requestingFrameUrl: string,\n      statusCode: number,\n      resourceType: Protocol.Network.ResourceType,\n      responseHeaders: Array<{name: string, value: string}>,\n      fetchPriorityHint: FetchPriorityHint,\n      url: string,\n      /** True only if got a 'resourceFinish' event indicating a failure. */\n      failed: boolean,\n      /** True only if got a 'resourceFinish' event. */\n      finished: boolean,\n      connectionId: number,\n      connectionReused: boolean,\n      // Optional fields\n      initiator?: Initiator,\n      requestMethod?: string,\n      timing?: TraceEventResourceReceiveResponseTimingData,\n    },\n  };\n  cat: 'loading';\n  name: 'SyntheticNetworkRequest';\n  ph: Phase.COMPLETE;\n  dur: MicroSeconds;\n  tdur: MicroSeconds;\n  ts: MicroSeconds;\n  tts: MicroSeconds;\n  pid: ProcessID;\n  tid: ThreadID;\n}\n\nexport const enum AuctionWorkletType {\n  BIDDER = 'bidder',\n  SELLER = 'seller',\n  // Not expected to be used, but here as a fallback in case new types get\n  // added and we have yet to update the trace engine.\n  UNKNOWN = 'unknown',\n}\n\nexport interface SyntheticAuctionWorkletEvent extends TraceEventInstant, SyntheticBasedEvent<Phase.INSTANT> {\n  rawSourceEvent: TraceEventData;\n  name: 'SyntheticAuctionWorkletEvent';\n  // The PID that the AuctionWorklet is running in.\n  pid: ProcessID;\n  // URL\n  host: string;\n  // An ID used to pair up runningInProcessEvents with doneWithProcessEvents\n  target: string;\n  type: AuctionWorkletType;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      // There are two threads for a worklet that we care about, so we gather\n      // the thread_name events so we can know the PID and TID for them (and\n      // hence display the right events in the track for each thread)\n      utilityThread: TraceEventThreadName,\n      v8HelperThread: TraceEventThreadName,\n    } &\n        (\n              // This type looks odd, but this is because these events could either have:\n              // 1. Just the DoneWithProcess event\n              // 2. Just the RunningInProcess event\n              // 3. Both events\n              // But crucially it cannot have both events missing, hence listing all the\n              // allowed cases.\n              // Clang is disabled as the combination of nested types and optional\n              // properties cause it to weirdly indent some of the properties and make it\n              // very unreadable.\n              // clang-format off\n              {\n                runningInProcessEvent: TraceEventAuctionWorkletRunningInProcess,\n                doneWithProcessEvent: TraceEventAuctionWorkletDoneWithProcess,\n              } |\n              {\n                runningInProcessEvent?: TraceEventAuctionWorkletRunningInProcess,\n                doneWithProcessEvent: TraceEventAuctionWorkletDoneWithProcess,\n              } |\n              {\n                doneWithProcessEvent?: TraceEventAuctionWorkletDoneWithProcess,\n                runningInProcessEvent: TraceEventAuctionWorkletRunningInProcess,\n\n              }),\n    // clang-format on\n  };\n}\nexport interface TraceEventAuctionWorkletRunningInProcess extends TraceEventData {\n  name: 'AuctionWorkletRunningInProcess';\n  ph: Phase.INSTANT;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      host: string,\n      pid: ProcessID,\n      target: string,\n      type: AuctionWorkletType,\n    },\n  };\n}\nexport interface TraceEventAuctionWorkletDoneWithProcess extends TraceEventData {\n  name: 'AuctionWorkletDoneWithProcess';\n  ph: Phase.INSTANT;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      host: string,\n      pid: ProcessID,\n      target: string,\n      type: AuctionWorkletType,\n    },\n  };\n}\n\nexport function isTraceEventAuctionWorkletRunningInProcess(event: TraceEventData):\n    event is TraceEventAuctionWorkletRunningInProcess {\n  return event.name === 'AuctionWorkletRunningInProcess';\n}\nexport function isTraceEventAuctionWorkletDoneWithProcess(event: TraceEventData):\n    event is TraceEventAuctionWorkletDoneWithProcess {\n  return event.name === 'AuctionWorkletDoneWithProcess';\n}\n\n// Snapshot events.\n\nexport interface TraceEventScreenshot extends TraceEventData {\n  /**\n   * @deprecated This value is incorrect. Use ScreenshotHandler.getPresentationTimestamp()\n   */\n  ts: MicroSeconds;\n  /** The id is the frame sequence number in hex */\n  id: string;\n  args: TraceEventArgs&{\n    snapshot: string,\n  };\n  name: KnownEventName.Screenshot;\n  cat: 'disabled-by-default-devtools.screenshot';\n  ph: Phase.OBJECT_SNAPSHOT;\n}\nexport function isTraceEventScreenshot(event: TraceEventData): event is TraceEventScreenshot {\n  return event.name === KnownEventName.Screenshot;\n}\n\nexport interface SyntheticScreenshot extends TraceEventData, SyntheticBasedEvent {\n  rawSourceEvent: TraceEventScreenshot;\n  /** This is the correct presentation timestamp. */\n  ts: MicroSeconds;\n  args: TraceEventArgs&{\n    dataUri: string,\n  };\n  name: KnownEventName.Screenshot;\n  cat: 'disabled-by-default-devtools.screenshot';\n  ph: Phase.OBJECT_SNAPSHOT;\n}\n\n// Animation events.\n\nexport interface TraceEventAnimation extends TraceEventData {\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      nodeName?: string,\n      nodeId?: number,\n      displayName?: string,\n      id?: string,\n      name?: string,\n      state?: string,\n      compositeFailed?: number,\n      unsupportedProperties?: string[],\n    },\n  };\n  name: 'Animation';\n  id2?: {\n    local?: string,\n  };\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_END|Phase.ASYNC_NESTABLE_INSTANT;\n}\n\n// Metadata events.\n\nexport interface TraceEventMetadata extends TraceEventData {\n  ph: Phase.METADATA;\n  args: TraceEventArgs&{\n    name?: string,\n    uptime?: string,\n  };\n}\n\nexport interface TraceEventThreadName extends TraceEventMetadata {\n  name: KnownEventName.ThreadName;\n  args: TraceEventArgs&{\n    name?: string,\n  };\n}\n\nexport interface TraceEventProcessName extends TraceEventMetadata {\n  name: 'process_name';\n}\n\n// Mark events.\n\nexport interface TraceEventMark extends TraceEventData {\n  ph: Phase.MARK;\n}\n\nexport interface TraceEventNavigationStart extends TraceEventMark {\n  name: 'navigationStart';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      documentLoaderURL: string,\n      isLoadingMainFrame: boolean,\n      // isOutermostMainFrame was introduced in crrev.com/c/3625434 and exists\n      // because of Fenced Frames\n      // [github.com/WICG/fenced-frame/tree/master/explainer].\n      // Fenced frames introduce a situation where isLoadingMainFrame could be\n      // true for a navigation, but that navigation be within an embedded \"main\n      // frame\", and therefore it wouldn't be on the top level main frame.\n      // In situations where we need to distinguish that, we can rely on\n      // isOutermostMainFrame, which will only be true for navigations on the\n      // top level main frame.\n\n      // This flag is optional as it was introduced in May 2022; so users\n      // reasonably may import traces from before that date that do not have\n      // this field present.\n      isOutermostMainFrame?: boolean, navigationId: string,\n    },\n        frame: string,\n  };\n}\n\nexport interface TraceEventFirstContentfulPaint extends TraceEventMark {\n  name: KnownEventName.MarkFCP;\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      navigationId: string,\n    },\n  };\n}\n\nexport interface TraceEventFirstPaint extends TraceEventMark {\n  name: 'firstPaint';\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      navigationId: string,\n    },\n  };\n}\n\nexport type PageLoadEvent = TraceEventFirstContentfulPaint|TraceEventMarkDOMContent|TraceEventInteractiveTime|\n    TraceEventLargestContentfulPaintCandidate|TraceEventLayoutShift|TraceEventFirstPaint|TraceEventMarkLoad|\n    TraceEventNavigationStart;\n\nconst markerTypeGuards = [\n  isTraceEventMarkDOMContent,\n  isTraceEventMarkLoad,\n  isTraceEventFirstPaint,\n  isTraceEventFirstContentfulPaint,\n  isTraceEventLargestContentfulPaintCandidate,\n  isTraceEventNavigationStart,\n];\n\nexport const MarkerName =\n    ['MarkDOMContent', 'MarkLoad', 'firstPaint', 'firstContentfulPaint', 'largestContentfulPaint::Candidate'] as const;\n\nexport interface MarkerEvent extends TraceEventData {\n  name: typeof MarkerName[number];\n}\n\nexport function isTraceEventMarkerEvent(event: TraceEventData): event is MarkerEvent {\n  return markerTypeGuards.some(fn => fn(event));\n}\n\nconst pageLoadEventTypeGuards = [\n  ...markerTypeGuards,\n  isTraceEventInteractiveTime,\n];\n\nexport function eventIsPageLoadEvent(event: TraceEventData): event is PageLoadEvent {\n  return pageLoadEventTypeGuards.some(fn => fn(event));\n}\n\nexport interface TraceEventLargestContentfulPaintCandidate extends TraceEventMark {\n  name: KnownEventName.MarkLCPCandidate;\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      candidateIndex: number,\n      isOutermostMainFrame: boolean,\n      isMainFrame: boolean,\n      navigationId: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n      loadingAttr: string,\n      type?: string,\n    },\n  };\n}\nexport interface TraceEventLargestImagePaintCandidate extends TraceEventMark {\n  name: 'LargestImagePaint::Candidate';\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      candidateIndex: number,\n      imageUrl: string,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      DOMNodeId: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\nexport interface TraceEventLargestTextPaintCandidate extends TraceEventMark {\n  name: 'LargestTextPaint::Candidate';\n  args: TraceEventArgs&{\n    frame: string,\n    data?: TraceEventArgsData&{\n      candidateIndex: number,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      DOMNodeId: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\n\nexport interface TraceEventInteractiveTime extends TraceEventMark {\n  name: 'InteractiveTime';\n  args: TraceEventArgs&{\n    args: {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      total_blocking_time_ms: number,\n    },\n    frame: string,\n  };\n}\n\n// Instant events.\n\nexport interface TraceEventInstant extends TraceEventData {\n  ph: Phase.INSTANT;\n  s: TraceEventScope;\n}\n\nexport interface TraceEventUpdateCounters extends TraceEventInstant {\n  name: 'UpdateCounters';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      documents: number,\n      jsEventListeners: number,\n      jsHeapSizeUsed: number,\n      nodes: number,\n      gpuMemoryLimitKB?: number,\n    },\n  };\n}\n\nexport type TraceEventRendererEvent = TraceEventInstant|TraceEventComplete;\n\nexport interface TraceEventTracingStartedInBrowser extends TraceEventInstant {\n  name: KnownEventName.TracingStartedInBrowser;\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      frameTreeNodeId: number,\n      // Frames can only missing in \"fake\" traces\n      frames?: TraceFrame[], persistentIds: boolean,\n    },\n  };\n}\n\nexport interface TraceEventTracingSessionIdForWorker extends TraceEventInstant {\n  name: 'TracingSessionIdForWorker';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      url: string,\n      workerId: WorkerId,\n      workerThreadId: ThreadID,\n      frame: string,\n    },\n  };\n}\nexport function isTraceEventTracingSessionIdForWorker(event: TraceEventData):\n    event is TraceEventTracingSessionIdForWorker {\n  return event.name === 'TracingSessionIdForWorker';\n}\n\nexport interface TraceEventFrameCommittedInBrowser extends TraceEventInstant {\n  name: 'FrameCommittedInBrowser';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & TraceFrame,\n  };\n}\n\nexport interface TraceEventMainFrameViewport extends TraceEventInstant {\n  name: 'PaintTimingVisualizer::Viewport';\n  args: {\n    data: TraceEventArgsData&{\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      viewport_rect: number[],\n    },\n  };\n}\n\nexport interface TraceEventCommitLoad extends TraceEventInstant {\n  name: 'CommitLoad';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      frame: string,\n      isMainFrame: boolean,\n      name: string,\n      nodeId: number,\n      page: string,\n      parent: string,\n      url: string,\n    },\n  };\n}\n\nexport interface TraceEventMarkDOMContent extends TraceEventInstant {\n  name: 'MarkDOMContent';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      frame: string,\n      isMainFrame: boolean,\n      isOutermostMainFrame?: boolean, page: string,\n    },\n  };\n}\n\nexport interface TraceEventMarkLoad extends TraceEventInstant {\n  name: 'MarkLoad';\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      frame: string,\n      isMainFrame: boolean,\n      page: string,\n      isOutermostMainFrame?: boolean,\n    },\n  };\n}\n\nexport interface TraceEventAsync extends TraceEventData {\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_INSTANT|Phase.ASYNC_NESTABLE_END|Phase.ASYNC_STEP_INTO|\n      Phase.ASYNC_BEGIN|Phase.ASYNC_END|Phase.ASYNC_STEP_PAST;\n}\n\nexport type TraceRect = [number, number, number, number];\nexport type TraceImpactedNode = {\n  // These keys come from the trace data, so we have to use underscores.\n  /* eslint-disable @typescript-eslint/naming-convention */\n  new_rect: TraceRect,\n  node_id: Protocol.DOM.BackendNodeId,\n  old_rect: TraceRect,\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n\ntype LayoutShiftData = TraceEventArgsData&{\n  // These keys come from the trace data, so we have to use underscores.\n  /* eslint-disable @typescript-eslint/naming-convention */\n  cumulative_score: number,\n  frame_max_distance: number,\n  had_recent_input: boolean,\n  impacted_nodes: TraceImpactedNode[] | undefined,\n  is_main_frame: boolean,\n  overall_max_distance: number,\n  region_rects: TraceRect[],\n  score: number,\n  weighted_score_delta: number,\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n// These keys come from the trace data, so we have to use underscores.\nexport interface TraceEventLayoutShift extends TraceEventInstant {\n  name: 'LayoutShift';\n  normalized?: boolean;\n  args: TraceEventArgs&{\n    frame: string,\n    data?: LayoutShiftData,\n  };\n}\n\ninterface LayoutShiftSessionWindowData {\n  // The sum of the weighted score of all the shifts\n  // that belong to a session window.\n  cumulativeWindowScore: number;\n  // A consecutive generated in the frontend to\n  // to identify a session window.\n  id: number;\n}\nexport interface LayoutShiftParsedData {\n  screenshotSource?: string;\n  timeFromNavigation?: MicroSeconds;\n  // The sum of the weighted scores of the shifts that\n  // belong to a session window up until this shift\n  // (inclusive).\n  cumulativeWeightedScoreInWindow: number;\n  sessionWindowData: LayoutShiftSessionWindowData;\n}\nexport interface SyntheticLayoutShift extends TraceEventLayoutShift, SyntheticBasedEvent<Phase.INSTANT> {\n  name: 'LayoutShift';\n  rawSourceEvent: TraceEventLayoutShift;\n  args: TraceEventArgs&{\n    frame: string,\n    data?: LayoutShiftData&{\n      rawEvent: TraceEventLayoutShift,\n    },\n  };\n  parsedData: LayoutShiftParsedData;\n}\n\nexport type FetchPriorityHint = 'low'|'high'|'auto';\nexport type RenderBlocking = 'blocking'|'non_blocking'|'in_body_parser_blocking'|'potentially_blocking';\n\nexport interface Initiator {\n  type: Protocol.Network.InitiatorType;\n  fetchType: string;\n  columnNumber?: number;\n  lineNumber?: number;\n  url?: string;\n}\n\nexport interface TraceEventResourceSendRequest extends TraceEventInstant {\n  name: 'ResourceSendRequest';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      requestId: string,\n      url: string,\n      priority: Protocol.Network.ResourcePriority,\n      resourceType: Protocol.Network.ResourceType,\n      fetchPriorityHint: FetchPriorityHint,\n      // TODO(crbug.com/1457985): change requestMethod to enum when confirm in the backend code.\n      requestMethod?: string,\n      renderBlocking?: RenderBlocking,\n      initiator?: Initiator,\n      isLinkPreload?: boolean,\n    },\n  };\n}\n\nexport interface TraceEventResourceChangePriority extends TraceEventInstant {\n  name: 'ResourceChangePriority';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      requestId: string,\n      priority: Protocol.Network.ResourcePriority,\n    },\n  };\n}\n\nexport interface TraceEventResourceWillSendRequest extends TraceEventInstant {\n  name: 'ResourceWillSendRequest';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      requestId: string,\n    },\n  };\n}\n\nexport interface TraceEventResourceFinish extends TraceEventInstant {\n  name: 'ResourceFinish';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      decodedBodyLength: number,\n      didFail: boolean,\n      encodedDataLength: number,\n      finishTime: Seconds,\n      requestId: string,\n    },\n  };\n}\n\nexport interface TraceEventResourceReceivedData extends TraceEventInstant {\n  name: 'ResourceReceivedData';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      encodedDataLength: number,\n      frame: string,\n      requestId: string,\n    },\n  };\n}\n\ninterface TraceEventResourceReceiveResponseTimingData {\n  connectEnd: MilliSeconds;\n  connectStart: MilliSeconds;\n  dnsEnd: MilliSeconds;\n  dnsStart: MilliSeconds;\n  proxyEnd: MilliSeconds;\n  proxyStart: MilliSeconds;\n  pushEnd: MilliSeconds;\n  pushStart: MilliSeconds;\n  receiveHeadersEnd: MilliSeconds;\n  receiveHeadersStart: MilliSeconds;\n  requestTime: Seconds;\n  sendEnd: MilliSeconds;\n  sendStart: MilliSeconds;\n  sslEnd: MilliSeconds;\n  sslStart: MilliSeconds;\n  workerReady: MilliSeconds;\n  workerStart: MilliSeconds;\n}\n\nexport interface TraceEventResourceReceiveResponse extends TraceEventInstant {\n  name: 'ResourceReceiveResponse';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      /**\n       * This is the protocol used to resolve the request.\n       *\n       * Note, this is not the same as URL.protocol.\n       *\n       * Example values (not exhaustive): http/0.9, http/1.0, http/1.1, http, h2, h3-Q050, data, blob\n       */\n      protocol: string,\n      encodedDataLength: number,\n      frame: string,\n      fromCache: boolean,\n      fromServiceWorker: boolean,\n      mimeType: string,\n      requestId: string,\n      responseTime: MilliSeconds,\n      statusCode: number,\n      timing: TraceEventResourceReceiveResponseTimingData,\n      connectionId: number,\n      connectionReused: boolean,\n      headers?: Array<{name: string, value: string}>,\n    },\n  };\n}\n\nexport interface TraceEventResourceMarkAsCached extends TraceEventInstant {\n  name: 'ResourceMarkAsCached';\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      requestId: string,\n    },\n  };\n}\n\nexport const enum LayoutInvalidationReason {\n  SIZE_CHANGED = 'Size changed',\n  ATTRIBUTE = 'Attribute',\n  ADDED_TO_LAYOUT = 'Added to layout',\n  SCROLLBAR_CHANGED = 'Scrollbar changed',\n  REMOVED_FROM_LAYOUT = 'Removed from layout',\n  STYLE_CHANGED = 'Style changed',\n  FONTS_CHANGED = 'Fonts changed',\n  UNKNOWN = 'Unknown',\n}\n\nexport interface TraceEventLayoutInvalidationTracking extends TraceEventInstant {\n  name: KnownEventName.LayoutInvalidationTracking;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n      reason: LayoutInvalidationReason,\n      nodeName?: string,\n    },\n  };\n}\n\nexport interface TraceEventScheduleStyleInvalidationTracking extends TraceEventInstant {\n  name: KnownEventName.ScheduleStyleInvalidationTracking;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n      invalidationSet?: string,\n      invalidatedSelectorId?: string,\n      reason?: LayoutInvalidationReason,\n      changedClass?: string,\n      changedAttribute?: string,\n      changedId?: string,\n      nodeName?: string,\n      stackTrace?: TraceEventCallFrame[],\n    },\n  };\n}\nexport function isTraceEventScheduleStyleInvalidationTracking(event: TraceEventData):\n    event is TraceEventScheduleStyleInvalidationTracking {\n  return event.name === KnownEventName.ScheduleStyleInvalidationTracking;\n}\n\nexport const enum StyleRecalcInvalidationReason {\n  ANIMATION = 'Animation',\n}\n\nexport interface TraceEventStyleRecalcInvalidationTracking extends TraceEventInstant {\n  name: KnownEventName.StyleRecalcInvalidationTracking;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n      reason: StyleRecalcInvalidationReason,\n      subtree: boolean,\n      nodeName?: string,\n      extraData?: string,\n    },\n  };\n}\n\nexport function isTraceEventStyleRecalcInvalidationTracking(event: TraceEventData):\n    event is TraceEventStyleRecalcInvalidationTracking {\n  return event.name === KnownEventName.StyleRecalcInvalidationTracking;\n}\nexport interface TraceEventStyleInvalidatorInvalidationTracking extends TraceEventInstant {\n  name: KnownEventName.StyleInvalidatorInvalidationTracking;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n      reason: string,\n      invalidationList: Array<{classes?: string[], id: string}>,\n      subtree: boolean,\n      nodeName?: string,\n      extraData?: string,\n    },\n  };\n}\nexport function isTraceEventStyleInvalidatorInvalidationTracking(event: TraceEventData):\n    event is TraceEventStyleInvalidatorInvalidationTracking {\n  return event.name === KnownEventName.StyleInvalidatorInvalidationTracking;\n}\n\nexport interface TraceEventBeginCommitCompositorFrame extends TraceEventInstant {\n  name: KnownEventName.BeginCommitCompositorFrame;\n  args: TraceEventArgs&{\n    frame: string,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    is_mobile_optimized: boolean,\n  };\n}\nexport function isTraceEventBeginCommitCompositorFrame(event: TraceEventData):\n    event is TraceEventBeginCommitCompositorFrame {\n  return event.name === KnownEventName.BeginCommitCompositorFrame;\n}\n\nexport interface TraceEventScheduleStyleRecalculation extends TraceEventInstant {\n  name: KnownEventName.ScheduleStyleRecalculation;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n    },\n  };\n}\nexport function isTraceEventScheduleStyleRecalculation(event: TraceEventData):\n    event is TraceEventScheduleStyleRecalculation {\n  return event.name === KnownEventName.ScheduleStyleRecalculation;\n}\n\nexport interface TraceEventRenderFrameImplCreateChildFrame extends TraceEventData {\n  name: KnownEventName.RenderFrameImplCreateChildFrame;\n  /* eslint-disable @typescript-eslint/naming-convention */\n  args: TraceEventArgs&{\n    child_frame_token: string,\n    frame_token: string,\n  };\n}\nexport function isTraceEventRenderFrameImplCreateChildFrame(event: TraceEventData):\n    event is TraceEventRenderFrameImplCreateChildFrame {\n  return event.name === KnownEventName.RenderFrameImplCreateChildFrame;\n}\n\nexport interface TraceEventPrePaint extends TraceEventComplete {\n  name: 'PrePaint';\n}\n\nexport interface TraceEventPairableAsync extends TraceEventData {\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_END|Phase.ASYNC_NESTABLE_INSTANT;\n  // The id2 field gives flexibility to explicitly specify if an event\n  // id is global among processes or process local. However not all\n  // events use it, so both kind of ids need to be marked as optional.\n  id2?: {local?: string, global?: string};\n  id?: string;\n}\nexport interface TraceEventPairableAsyncBegin extends TraceEventPairableAsync {\n  ph: Phase.ASYNC_NESTABLE_START;\n}\n\nexport interface TraceEventPairableAsyncInstant extends TraceEventPairableAsync {\n  ph: Phase.ASYNC_NESTABLE_INSTANT;\n}\n\nexport interface TraceEventPairableAsyncEnd extends TraceEventPairableAsync {\n  ph: Phase.ASYNC_NESTABLE_END;\n}\n\nexport interface TraceEventUserTiming extends TraceEventData {\n  id2?: {local?: string, global?: string};\n  id?: string;\n  cat: 'blink.user_timing';\n  // Note that the timestamp for user timing trace events is set to the\n  // start time passed by the user at the call site of the timing (based\n  // on the UserTiming spec).\n  // https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/performance_user_timing.cc;l=236;drc=494419358caf690316f160a1f27d9e771a14c033\n}\n\nexport type TraceEventPairableUserTiming = TraceEventUserTiming&TraceEventPairableAsync;\n\nexport interface TraceEventPerformanceMeasureBegin extends TraceEventPairableUserTiming {\n  args: TraceEventArgs&{\n    detail?: string,\n  };\n  ph: Phase.ASYNC_NESTABLE_START;\n}\n\nexport type TraceEventPerformanceMeasureEnd = TraceEventPairableUserTiming&TraceEventPairableAsyncEnd;\nexport type TraceEventPerformanceMeasure = TraceEventPerformanceMeasureBegin|TraceEventPerformanceMeasureEnd;\n\nexport interface TraceEventPerformanceMark extends TraceEventUserTiming {\n  args: TraceEventArgs&{\n    data?: TraceEventArgsData & {\n      detail?: string,\n    },\n  };\n  ph: Phase.INSTANT|Phase.MARK|Phase.ASYNC_NESTABLE_INSTANT;\n}\n\nexport interface TraceEventConsoleTimeBegin extends TraceEventPairableAsyncBegin {\n  cat: 'blink.console';\n}\n\nexport interface TraceEventConsoleTimeEnd extends TraceEventPairableAsyncEnd {\n  cat: 'blink.console';\n}\n\nexport type TraceEventConsoleTime = TraceEventConsoleTimeBegin|TraceEventConsoleTimeEnd;\n\nexport interface TraceEventTimeStamp extends TraceEventData {\n  cat: 'devtools.timeline';\n  name: 'TimeStamp';\n  ph: Phase.INSTANT;\n  id: string;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      message: string,\n    },\n  };\n}\n\n/** ChromeFrameReporter args for PipelineReporter event.\n    Matching proto: https://source.chromium.org/chromium/chromium/src/+/main:third_party/perfetto/protos/perfetto/trace/track_event/chrome_frame_reporter.proto\n */\n/* eslint-disable @typescript-eslint/naming-convention */\ninterface ChromeFrameReporter {\n  state: State;\n  enum: FrameDropReason;\n  /** The reason is set only if |state| is not |STATE_UPDATED_ALL|. */\n  reason: FrameDropReason;\n  frame_source: number;\n  /**  Identifies a BeginFrameArgs (along with the source_id).\n       See comments in components/viz/common/frame_sinks/begin_frame_args.h. */\n  frame_sequence: number;\n  /**  If this is a droped frame (i.e. if |state| is set to |STATE_DROPPED| or\n       |STATE_PRESENTED_PARTIAL|), then indicates whether this frame impacts smoothness. */\n  affects_smoothness: boolean;\n  /** The type of active scroll. */\n  scroll_state: ScrollState;\n  /** If any main thread animation is active during this frame. */\n  has_main_animation: boolean;\n  /** If any compositor thread animation is active during this frame. */\n  has_compositor_animation: boolean;\n  /** If any touch-driven UX (not scroll) is active during this frame. */\n  has_smooth_input_main: boolean;\n  /**  Whether the frame contained any missing content (i.e. whether there was\n       checkerboarding in the frame). */\n  has_missing_content: boolean;\n  /** The id of layer_tree_host that the frame has been produced for. */\n  layer_tree_host_id: number;\n  /** If total latency of PipelineReporter exceeds a certain limit. */\n  has_high_latency: boolean;\n  /**  Indicate if the frame is \"FORKED\" (i.e. a PipelineReporter event starts at\n       the same frame sequence as another PipelineReporter) or \"BACKFILL\"\n       (i.e. dropped frames when there are no partial compositor updates). */\n  frame_type: FrameType;\n  /**  The breakdown stage of PipelineReporter that is most likely accountable for\n       high latency. */\n  high_latency_contribution_stage: string[];\n}\nconst enum State {\n  /** The frame did not have any updates to present. **/\n  STATE_NO_UPDATE_DESIRED = 'STATE_NO_UPDATE_DESIRED',\n  /**  The frame presented all the desired updates (i.e. any updates requested\n       from both the compositor thread and main-threads were handled). **/\n  STATE_PRESENTED_ALL = 'STATE_PRESENTED_ALL',\n  /**  The frame was presented with some updates, but also missed some updates\n       (e.g. missed updates from the main-thread, but included updates from the\n        compositor thread). **/\n  STATE_PRESENTED_PARTIAL = 'STATE_PRESENTED_PARTIAL',\n  /**  The frame was dropped, i.e. some updates were desired for the frame, but\n       was not presented. **/\n  STATE_DROPPED = 'STATE_DROPPED',\n}\n\nconst enum FrameDropReason {\n  REASON_UNSPECIFIED = 'REASON_UNSPECIFIED',\n  /**  Frame was dropped by the display-compositor.\n         The display-compositor may drop a frame some times (e.g. the frame missed\n        the deadline, or was blocked on surface-sync, etc.) **/\n  REASON_DISPLAY_COMPOSITOR = 'REASON_DISPLAY_COMPOSITOR',\n  /**  Frame was dropped because of the main-thread.\n         The main-thread may cause a frame to be dropped, e.g. if the main-thread\n        is running expensive javascript, or doing a lot of layout updates, etc. **/\n  REASON_MAIN_THREAD = 'REASON_MAIN_THREAD',\n  /**  Frame was dropped by the client compositor.\n         The client compositor can drop some frames too (e.g. attempting to\n         recover latency, missing the deadline, etc.). **/\n  REASON_CLIENT_COMPOSITOR = 'REASON_CLIENT_COMPOSITOR',\n}\n\nconst enum ScrollState {\n  SCROLL_NONE = 'SCROLL_NONE',\n  SCROLL_MAIN_THREAD = 'SCROLL_MAIN_THREAD',\n  SCROLL_COMPOSITOR_THREAD = 'SCROLL_COMPOSITOR_THREAD',\n\n  /** Used when it can't be determined whether a scroll is in progress or not. */\n  SCROLL_UNKNOWN = 'SCROLL_UNKNOWN',\n}\nconst enum FrameType {\n  FORKED = 'FORKED',\n  BACKFILL = 'BACKFILL',\n}\n\nexport interface TraceEventPipelineReporter extends TraceEventData {\n  id2?: {\n    local?: string,\n  };\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_END;\n  args: TraceEventArgs&{\n    chrome_frame_reporter: ChromeFrameReporter,\n  };\n}\n\nexport function isTraceEventPipelineReporter(event: TraceEventData): event is TraceEventPipelineReporter {\n  return event.name === KnownEventName.PipelineReporter;\n}\n\n// A type used for synthetic events created based on a raw trace event.\nexport interface SyntheticBasedEvent<Ph extends Phase = Phase> extends SyntheticEntry {\n  ph: Ph;\n  rawSourceEvent: TraceEventData;\n}\n\n// A branded type is used to ensure not all events can be typed as\n// SyntheticEntry and prevent places different to the\n// SyntheticEventsManager from creating synthetic events. This is\n// because synthetic events need to be registered in order to resolve\n// serialized event keys into event objects, so we ensure events are\n// registered at the time they are created by the SyntheticEventsManager.\nexport type SyntheticEntry = TraceEventData&{_tag: 'SyntheticEntryTag'};\n\nexport function isSyntheticBasedEvent(event: TraceEventData): event is SyntheticBasedEvent {\n  return 'rawSourceEvent' in event;\n}\n\n// Nestable async events with a duration are made up of two distinct\n// events: the begin, and the end. We need both of them to be able to\n// display the right information, so we create these synthetic events.\nexport interface SyntheticEventPair<T extends TraceEventPairableAsync = TraceEventPairableAsync> extends\n    SyntheticBasedEvent {\n  rawSourceEvent: TraceEventData;\n  name: T['name'];\n  cat: T['cat'];\n  id?: string;\n  id2?: {local?: string, global?: string};\n\n  dur: MicroSeconds;\n  args: TraceEventArgs&{\n    data: {\n      beginEvent: T & TraceEventPairableAsyncBegin,\n      endEvent: T&TraceEventPairableAsyncEnd,\n      instantEvents?: Array<T&TraceEventPairableAsyncInstant>,\n    },\n  };\n}\n\nexport type SyntheticPipelineReporterPair = SyntheticEventPair<TraceEventPipelineReporter>;\n\nexport type SyntheticUserTimingPair = SyntheticEventPair<TraceEventPerformanceMeasure>;\n\nexport type SyntheticConsoleTimingPair = SyntheticEventPair<TraceEventConsoleTime>;\n\nexport type SyntheticAnimationPair = SyntheticEventPair<TraceEventAnimation>;\n\nexport interface SyntheticInteractionPair extends SyntheticEventPair<TraceEventEventTiming> {\n  // InteractionID and type are available within the beginEvent's data, but we\n  // put them on the top level for ease of access.\n  interactionId: number;\n  type: string;\n  // This is equivalent to startEvent.ts;\n  ts: MicroSeconds;\n  // This duration can be calculated via endEvent.ts - startEvent.ts, but we do\n  // that and put it here to make it easier. This also makes these events\n  // consistent with real events that have a dur field.\n  dur: MicroSeconds;\n  // These values are provided in the startEvent's args.data field as\n  // millisecond values, but during the handler phase we parse these into\n  // microseconds and put them on the top level for easy access.\n  processingStart: MicroSeconds;\n  processingEnd: MicroSeconds;\n  // These 3 values represent the breakdown of the parts of an interaction:\n  // 1. inputDelay: time from the user clicking to the input being handled\n  inputDelay: MicroSeconds;\n  // 2. mainThreadHandling: time spent processing the event handler\n  mainThreadHandling: MicroSeconds;\n  // 3. presentationDelay: delay between the event being processed and the frame being rendered\n  presentationDelay: MicroSeconds;\n}\n\n/**\n * An event created synthetically in the frontend that has a self time\n * (the time spent running the task itself).\n */\nexport interface SyntheticTraceEntry extends TraceEventData {\n  selfTime?: MicroSeconds;\n}\n\n/**\n * A profile call created in the frontend from samples disguised as a\n * trace event.\n *\n * We store the sampleIndex, profileId and nodeId so that we can easily link\n * back a Synthetic Trace Entry to an indivdual Sample trace event within a\n * Profile.\n *\n * Because a sample contains a set of call frames representing the stack at the\n * point in time that the sample was created, we also have to store the ID of\n * the Node that points to the function call that this profile call represents.\n */\nexport interface SyntheticProfileCall extends SyntheticTraceEntry {\n  callFrame: Protocol.Runtime.CallFrame;\n  nodeId: Protocol.integer;\n  sampleIndex: number;\n  profileId: ProfileID;\n  selfTime: MicroSeconds;\n}\n\n/**\n * A JS Sample reflects a single sample from the V8 CPU Profile\n */\nexport interface SyntheticJSSample extends SyntheticTraceEntry {\n  name: KnownEventName.JSSample;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      stackTrace: Protocol.Runtime.CallFrame[],\n    },\n  };\n  ph: Phase.INSTANT;\n}\n\n/**\n * A trace event augmented synthetically in the frontend to contain\n * its self time.\n */\nexport type SyntheticRendererEvent = TraceEventRendererEvent&SyntheticTraceEntry;\n\nexport function isSyntheticInteractionEvent(event: TraceEventData): event is SyntheticInteractionPair {\n  return Boolean(\n      'interactionId' in event && event.args?.data && 'beginEvent' in event.args.data && 'endEvent' in event.args.data);\n}\n\nexport function isSyntheticTraceEntry(event: TraceEventData): event is SyntheticTraceEntry {\n  return isTraceEventRendererEvent(event) || isProfileCall(event);\n}\n\n// Events relating to frames.\n\nexport interface TraceEventDrawFrame extends TraceEventInstant {\n  name: KnownEventName.DrawFrame;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameSeqId: number,\n  };\n}\n\nexport function isTraceEventDrawFrame(event: TraceEventData): event is TraceEventDrawFrame {\n  // The extra check for INSTANT here is because in the past DrawFrame events had an ASYNC_NESTABLE_START and ASYNC_NESTABLE_END pair. We don't want to support those old events, so we have to check we are dealing with an instant event.\n  return event.name === KnownEventName.DrawFrame && event.ph === Phase.INSTANT;\n}\nexport interface TraceEventLegacyDrawFrameBegin extends TraceEventAsync {\n  name: KnownEventName.DrawFrame;\n  ph: Phase.ASYNC_NESTABLE_START;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameSeqId: number,\n  };\n}\nexport function isLegacyTraceEventDrawFrameBegin(event: TraceEventData): event is TraceEventLegacyDrawFrameBegin {\n  return event.name === KnownEventName.DrawFrame && event.ph === Phase.ASYNC_NESTABLE_START;\n}\n\nexport interface TraceEventBeginFrame extends TraceEventInstant {\n  name: KnownEventName.BeginFrame;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameSeqId: number,\n  };\n}\nexport function isTraceEventBeginFrame(event: TraceEventData): event is TraceEventBeginFrame {\n  // Old traces did not have frameSeqId; but we do not want to support these.\n  return Boolean(event.name === KnownEventName.BeginFrame && event.args && 'frameSeqId' in event.args);\n}\n\nexport interface TraceEventDroppedFrame extends TraceEventInstant {\n  name: KnownEventName.DroppedFrame;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameSeqId: number,\n    hasPartialUpdate?: boolean,\n  };\n}\nexport function isTraceEventDroppedFrame(event: TraceEventData): event is TraceEventDroppedFrame {\n  // Old traces did not have frameSeqId; but we do not want to support these.\n  return Boolean(event.name === KnownEventName.DroppedFrame && event.args && 'frameSeqId' in event.args);\n}\n\nexport interface TraceEventRequestMainThreadFrame extends TraceEventInstant {\n  name: KnownEventName.RequestMainThreadFrame;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n  };\n}\nexport function isTraceEventRequestMainThreadFrame(event: TraceEventData): event is TraceEventRequestMainThreadFrame {\n  return event.name === KnownEventName.RequestMainThreadFrame;\n}\n\nexport interface TraceEventBeginMainThreadFrame extends TraceEventInstant {\n  name: KnownEventName.BeginMainThreadFrame;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    data: TraceEventArgsData&{\n      frameId?: number,\n    },\n  };\n}\nexport function isTraceEventBeginMainThreadFrame(event: TraceEventData): event is TraceEventBeginMainThreadFrame {\n  return event.name === KnownEventName.BeginMainThreadFrame;\n}\n\nexport interface TraceEventNeedsBeginFrameChanged extends TraceEventInstant {\n  name: KnownEventName.NeedsBeginFrameChanged;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    data: TraceEventArgsData&{\n      needsBeginFrame: number,\n    },\n  };\n}\nexport function isTraceEventNeedsBeginFrameChanged(event: TraceEventData): event is TraceEventNeedsBeginFrameChanged {\n  return event.name === KnownEventName.NeedsBeginFrameChanged;\n}\n\nexport interface TraceEventCommit extends TraceEventInstant {\n  name: KnownEventName.Commit;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameSeqId: number,\n  };\n}\nexport function isTraceEventCommit(event: TraceEventData): event is TraceEventCommit {\n  // Old traces did not have frameSeqId; but we do not want to support these.\n  return Boolean(event.name === KnownEventName.Commit && event.args && 'frameSeqId' in event.args);\n}\n\nexport interface TraceEventRasterTask extends TraceEventComplete {\n  name: KnownEventName.RasterTask;\n  args: TraceEventArgs&{\n    tileData?: {\n      layerId: number,\n      sourceFrameNumber: number,\n      tileId: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        id_ref: string,\n      },\n      tileResolution: string,\n    },\n  };\n}\nexport function isTraceEventRasterTask(event: TraceEventData): event is TraceEventRasterTask {\n  return event.name === KnownEventName.RasterTask;\n}\n\n// CompositeLayers has been replaced by \"Commit\", but we support both to not break old traces being imported.\nexport interface TraceEventCompositeLayers extends TraceEventInstant {\n  name: KnownEventName.CompositeLayers;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n  };\n}\nexport function isTraceEventCompositeLayers(event: TraceEventData): event is TraceEventCompositeLayers {\n  return event.name === KnownEventName.CompositeLayers;\n}\n\nexport interface TraceEventActivateLayerTree extends TraceEventInstant {\n  name: KnownEventName.ActivateLayerTree;\n  args: TraceEventArgs&{\n    layerTreeId: number,\n    frameId: number,\n  };\n}\nexport function isTraceEventActivateLayerTree(event: TraceEventData): event is TraceEventActivateLayerTree {\n  return event.name === KnownEventName.ActivateLayerTree;\n}\n\nexport interface SyntheticInvalidation extends TraceEventInstant {\n  name: 'SyntheticInvalidation';\n  nodeName?: string;\n  rawEvent: TraceEventScheduleStyleInvalidationTracking|TraceEventStyleRecalcInvalidationTracking|\n      TraceEventStyleInvalidatorInvalidationTracking|TraceEventLayoutInvalidationTracking;\n  nodeId: Protocol.DOM.BackendNodeId;\n  frame: string;\n  reason?: string;\n  stackTrace?: TraceEventCallFrame[];\n}\n\nexport function isSyntheticInvalidation(event: TraceEventData): event is SyntheticInvalidation {\n  return event.name === 'SyntheticInvalidation';\n}\n\nexport interface TraceEventDrawLazyPixelRef extends TraceEventInstant {\n  name: KnownEventName.DrawLazyPixelRef;\n  args?: TraceEventArgs&{\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LazyPixelRef: number,\n  };\n}\nexport function isTraceEventDrawLazyPixelRef(event: TraceEventData): event is TraceEventDrawLazyPixelRef {\n  return event.name === KnownEventName.DrawLazyPixelRef;\n}\n\nexport interface TraceEventDecodeLazyPixelRef extends TraceEventInstant {\n  name: KnownEventName.DecodeLazyPixelRef;\n  args?: TraceEventArgs&{\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LazyPixelRef: number,\n  };\n}\nexport function isTraceEventDecodeLazyPixelRef(event: TraceEventData): event is TraceEventDecodeLazyPixelRef {\n  return event.name === KnownEventName.DecodeLazyPixelRef;\n}\n\nexport interface TraceEventDecodeImage extends TraceEventComplete {\n  name: KnownEventName.DecodeImage;\n  args: TraceEventArgs&{\n    imageType: string,\n  };\n}\nexport function isTraceEventDecodeImage(event: TraceEventData): event is TraceEventDecodeImage {\n  return event.name === KnownEventName.DecodeImage;\n}\n\nexport interface SelectorTiming {\n  'elapsed (us)': number;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  'fast_reject_count': number;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  'match_attempts': number;\n  'selector': string;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  'style_sheet_id': string;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  'match_count': number;\n}\n\nexport interface SelectorStats {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  selector_timings: SelectorTiming[];\n}\n\nexport interface TraceEventSelectorStats extends TraceEventComplete {\n  name: KnownEventName.SelectorStats;\n  args: TraceEventArgs&{\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    selector_stats?: SelectorStats,\n  };\n}\n\nexport function isTraceEventSelectorStats(event: TraceEventData): event is TraceEventSelectorStats {\n  return event.name === KnownEventName.SelectorStats;\n}\n\nexport interface TraceEventUpdateLayoutTree extends TraceEventComplete {\n  name: KnownEventName.UpdateLayoutTree;\n  args: TraceEventArgs&{\n    elementCount: number,\n    beginData?: {\n      frame: string,\n      stackTrace?: TraceEventCallFrame[],\n    },\n  };\n}\nexport function isTraceEventUpdateLayoutTree(event: TraceEventData): event is TraceEventUpdateLayoutTree {\n  return event.name === KnownEventName.UpdateLayoutTree;\n}\n\nexport interface TraceEventLayout extends TraceEventComplete {\n  name: KnownEventName.Layout;\n  args: TraceEventArgs&{\n    beginData: {\n      frame: string,\n      dirtyObjects: number,\n      partialLayout: boolean,\n      totalObjects: number,\n    },\n    // endData is not reliably populated.\n    // Why? TBD. https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/local_frame_view.cc;l=847-851;drc=8b6aaad8027390ce6b32d82d57328e93f34bb8e5\n    endData?: {\n      layoutRoots: Array<{\n        depth: number,\n        nodeId: Protocol.DOM.BackendNodeId,\n        quads: number[][],\n      }>,\n    },\n  };\n}\nexport function isTraceEventLayout(event: TraceEventData): event is TraceEventLayout {\n  return event.name === KnownEventName.Layout;\n}\nexport interface TraceEventInvalidateLayout extends TraceEventInstant {\n  name: KnownEventName.InvalidateLayout;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      nodeId: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\nexport function isTraceEventInvalidateLayout(event: TraceEventData): event is TraceEventInvalidateLayout {\n  return event.name === KnownEventName.InvalidateLayout;\n}\n\nclass ProfileIdTag {\n  readonly #profileIdTag: (symbol|undefined);\n}\nexport type ProfileID = string&ProfileIdTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function ProfileID(value: string): ProfileID {\n  return value as ProfileID;\n}\n\nclass CallFrameIdTag {\n  readonly #callFrameIdTag: (symbol|undefined);\n}\nexport type CallFrameID = number&CallFrameIdTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CallFrameID(value: number): CallFrameID {\n  return value as CallFrameID;\n}\n\nclass SampleIndexTag {\n  readonly #sampleIndexTag: (symbol|undefined);\n}\nexport type SampleIndex = number&SampleIndexTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function SampleIndex(value: number): SampleIndex {\n  return value as SampleIndex;\n}\n\nclass ProcessIdTag {\n  readonly #processIdTag: (symbol|undefined);\n}\nexport type ProcessID = number&ProcessIdTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function ProcessID(value: number): ProcessID {\n  return value as ProcessID;\n}\n\nclass ThreadIdTag {\n  readonly #threadIdTag: (symbol|undefined);\n}\nexport type ThreadID = number&ThreadIdTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function ThreadID(value: number): ThreadID {\n  return value as ThreadID;\n}\n\nclass WorkerIdTag {\n  readonly #workerIdTag: (symbol|undefined);\n}\nexport type WorkerId = string&WorkerIdTag;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function WorkerId(value: string): WorkerId {\n  return value as WorkerId;\n}\n\nexport function isTraceEventComplete(event: TraceEventData): event is TraceEventComplete {\n  return event.ph === Phase.COMPLETE;\n}\n\nexport function isTraceEventBegin(event: TraceEventData): event is TraceEventBegin {\n  return event.ph === Phase.BEGIN;\n}\n\nexport function isTraceEventEnd(event: TraceEventData): event is TraceEventEnd {\n  return event.ph === Phase.END;\n}\n\nexport function isTraceEventDispatch(event: TraceEventData): event is TraceEventDispatch {\n  return event.name === 'EventDispatch';\n}\n\nexport function isTraceEventInstant(event: TraceEventData): event is TraceEventInstant {\n  return event.ph === Phase.INSTANT;\n}\n\nexport function isTraceEventRendererEvent(event: TraceEventData): event is TraceEventRendererEvent {\n  return isTraceEventInstant(event) || isTraceEventComplete(event);\n}\n\nexport function isTraceEventFireIdleCallback(event: TraceEventData): event is TraceEventFireIdleCallback {\n  return event.name === 'FireIdleCallback';\n}\n\nexport function isTraceEventSchedulePostMessage(event: TraceEventData): event is TraceEventSchedulePostMessage {\n  return event.name === KnownEventName.SchedulePostMessage;\n}\n\nexport function isTraceEventHandlePostMessage(event: TraceEventData): event is TraceEventHandlePostMessage {\n  return event.name === KnownEventName.HandlePostMessage;\n}\n\nexport function isTraceEventUpdateCounters(event: TraceEventData): event is TraceEventUpdateCounters {\n  return event.name === 'UpdateCounters';\n}\n\nexport function isThreadName(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventThreadName {\n  return traceEventData.name === KnownEventName.ThreadName;\n}\n\nexport function isProcessName(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventProcessName {\n  return traceEventData.name === 'process_name';\n}\n\nexport function isTraceEventTracingStartedInBrowser(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventTracingStartedInBrowser {\n  return traceEventData.name === KnownEventName.TracingStartedInBrowser;\n}\n\nexport function isTraceEventFrameCommittedInBrowser(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventFrameCommittedInBrowser {\n  return traceEventData.name === 'FrameCommittedInBrowser';\n}\n\nexport function isTraceEventCommitLoad(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventCommitLoad {\n  return traceEventData.name === 'CommitLoad';\n}\n\nexport function isTraceEventNavigationStart(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventNavigationStart {\n  return traceEventData.name === 'navigationStart';\n}\n\nexport function isTraceEventAnimation(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventAnimation {\n  // We've found some rare traces with an Animtation trace event from a different category: https://crbug.com/1472375#comment7\n  return traceEventData.name === 'Animation' && traceEventData.cat.includes('devtools.timeline');\n}\n\nexport function isTraceEventLayoutShift(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventLayoutShift {\n  return traceEventData.name === 'LayoutShift';\n}\n\nexport function isTraceEventLayoutInvalidationTracking(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventLayoutInvalidationTracking {\n  return traceEventData.name === KnownEventName.LayoutInvalidationTracking;\n}\n\nexport function isTraceEventFirstContentfulPaint(traceEventData: TraceEventData):\n    traceEventData is TraceEventFirstContentfulPaint {\n  return traceEventData.name === 'firstContentfulPaint';\n}\n\nexport function isTraceEventLargestContentfulPaintCandidate(traceEventData: TraceEventData):\n    traceEventData is TraceEventLargestContentfulPaintCandidate {\n  return traceEventData.name === KnownEventName.MarkLCPCandidate;\n}\nexport function isTraceEventLargestImagePaintCandidate(traceEventData: TraceEventData):\n    traceEventData is TraceEventLargestImagePaintCandidate {\n  return traceEventData.name === 'LargestImagePaint::Candidate';\n}\nexport function isTraceEventLargestTextPaintCandidate(traceEventData: TraceEventData):\n    traceEventData is TraceEventLargestTextPaintCandidate {\n  return traceEventData.name === 'LargestTextPaint::Candidate';\n}\n\nexport function isTraceEventMarkLoad(traceEventData: TraceEventData): traceEventData is TraceEventMarkLoad {\n  return traceEventData.name === 'MarkLoad';\n}\n\nexport function isTraceEventFirstPaint(traceEventData: TraceEventData): traceEventData is TraceEventFirstPaint {\n  return traceEventData.name === 'firstPaint';\n}\n\nexport function isTraceEventMarkDOMContent(traceEventData: TraceEventData): traceEventData is TraceEventMarkDOMContent {\n  return traceEventData.name === 'MarkDOMContent';\n}\n\nexport function isTraceEventInteractiveTime(traceEventData: TraceEventData):\n    traceEventData is TraceEventInteractiveTime {\n  return traceEventData.name === 'InteractiveTime';\n}\n\nexport function isTraceEventEventTiming(traceEventData: TraceEventData): traceEventData is TraceEventEventTiming {\n  return traceEventData.name === KnownEventName.EventTiming;\n}\n\nexport function isTraceEventEventTimingEnd(traceEventData: TraceEventData): traceEventData is TraceEventEventTimingEnd {\n  return isTraceEventEventTiming(traceEventData) && traceEventData.ph === Phase.ASYNC_NESTABLE_END;\n}\nexport function isTraceEventEventTimingStart(traceEventData: TraceEventData):\n    traceEventData is TraceEventEventTimingBegin {\n  return isTraceEventEventTiming(traceEventData) && traceEventData.ph === Phase.ASYNC_NESTABLE_START;\n}\n\nexport function isTraceEventGPUTask(traceEventData: TraceEventData): traceEventData is TraceEventGPUTask {\n  return traceEventData.name === 'GPUTask';\n}\n\nexport function isTraceEventProfile(traceEventData: TraceEventData): traceEventData is TraceEventProfile {\n  return traceEventData.name === 'Profile';\n}\n\nexport function isSyntheticCpuProfile(traceEventData: TraceEventData): traceEventData is SyntheticCpuProfile {\n  return traceEventData.name === 'CpuProfile';\n}\n\nexport function isTraceEventProfileChunk(traceEventData: TraceEventData): traceEventData is TraceEventProfileChunk {\n  return traceEventData.name === 'ProfileChunk';\n}\n\nexport function isTraceEventResourceChangePriority(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceChangePriority {\n  return traceEventData.name === 'ResourceChangePriority';\n}\n\nexport function isTraceEventResourceSendRequest(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceSendRequest {\n  return traceEventData.name === 'ResourceSendRequest';\n}\n\nexport function isTraceEventResourceReceiveResponse(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceReceiveResponse {\n  return traceEventData.name === 'ResourceReceiveResponse';\n}\n\nexport function isTraceEventResourceMarkAsCached(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceMarkAsCached {\n  return traceEventData.name === 'ResourceMarkAsCached';\n}\n\nexport function isTraceEventResourceFinish(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceFinish {\n  return traceEventData.name === 'ResourceFinish';\n}\n\nexport function isTraceEventResourceWillSendRequest(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceWillSendRequest {\n  return traceEventData.name === 'ResourceWillSendRequest';\n}\n\nexport function isTraceEventResourceReceivedData(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventResourceReceivedData {\n  return traceEventData.name === 'ResourceReceivedData';\n}\n\nexport function isSyntheticNetworkRequestDetailsEvent(\n    traceEventData: TraceEventData,\n    ): traceEventData is SyntheticNetworkRequest {\n  return traceEventData.name === 'SyntheticNetworkRequest';\n}\n\nexport function isTraceEventPrePaint(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventPrePaint {\n  return traceEventData.name === 'PrePaint';\n}\n\nexport function isTraceEventNavigationStartWithURL(event: TraceEventData): event is TraceEventNavigationStart {\n  return Boolean(isTraceEventNavigationStart(event) && event.args.data && event.args.data.documentLoaderURL !== '');\n}\n\nexport function isTraceEventMainFrameViewport(\n    traceEventData: TraceEventData,\n    ): traceEventData is TraceEventMainFrameViewport {\n  return traceEventData.name === 'PaintTimingVisualizer::Viewport';\n}\n\nexport function isSyntheticUserTiming(traceEventData: TraceEventData): traceEventData is SyntheticUserTimingPair {\n  if (traceEventData.cat !== 'blink.user_timing') {\n    return false;\n  }\n  const data = traceEventData.args?.data;\n  if (!data) {\n    return false;\n  }\n  return 'beginEvent' in data && 'endEvent' in data;\n}\n\nexport function isSyntheticConsoleTiming(traceEventData: TraceEventData): traceEventData is SyntheticConsoleTimingPair {\n  if (traceEventData.cat !== 'blink.console') {\n    return false;\n  }\n  const data = traceEventData.args?.data;\n  if (!data) {\n    return false;\n  }\n  return 'beginEvent' in data && 'endEvent' in data;\n}\n\nexport function isTraceEventPerformanceMeasure(traceEventData: TraceEventData):\n    traceEventData is TraceEventPerformanceMeasure {\n  return traceEventData.cat === 'blink.user_timing' && isTraceEventAsyncPhase(traceEventData);\n}\n\nexport function isTraceEventPerformanceMark(traceEventData: TraceEventData):\n    traceEventData is TraceEventPerformanceMark {\n  return traceEventData.cat === 'blink.user_timing' &&\n      (traceEventData.ph === Phase.MARK || traceEventData.ph === Phase.INSTANT);\n}\n\nexport function isTraceEventConsoleTime(traceEventData: TraceEventData): traceEventData is TraceEventConsoleTime {\n  return traceEventData.cat === 'blink.console' && isTraceEventAsyncPhase(traceEventData);\n}\n\nexport function isTraceEventTimeStamp(traceEventData: TraceEventData): traceEventData is TraceEventTimeStamp {\n  return traceEventData.ph === Phase.INSTANT && traceEventData.name === 'TimeStamp';\n}\n\nexport function isTraceEventParseHTML(traceEventData: TraceEventData): traceEventData is TraceEventParseHTML {\n  return traceEventData.name === 'ParseHTML';\n}\n\nexport interface TraceEventAsync extends TraceEventData {\n  ph: Phase.ASYNC_NESTABLE_START|Phase.ASYNC_NESTABLE_INSTANT|Phase.ASYNC_NESTABLE_END|Phase.ASYNC_STEP_INTO|\n      Phase.ASYNC_BEGIN|Phase.ASYNC_END|Phase.ASYNC_STEP_PAST;\n}\n\nconst asyncPhases = new Set([\n  Phase.ASYNC_NESTABLE_START,\n  Phase.ASYNC_NESTABLE_INSTANT,\n  Phase.ASYNC_NESTABLE_END,\n  Phase.ASYNC_STEP_INTO,\n  Phase.ASYNC_BEGIN,\n  Phase.ASYNC_END,\n  Phase.ASYNC_STEP_PAST,\n]);\n\nexport function isTraceEventAsyncPhase(traceEventData: TraceEventData): boolean {\n  return asyncPhases.has(traceEventData.ph);\n}\n\nexport function isSyntheticLayoutShift(traceEventData: TraceEventData): traceEventData is SyntheticLayoutShift {\n  if (!isTraceEventLayoutShift(traceEventData) || !traceEventData.args.data) {\n    return false;\n  }\n  return 'rawEvent' in traceEventData.args.data;\n}\n\nexport function isProfileCall(event: TraceEventData): event is SyntheticProfileCall {\n  return 'callFrame' in event;\n}\n\nexport interface TraceEventPaint extends TraceEventComplete {\n  name: KnownEventName.Paint;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      clip: number[],\n      frame: string,\n      layerId: number,\n      // With CompositeAfterPaint enabled, paint events are no longer\n      // associated with a Node, and nodeId will not be present.\n      nodeId?: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\n\nexport function isTraceEventPaint(event: TraceEventData): event is TraceEventPaint {\n  return event.name === KnownEventName.Paint;\n}\n\nexport interface TraceEventPaintImage extends TraceEventComplete {\n  name: KnownEventName.PaintImage;\n  args: TraceEventArgs&{\n    data: TraceEventData & {\n      height: number,\n      width: number,\n      x: number,\n      y: number,\n      url?: string, srcHeight: number, srcWidth: number,\n      nodeId?: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\nexport function isTraceEventPaintImage(event: TraceEventData): event is TraceEventPaintImage {\n  return event.name === KnownEventName.PaintImage;\n}\n\nexport interface TraceEventScrollLayer extends TraceEventComplete {\n  name: KnownEventName.ScrollLayer;\n  args: TraceEventArgs&{\n    data: TraceEventData & {\n      frame: string,\n      nodeId?: Protocol.DOM.BackendNodeId,\n    },\n  };\n}\nexport function isTraceEventScrollLayer(event: TraceEventData): event is TraceEventScrollLayer {\n  return event.name === KnownEventName.ScrollLayer;\n}\n\nexport interface TraceEventSetLayerTreeId extends TraceEventInstant {\n  name: KnownEventName.SetLayerTreeId;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      frame: string,\n      layerTreeId: number,\n    },\n  };\n}\nexport function isTraceEventSetLayerId(event: TraceEventData): event is TraceEventSetLayerTreeId {\n  return event.name === KnownEventName.SetLayerTreeId;\n}\nexport interface TraceEventUpdateLayer extends TraceEventComplete {\n  name: KnownEventName.UpdateLayer;\n  args: TraceEventArgs&{\n    layerId: number,\n    layerTreeId: number,\n  };\n}\nexport function isTraceEventUpdateLayer(event: TraceEventData): event is TraceEventUpdateLayer {\n  return event.name === KnownEventName.UpdateLayer;\n}\n\nexport interface TraceEventDisplayItemListSnapshot extends TraceEventData {\n  name: KnownEventName.DisplayItemListSnapshot;\n  ph: Phase.OBJECT_SNAPSHOT;\n  id2: {\n    local?: string,\n  };\n  args: TraceEventArgs&{\n    snapshot: {\n      skp64: string,\n      params?: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        layer_rect: [number, number, number, number],\n      },\n    },\n  };\n}\nexport function isTraceEventDisplayListItemListSnapshot(event: TraceEventData):\n    event is TraceEventDisplayItemListSnapshot {\n  return event.name === KnownEventName.DisplayItemListSnapshot;\n}\n\nexport interface TraceEventLayerTreeHostImplSnapshot extends TraceEventData {\n  name: KnownEventName.LayerTreeHostImplSnapshot;\n  ph: Phase.OBJECT_SNAPSHOT;\n  id: string;\n  args: TraceEventArgs&{\n    snapshot: {\n      /* eslint-disable @typescript-eslint/naming-convention */\n      active_tiles: Array<{\n        id: string,\n        layer_id: string,\n        gpu_memory_usage: number,\n        content_rect: number[],\n      }>,\n      device_viewport_size: {\n        width: number,\n        height: number,\n      },\n      active_tree: {\n        root_layer: TraceLayer,\n        layers: TraceLayer[],\n      },\n      /* eslint-enable @typescript-eslint/naming-convention */\n    },\n  };\n}\n\nexport function isTraceEventLayerTreeHostImplSnapshot(event: TraceEventData):\n    event is TraceEventLayerTreeHostImplSnapshot {\n  return event.name === KnownEventName.LayerTreeHostImplSnapshot;\n}\n/* eslint-disable @typescript-eslint/naming-convention */\nexport interface TraceLayer {\n  bounds: {height: number, width: number};\n  children: TraceLayer[];\n  layer_id: number;\n  position: number[];\n  scroll_offset: number[];\n  layer_quad: number[];\n  draws_content: number;\n  gpu_memory_usage: number;\n  transform: number[];\n  owner_node: Protocol.DOM.BackendNodeId;\n  compositing_reasons: string[];\n  compositing_reason_ids: string[];\n  non_fast_scrollable_region: number[];\n  touch_event_handler_region: number[];\n  wheel_event_handler_region: number[];\n  scroll_event_handler_region: number[];\n}\n\nexport interface TracingLayerTile {\n  id: string;\n  layer_id: string;\n  gpu_memory_usage: number;\n  content_rect: number[];\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport interface TraceEventFireAnimationFrame extends TraceEventComplete {\n  name: KnownEventName.FireAnimationFrame;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      id: number,\n    },\n  };\n}\nexport function isTraceEventFireAnimationFrame(event: TraceEventData): event is TraceEventFireAnimationFrame {\n  return event.name === KnownEventName.FireAnimationFrame;\n}\n\nexport interface TraceEventRequestAnimationFrame extends TraceEventInstant {\n  name: KnownEventName.RequestAnimationFrame;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      id: number,\n      stackTrace?: TraceEventCallFrame,\n    },\n  };\n}\nexport function isTraceEventRequestAnimationFrame(event: TraceEventData): event is TraceEventRequestAnimationFrame {\n  return event.name === KnownEventName.RequestAnimationFrame;\n}\n\nexport interface TraceEventTimerInstall extends TraceEventInstant {\n  name: KnownEventName.TimerInstall;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      singleShot: boolean,\n      stackTrace?: TraceEventCallFrame, timeout: number, timerId: number,\n    },\n  };\n}\nexport function isTraceEventTimerInstall(event: TraceEventData): event is TraceEventTimerInstall {\n  return event.name === KnownEventName.TimerInstall;\n}\n\nexport interface TraceEventTimerFire extends TraceEventComplete {\n  name: KnownEventName.TimerFire;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      timerId: number,\n    },\n  };\n}\nexport function isTraceEventTimerFire(event: TraceEventData): event is TraceEventTimerFire {\n  return event.name === KnownEventName.TimerFire;\n}\n\nexport interface TraceEventRequestIdleCallback extends TraceEventInstant {\n  name: KnownEventName.RequestIdleCallback;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      id: number,\n      timeout: number,\n      stackTrace?: TraceEventCallFrame,\n    },\n\n  };\n}\nexport function isTraceEventRequestIdleCallback(event: TraceEventData): event is TraceEventRequestIdleCallback {\n  return event.name === KnownEventName.RequestIdleCallback;\n}\n\nexport interface TraceEventWebSocketCreate extends TraceEventInstant {\n  name: KnownEventName.WebSocketCreate;\n  args: TraceEventArgs&{\n    data: {\n      identifier: number,\n      url: string,\n      frame?: string,\n      workerId?: string,\n      websocketProtocol?: string,\n      stackTrace?: TraceEventCallFrame,\n    },\n  };\n}\nexport function isTraceEventWebSocketCreate(event: TraceEventData): event is TraceEventWebSocketCreate {\n  return event.name === KnownEventName.WebSocketCreate;\n}\n\nexport interface TraceEventWebSocketInfo extends TraceEventInstant {\n  name: KnownEventName.WebSocketDestroy|KnownEventName.WebSocketReceiveHandshake|\n      KnownEventName.WebSocketReceiveHandshakeResponse;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      identifier: number,\n      url: string,\n      frame?: string,\n      workerId?: string,\n    },\n  };\n}\nexport interface TraceEventWebSocketTransfer extends TraceEventInstant {\n  name: KnownEventName.WebSocketSend|KnownEventName.WebSocketReceive;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      identifier: number,\n      url: string,\n      frame?: string,\n      workerId?: string, dataLength: number,\n    },\n  };\n}\nexport function isTraceEventWebSocketInfo(traceEventData: TraceEventData): traceEventData is TraceEventWebSocketInfo {\n  return traceEventData.name === KnownEventName.WebSocketSendHandshakeRequest ||\n      traceEventData.name === KnownEventName.WebSocketReceiveHandshakeResponse ||\n      traceEventData.name === KnownEventName.WebSocketDestroy;\n}\n\nexport function isTraceEventWebSocketTransfer(traceEventData: TraceEventData):\n    traceEventData is TraceEventWebSocketTransfer {\n  return traceEventData.name === KnownEventName.WebSocketSend ||\n      traceEventData.name === KnownEventName.WebSocketReceive;\n}\n\nexport interface TraceEventWebSocketSend extends TraceEventInstant {\n  name: KnownEventName.WebSocketSend;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      identifier: number,\n      url: string,\n      frame?: string,\n      workerId?: string, dataLength: number,\n    },\n  };\n}\n\nexport function isTraceEventWebSocketSend(event: TraceEventData): event is TraceEventWebSocketSend {\n  return event.name === KnownEventName.WebSocketSend;\n}\n\nexport interface TraceEventWebSocketReceive extends TraceEventInstant {\n  name: KnownEventName.WebSocketReceive;\n  args: TraceEventArgs&{\n    data: TraceEventArgsData & {\n      identifier: number,\n      url: string,\n      frame?: string,\n      workerId?: string, dataLength: number,\n    },\n  };\n}\nexport function isTraceEventWebSocketReceive(event: TraceEventData): event is TraceEventWebSocketReceive {\n  return event.name === KnownEventName.WebSocketReceive;\n}\n\nexport interface TraceEventWebSocketSendHandshakeRequest extends TraceEventInstant {\n  name: KnownEventName.WebSocketSendHandshakeRequest;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      identifier: number,\n    },\n  };\n}\nexport function isTraceEventWebSocketSendHandshakeRequest(event: TraceEventData):\n    event is TraceEventWebSocketSendHandshakeRequest {\n  return event.name === KnownEventName.WebSocketSendHandshakeRequest;\n}\n\nexport interface TraceEventWebSocketReceiveHandshakeResponse extends TraceEventInstant {\n  name: KnownEventName.WebSocketReceiveHandshakeResponse;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      identifier: number,\n    },\n  };\n}\nexport function isTraceEventWebSocketReceiveHandshakeResponse(event: TraceEventData):\n    event is TraceEventWebSocketReceiveHandshakeResponse {\n  return event.name === KnownEventName.WebSocketReceiveHandshakeResponse;\n}\n\nexport interface TraceEventWebSocketDestroy extends TraceEventInstant {\n  name: KnownEventName.WebSocketDestroy;\n  args: TraceEventArgs&{\n    data: {\n      frame: string,\n      identifier: number,\n    },\n  };\n}\nexport function isTraceEventWebSocketDestroy(event: TraceEventData): event is TraceEventWebSocketDestroy {\n  return event.name === KnownEventName.WebSocketDestroy;\n}\n\nexport function isWebSocketTraceEvent(event: TraceEventData): event is TraceEventWebSocketCreate|\n    TraceEventWebSocketInfo|TraceEventWebSocketTransfer {\n  return isTraceEventWebSocketCreate(event) || isTraceEventWebSocketInfo(event) || isTraceEventWebSocketTransfer(event);\n}\nexport type WebSocketEvent = TraceEventWebSocketCreate|TraceEventWebSocketInfo|TraceEventWebSocketTransfer;\n\nexport interface TraceEventV8Compile extends TraceEventComplete {\n  name: KnownEventName.Compile;\n  args: TraceEventArgs&{\n    data?: {\n      url?: string,\n      columnNumber?: number,\n      consumedCacheSize?: number,\n      cacheRejected?: boolean,\n      cacheKind?: 'full'|'normal',\n      lineNumber?: number,\n      notStreamedReason?: string,\n      streamed?: boolean,\n      eager?: boolean,\n    },\n    fileName?: string,\n  };\n}\nexport function isTraceEventV8Compile(event: TraceEventData): event is TraceEventV8Compile {\n  return event.name === KnownEventName.Compile;\n}\n\nexport interface TraceEventFunctionCall extends TraceEventComplete {\n  name: KnownEventName.FunctionCall;\n  args: TraceEventArgs&{\n    data?: {\n      frame?: string,\n      columnNumber?: number,\n      lineNumber?: number,\n      functionName?: string,\n      scriptId?: number,\n      url?: string,\n    },\n  };\n}\nexport function isTraceEventFunctionCall(event: TraceEventData): event is TraceEventFunctionCall {\n  return event.name === KnownEventName.FunctionCall;\n}\n\n/**\n * Generally, before JS is executed, a trace event is dispatched that\n * parents the JS calls. These we call \"invocation\" events. This\n * function determines if an event is one of such.\n */\nexport function isJSInvocationEvent(event: TraceEventData): boolean {\n  switch (event.name) {\n    case KnownEventName.RunMicrotasks:\n    case KnownEventName.FunctionCall:\n    case KnownEventName.EvaluateScript:\n    case KnownEventName.EvaluateModule:\n    case KnownEventName.EventDispatch:\n    case KnownEventName.V8Execute:\n      return true;\n  }\n  // Also consider any new v8 trace events. (eg 'V8.RunMicrotasks' and 'v8.run')\n  if (event.name.startsWith('v8') || event.name.startsWith('V8')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * This is an exhaustive list of events we track in the Performance\n * panel. Note not all of them are necessarliry shown in the flame\n * chart, some of them we only use for parsing.\n * TODO(crbug.com/1428024): Complete this enum.\n */\nexport const enum KnownEventName {\n  /* Metadata */\n  ThreadName = 'thread_name',\n\n  /* Task */\n  Program = 'Program',\n  RunTask = 'RunTask',\n  AsyncTask = 'AsyncTask',\n  RunMicrotasks = 'RunMicrotasks',\n\n  /* Load */\n  XHRLoad = 'XHRLoad',\n  XHRReadyStateChange = 'XHRReadyStateChange',\n  /* Parse */\n  ParseHTML = 'ParseHTML',\n  ParseCSS = 'ParseAuthorStyleSheet',\n  /* V8 */\n  CompileCode = 'V8.CompileCode',\n  CompileModule = 'V8.CompileModule',\n  // Although V8 emits the V8.CompileScript event, the event that actually\n  // contains the useful information about the script (URL, etc), is contained\n  // in the v8.compile event.\n  // Yes, it is all lowercase compared to all the rest of the V8... events,\n  // that is not a typo :)\n  Compile = 'v8.compile',\n  CompileScript = 'V8.CompileScript',\n  Optimize = 'V8.OptimizeCode',\n  WasmStreamFromResponseCallback = 'v8.wasm.streamFromResponseCallback',\n  WasmCompiledModule = 'v8.wasm.compiledModule',\n  WasmCachedModule = 'v8.wasm.cachedModule',\n  WasmModuleCacheHit = 'v8.wasm.moduleCacheHit',\n  WasmModuleCacheInvalid = 'v8.wasm.moduleCacheInvalid',\n  /* Js */\n  ProfileCall = 'ProfileCall',\n  EvaluateScript = 'EvaluateScript',\n  FunctionCall = 'FunctionCall',\n  EventDispatch = 'EventDispatch',\n  EvaluateModule = 'v8.evaluateModule',\n  RequestMainThreadFrame = 'RequestMainThreadFrame',\n  RequestAnimationFrame = 'RequestAnimationFrame',\n  CancelAnimationFrame = 'CancelAnimationFrame',\n  FireAnimationFrame = 'FireAnimationFrame',\n  RequestIdleCallback = 'RequestIdleCallback',\n  CancelIdleCallback = 'CancelIdleCallback',\n  FireIdleCallback = 'FireIdleCallback',\n  TimerInstall = 'TimerInstall',\n  TimerRemove = 'TimerRemove',\n  TimerFire = 'TimerFire',\n  WebSocketCreate = 'WebSocketCreate',\n  WebSocketSendHandshake = 'WebSocketSendHandshakeRequest',\n  WebSocketReceiveHandshake = 'WebSocketReceiveHandshakeResponse',\n  WebSocketDestroy = 'WebSocketDestroy',\n  WebSocketSend = 'WebSocketSend',\n  WebSocketReceive = 'WebSocketReceive',\n  CryptoDoEncrypt = 'DoEncrypt',\n  CryptoDoEncryptReply = 'DoEncryptReply',\n  CryptoDoDecrypt = 'DoDecrypt',\n  CryptoDoDecryptReply = 'DoDecryptReply',\n  CryptoDoDigest = 'DoDigest',\n  CryptoDoDigestReply = 'DoDigestReply',\n  CryptoDoSign = 'DoSign',\n  CryptoDoSignReply = 'DoSignReply',\n  CryptoDoVerify = 'DoVerify',\n  CryptoDoVerifyReply = 'DoVerifyReply',\n  V8Execute = 'V8.Execute',\n\n  /* Gc */\n  GC = 'GCEvent',\n  DOMGC = 'BlinkGC.AtomicPhase',\n  MajorGC = 'MajorGC',\n  MinorGC = 'MinorGC',\n  GCCollectGarbage = 'BlinkGC.AtomicPhase',\n  CPPGCSweep = 'CppGC.IncrementalSweep',\n\n  /* Layout */\n  ScheduleStyleRecalculation = 'ScheduleStyleRecalculation',\n  Layout = 'Layout',\n  UpdateLayoutTree = 'UpdateLayoutTree',\n  InvalidateLayout = 'InvalidateLayout',\n  LayoutInvalidationTracking = 'LayoutInvalidationTracking',\n  ComputeIntersections = 'ComputeIntersections',\n  HitTest = 'HitTest',\n  PrePaint = 'PrePaint',\n  Layerize = 'Layerize',\n  LayoutShift = 'LayoutShift',\n  UpdateLayerTree = 'UpdateLayerTree',\n  ScheduleStyleInvalidationTracking = 'ScheduleStyleInvalidationTracking',\n  StyleRecalcInvalidationTracking = 'StyleRecalcInvalidationTracking',\n  StyleInvalidatorInvalidationTracking = 'StyleInvalidatorInvalidationTracking',\n  SelectorStats = 'SelectorStats',\n  BeginCommitCompositorFrame = 'BeginCommitCompositorFrame',\n\n  /* Paint */\n  ScrollLayer = 'ScrollLayer',\n  UpdateLayer = 'UpdateLayer',\n  PaintSetup = 'PaintSetup',\n  Paint = 'Paint',\n  PaintImage = 'PaintImage',\n  Commit = 'Commit',\n  CompositeLayers = 'CompositeLayers',\n  RasterTask = 'RasterTask',\n  ImageDecodeTask = 'ImageDecodeTask',\n  ImageUploadTask = 'ImageUploadTask',\n  DecodeImage = 'Decode Image',\n  DrawLazyPixelRef = 'Draw LazyPixelRef',\n  DecodeLazyPixelRef = 'Decode LazyPixelRef',\n  GPUTask = 'GPUTask',\n  Rasterize = 'Rasterize',\n  EventTiming = 'EventTiming',\n\n  /* Compile */\n  OptimizeCode = 'V8.OptimizeCode',\n  CacheScript = 'v8.produceCache',\n  CacheModule = 'v8.produceModuleCache',\n  // V8Sample events are coming from tracing and contain raw stacks with function addresses.\n  // After being processed with help of JitCodeAdded and JitCodeMoved events they\n  // get translated into function infos and stored as stacks in JSSample events.\n  V8Sample = 'V8Sample',\n  JitCodeAdded = 'JitCodeAdded',\n  JitCodeMoved = 'JitCodeMoved',\n  StreamingCompileScript = 'v8.parseOnBackground',\n  StreamingCompileScriptWaiting = 'v8.parseOnBackgroundWaiting',\n  StreamingCompileScriptParsing = 'v8.parseOnBackgroundParsing',\n  BackgroundDeserialize = 'v8.deserializeOnBackground',\n  FinalizeDeserialization = 'V8.FinalizeDeserialization',\n\n  /* Markers */\n  CommitLoad = 'CommitLoad',\n  MarkLoad = 'MarkLoad',\n  MarkDOMContent = 'MarkDOMContent',\n  MarkFirstPaint = 'firstPaint',\n  MarkFCP = 'firstContentfulPaint',\n  MarkLCPCandidate = 'largestContentfulPaint::Candidate',\n  MarkLCPInvalidate = 'largestContentfulPaint::Invalidate',\n  NavigationStart = 'navigationStart',\n  TimeStamp = 'TimeStamp',\n  ConsoleTime = 'ConsoleTime',\n  UserTiming = 'UserTiming',\n  InteractiveTime = 'InteractiveTime',\n\n  /* Frames */\n  BeginFrame = 'BeginFrame',\n  NeedsBeginFrameChanged = 'NeedsBeginFrameChanged',\n  BeginMainThreadFrame = 'BeginMainThreadFrame',\n  ActivateLayerTree = 'ActivateLayerTree',\n  DrawFrame = 'DrawFrame',\n  DroppedFrame = 'DroppedFrame',\n  FrameStartedLoading = 'FrameStartedLoading',\n  PipelineReporter = 'PipelineReporter',\n  Screenshot = 'Screenshot',\n\n  /* Network request events */\n  ResourceWillSendRequest = 'ResourceWillSendRequest',\n  ResourceSendRequest = 'ResourceSendRequest',\n  ResourceReceiveResponse = 'ResourceReceiveResponse',\n  ResourceReceivedData = 'ResourceReceivedData',\n  ResourceFinish = 'ResourceFinish',\n  ResourceMarkAsCached = 'ResourceMarkAsCached',\n\n  /* Web sockets */\n  WebSocketSendHandshakeRequest = 'WebSocketSendHandshakeRequest',\n  WebSocketReceiveHandshakeResponse = 'WebSocketReceiveHandshakeResponse',\n\n  /* CPU Profiling */\n  Profile = 'Profile',\n  StartProfiling = 'CpuProfiler::StartProfiling',\n  ProfileChunk = 'ProfileChunk',\n  UpdateCounters = 'UpdateCounters',\n\n  JSSample = 'JSSample',\n\n  /* Other */\n  Animation = 'Animation',\n  ParseAuthorStyleSheet = 'ParseAuthorStyleSheet',\n  EmbedderCallback = 'EmbedderCallback',\n  SetLayerTreeId = 'SetLayerTreeId',\n  TracingStartedInPage = 'TracingStartedInPage',\n  TracingStartedInBrowser = 'TracingStartedInBrowser',\n  TracingSessionIdForWorker = 'TracingSessionIdForWorker',\n  LazyPixelRef = 'LazyPixelRef',\n  LayerTreeHostImplSnapshot = 'cc::LayerTreeHostImpl',\n  PictureSnapshot = 'cc::Picture',\n  DisplayItemListSnapshot = 'cc::DisplayItemList',\n  InputLatencyMouseMove = 'InputLatency::MouseMove',\n  InputLatencyMouseWheel = 'InputLatency::MouseWheel',\n  ImplSideFling = 'InputHandlerProxy::HandleGestureFling::started',\n\n  SchedulePostMessage = 'SchedulePostMessage',\n  HandlePostMessage = 'HandlePostMessage',\n\n  RenderFrameImplCreateChildFrame = 'RenderFrameImpl::createChildFrame',\n}\n\n// NOT AN EXHAUSTIVE LIST: just some categories we use and refer\n// to in multiple places.\nexport const Categories = {\n  Console: 'blink.console',\n  UserTiming: 'blink.user_timing',\n  Loading: 'loading',\n} as const;\n"]}