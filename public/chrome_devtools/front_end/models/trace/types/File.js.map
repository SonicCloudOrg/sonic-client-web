{"version":3,"file":"File.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/types/File.ts"],"names":[],"mappings":"AAsFA,MAAM,UAAU,qBAAqB,CAAC,GAA8B;IAClE,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC7B,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAEtB,QAAQ,IAAI,EAAE,CAAC;QACb;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;gBAClB,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACnG,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,EAAE,CAAC,CAAC;YACpD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,SAAS,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBACjC,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBAChC,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBACnC,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACT,CAAC;QAC5B;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5F,MAAM,IAAI,KAAK,CAAC,yBAAyB,GAAG,EAAE,CAAC,CAAC;YAClD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACZ,CAAC;QACzB;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5F,MAAM,IAAI,KAAK,CAAC,+BAA+B,GAAG,EAAE,CAAC,CAAC;YACxD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACN,CAAC;QAC/B;YACE,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,EAAE,CAAC,CAAC;IACvD,CAAC;AACH,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Protocol from '../../../generated/protocol.js';\n\nimport {type TraceWindowMicroSeconds} from './Timing.js';\nimport {type ProcessID, type SampleIndex, type ThreadID, type TraceEventData} from './TraceEvents.js';\n\nexport type TraceFile = {\n  traceEvents: readonly TraceEventData[],\n  metadata: MetaData,\n};\n\nexport interface Breadcrumb {\n  window: TraceWindowMicroSeconds;\n  child: Breadcrumb|null;\n}\n\nexport const enum DataOrigin {\n  CPUProfile = 'CPUProfile',\n  TraceEvents = 'TraceEvents',\n}\n\nexport const enum EventKeyType {\n  RawEvent = 'r',\n  SyntheticEvent = 's',\n  ProfileCall = 'p',\n}\n\n// Serializable keys are created for trace events to be able to save\n// references to timeline events in a trace file. These keys enable\n// user modifications that can be saved. See go/cpq:event-data-json for\n// more details on the key format.\nexport type RawEventKey = `${EventKeyType.RawEvent}-${number}`;\nexport type SyntheticEventKey = `${EventKeyType.SyntheticEvent}-${number}`;\nexport type ProfileCallKey = `${EventKeyType.ProfileCall}-${ProcessID}-${ThreadID}-${SampleIndex}-${Protocol.integer}`;\nexport type TraceEventSerializableKey = RawEventKey|ProfileCallKey|SyntheticEventKey;\n\n// Serializable keys values objects contain data that maps the keys to original Trace Events\nexport type RawEventKeyValues = {\n  type: EventKeyType.RawEvent,\n  rawIndex: number,\n};\n\nexport type SyntheticEventKeyValues = {\n  type: EventKeyType.SyntheticEvent,\n  rawIndex: number,\n};\n\nexport type ProfileCallKeyValues = {\n  type: EventKeyType.ProfileCall,\n  processID: ProcessID,\n  threadID: ThreadID,\n  sampleIndex: SampleIndex,\n  protocol: Protocol.integer,\n};\n\nexport type TraceEventSerializableKeyValues = RawEventKeyValues|ProfileCallKeyValues|SyntheticEventKeyValues;\n\nexport interface Modifications {\n  entriesModifications: {\n    // Entries hidden by the user\n    hiddenEntries: TraceEventSerializableKey[],\n    // Entries that parent a hiddenEntry\n    expandableEntries: TraceEventSerializableKey[],\n  };\n  initialBreadcrumb: Breadcrumb;\n}\n\n/**\n * Trace metadata that we persist to the file. This will allow us to\n * store specifics for the trace, e.g., which tracks should be visible\n * on load.\n */\nexport interface MetaData {\n  source?: 'DevTools';\n  startTime?: string;\n  networkThrottling?: string;\n  cpuThrottling?: number;\n  hardwareConcurrency?: number;\n  dataOrigin?: DataOrigin;\n  modifications?: Modifications;\n}\n\nexport type Contents = TraceFile|TraceEventData[];\n\nexport function traceEventKeyToValues(key: TraceEventSerializableKey): TraceEventSerializableKeyValues {\n  const parts = key.split('-');\n  const type = parts[0];\n\n  switch (type) {\n    case EventKeyType.ProfileCall:\n      if (parts.length !== 5 ||\n          !(parts.every((part, i) => i === 0 || typeof part === 'number' || !isNaN(parseInt(part, 10))))) {\n        throw new Error(`Invalid ProfileCallKey: ${key}`);\n      }\n      return {\n        type: parts[0],\n        processID: parseInt(parts[1], 10),\n        threadID: parseInt(parts[2], 10),\n        sampleIndex: parseInt(parts[3], 10),\n        protocol: parseInt(parts[4], 10),\n      } as ProfileCallKeyValues;\n    case EventKeyType.RawEvent:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid RawEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as RawEventKeyValues;\n    case EventKeyType.SyntheticEvent:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid SyntheticEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as SyntheticEventKeyValues;\n    default:\n      throw new Error(`Unknown trace event key: ${key}`);\n  }\n}\n"]}