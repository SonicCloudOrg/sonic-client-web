{"version":3,"file":"LayoutShiftsHandler.test.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {TraceLoader} from '../../../testing/TraceLoader.js';\nimport * as TraceModel from '../trace.js';\n\nasync function processTrace(context: Mocha.Suite|Mocha.Context|null, url: string): Promise<void> {\n  TraceModel.Handlers.ModelHandlers.Meta.reset();\n  TraceModel.Handlers.ModelHandlers.Meta.initialize();\n\n  TraceModel.Handlers.ModelHandlers.LayoutShifts.reset();\n  TraceModel.Handlers.ModelHandlers.LayoutShifts.initialize();\n\n  try {\n    const events = await TraceLoader.rawEvents(context, url);\n    for (const event of events) {\n      TraceModel.Handlers.ModelHandlers.Meta.handleEvent(event);\n      TraceModel.Handlers.ModelHandlers.Screenshots.handleEvent(event);\n      TraceModel.Handlers.ModelHandlers.LayoutShifts.handleEvent(event);\n    }\n  } catch (error) {\n    assert.fail(error);\n  }\n  await TraceModel.Handlers.ModelHandlers.Meta.finalize();\n  await TraceModel.Handlers.ModelHandlers.Screenshots.finalize();\n  await TraceModel.Handlers.ModelHandlers.LayoutShifts.finalize();\n}\n\ndescribe('LayoutShiftsHandler', function() {\n  beforeEach(async () => {\n    // The layout shifts handler stores by process, so to make life easier we\n    // run the meta handler here, too, so that later on we can get the IDs of\n    // the main renderer process and thread.\n    TraceModel.Handlers.ModelHandlers.Meta.reset();\n    TraceModel.Handlers.ModelHandlers.Meta.initialize();\n\n    TraceModel.Handlers.ModelHandlers.LayoutShifts.reset();\n  });\n\n  it('clusters a single frame correctly', async function() {\n    await processTrace(this, 'cls-single-frame.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(layoutShifts.clusters.length, 1);\n    assert.strictEqual(layoutShifts.clusters[0].clusterCumulativeScore, 0.29522728495836237);\n  });\n\n  it('creates a cluster after the maximum time gap between shifts', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(layoutShifts.clusters.length, 3);\n    // The first cluster should end because the maximum time gap between\n    // shifts ends, and thus the time between the last shift and the window\n    // end should be exactly MAX_SHIFT_TIME_DELTA;\n    const firstCluster = layoutShifts.clusters[0];\n    const firstClusterEvents = layoutShifts.clusters[0].events;\n\n    assert.strictEqual(\n        firstCluster.clusterWindow.max - firstClusterEvents[firstClusterEvents.length - 1].ts,\n        TraceModel.Handlers.ModelHandlers.LayoutShifts.MAX_SHIFT_TIME_DELTA);\n\n    // There are seven shifts in quick succession in the first cluster,\n    // only one shift in the second cluster and only one shift in the\n    // third cluster.\n    assert.strictEqual(layoutShifts.clusters[0].events.length, 7);\n    assert.strictEqual(layoutShifts.clusters[1].events.length, 1);\n    assert.strictEqual(layoutShifts.clusters[2].events.length, 1);\n  });\n\n  it('creates a cluster after a navigation', async function() {\n    await processTrace(this, 'cls-cluster-navigation.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    const {navigationsByFrameId, mainFrameId} = TraceModel.Handlers.ModelHandlers.Meta.data();\n\n    const navigations = navigationsByFrameId.get(mainFrameId);\n    if (!navigations || navigations.length === 0) {\n      assert.fail('No navigations found');\n    }\n\n    assert.strictEqual(layoutShifts.clusters[0].clusterWindow.max, navigations[0].ts);\n\n    // We should see an initial cluster here from the first layout shifts,\n    // followed by 1 for each of the navigations themselves.\n    assert.strictEqual(layoutShifts.clusters.length, navigations.length + 1);\n\n    const secondCluster = layoutShifts.clusters[1];\n    // The second cluster should be marked to start at the first shift timestamp.\n    assert.strictEqual(secondCluster.clusterWindow.min, secondCluster.events[0].ts);\n  });\n\n  it('creates a cluster after exceeding the continuous shift limit', async function() {\n    await processTrace(this, 'cls-cluster-max-duration.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(layoutShifts.clusters.length, 2);\n    // Cluster must be closed as soon as MAX_CLUSTER_DURATION is reached, even if\n    // there is a gap greater than MAX_SHIFT_TIME_DELTA right after the max window\n    // length happens.\n    assert.strictEqual(\n        layoutShifts.clusters[0].clusterWindow.max - layoutShifts.clusters[0].clusterWindow.min,\n        TraceModel.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n  it('sets the end of the last session window to the trace end time correctly', async function() {\n    await processTrace(this, 'cls-cluster-max-duration.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(\n        layoutShifts.clusters.at(-1)?.clusterWindow.max, TraceModel.Handlers.ModelHandlers.Meta.data().traceBounds.max);\n  });\n\n  it('sets the end of the last session window to the max gap between duration correctly', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    const lastWindow = layoutShifts.clusters.at(-1)?.clusterWindow;\n    const lastShiftInWindow = layoutShifts.clusters.at(-1)?.events.at(-1);\n    if (!lastWindow) {\n      assert.fail('Session window not found.');\n    }\n\n    if (!lastShiftInWindow) {\n      assert.fail('Session window not found.');\n    }\n    assert.strictEqual(\n        lastWindow.max, lastShiftInWindow.ts + TraceModel.Handlers.ModelHandlers.LayoutShifts.MAX_SHIFT_TIME_DELTA);\n    assert.isBelow(lastWindow.range, TraceModel.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n  it('sets the end of the last session window to the max session duration correctly', async function() {\n    await processTrace(this, 'cls-last-cluster-max-duration.json.gz');\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    const lastWindow = layoutShifts.clusters.at(-1)?.clusterWindow;\n    const lastShiftInWindow = layoutShifts.clusters.at(-1)?.events.at(-1);\n    if (!lastWindow) {\n      assert.fail('Session window not found.');\n    }\n\n    if (!lastShiftInWindow) {\n      assert.fail('Session window not found.');\n    }\n    assert.strictEqual(lastWindow.range, TraceModel.Handlers.ModelHandlers.LayoutShifts.MAX_CLUSTER_DURATION);\n  });\n\n  it('demarcates cluster score windows correctly', async function() {\n    await processTrace(this, 'cls-multiple-frames.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(layoutShifts.clusters.length, 5);\n\n    for (const cluster of layoutShifts.clusters) {\n      let clusterScore = 0;\n      for (const event of cluster.events) {\n        const scoreBeforeEvent = clusterScore;\n        clusterScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n\n        // Here we've crossed the threshold from Good to NI (but not Bad) so\n        // check that both the Good and NI windows values are set as expected.\n        if (scoreBeforeEvent < TraceModel.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.NEEDS_IMPROVEMENT &&\n            clusterScore >= TraceModel.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.NEEDS_IMPROVEMENT &&\n            clusterScore < TraceModel.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD) {\n          assert.strictEqual(cluster.scoreWindows.good.max, event.ts - 1);\n          if (!cluster.scoreWindows.needsImprovement) {\n            assert.fail('No Needs Improvement window');\n          }\n          assert.strictEqual(cluster.scoreWindows.needsImprovement.min, event.ts);\n        }\n\n        // Here we have transitioned from eiter Good or NI to Bad, so\n        // again we assert that the Bad window starts when expected,\n        // and that either the NI or Good window finishes just prior.\n        if (scoreBeforeEvent < TraceModel.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD &&\n            clusterScore >= TraceModel.Handlers.ModelHandlers.LayoutShifts.LayoutShiftsThreshold.BAD) {\n          if (!cluster.scoreWindows.bad) {\n            assert.fail('No Bad window');\n          }\n\n          if (cluster.scoreWindows.needsImprovement) {\n            assert.strictEqual(cluster.scoreWindows.needsImprovement.max, event.ts - 1);\n          } else {\n            assert.strictEqual(cluster.scoreWindows.good.max, event.ts - 1);\n          }\n          assert.strictEqual(cluster.scoreWindows.bad.min, event.ts);\n        }\n      }\n    }\n  });\n\n  it('calculates Cumulative Layout Shift correctly for multiple session windows', async function() {\n    await processTrace(this, 'cls-cluster-max-timeout.json.gz');\n\n    const layoutShifts = TraceModel.Handlers.ModelHandlers.LayoutShifts.data();\n    assert.strictEqual(layoutShifts.clusters.length, 3);\n\n    let globalCLS = 0;\n    let clusterCount = 1;\n    let clusterWithCLS = 0;\n    for (const cluster of layoutShifts.clusters) {\n      let clusterCumulativeScore = 0;\n      for (const shift of cluster.events) {\n        clusterCumulativeScore += shift.args.data?.weighted_score_delta || 0;\n        // Test the cumulative score until this shift.\n        assert.strictEqual(shift.parsedData.cumulativeWeightedScoreInWindow, clusterCumulativeScore);\n        // Test the score of this shift's session window.\n        assert.strictEqual(shift.parsedData.sessionWindowData.cumulativeWindowScore, cluster.clusterCumulativeScore);\n        // Test the id of this shift's session window.\n        assert.strictEqual(shift.parsedData.sessionWindowData.id, clusterCount);\n      }\n      clusterCount++;\n      // Test the accumulated\n      assert.strictEqual(cluster.clusterCumulativeScore, clusterCumulativeScore);\n      if (cluster.clusterCumulativeScore > globalCLS) {\n        globalCLS = cluster.clusterCumulativeScore;\n        clusterWithCLS = clusterCount - 1;\n      }\n    }\n    // Test the calculated CLS.\n    assert.strictEqual(layoutShifts.sessionMaxScore, globalCLS);\n    assert.strictEqual(layoutShifts.clsWindowID, clusterWithCLS);\n  });\n});\n"]}