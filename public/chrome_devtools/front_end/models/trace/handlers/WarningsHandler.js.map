{"version":3,"file":"WarningsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/WarningsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {type TraceEventHandlerName} from './types.js';\nimport {data as userInteractionsHandlerData} from './UserInteractionsHandler.js';\n\nexport interface WarningsData {\n  // Tracks warnings keyed by the event.\n  perEvent: Map<Types.TraceEvents.TraceEventData, Warning[]>;\n  // The same data in reverse: for each type of warning, track the events.\n  // Useful if we need to enumerate events by type of issue\n  perWarning: Map<Warning, Types.TraceEvents.TraceEventData[]>;\n}\n\nexport type Warning = 'LONG_TASK'|'IDLE_CALLBACK_OVER_TIME'|'FORCED_REFLOW'|'LONG_INTERACTION';\n\nconst warningsPerEvent: WarningsData['perEvent'] = new Map();\nconst eventsPerWarning: WarningsData['perWarning'] = new Map();\n\n/**\n * Tracks the stack formed by nested trace events up to a given point\n */\nconst allEventsStack: Types.TraceEvents.TraceEventData[] = [];\n/**\n * Tracks the stack formed by JS invocation trace events up to a given point.\n * F.e. FunctionCall, EvaluateScript, V8Execute.\n * Not to be confused with ProfileCalls.\n */\nconst jsInvokeStack: Types.TraceEvents.TraceEventData[] = [];\n/**\n * Tracks reflow events in a task.\n */\nconst taskReflowEvents: Types.TraceEvents.TraceEventData[] = [];\n\nexport const FORCED_REFLOW_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(30));\n\nexport const LONG_MAIN_THREAD_TASK_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\n\nexport function reset(): void {\n  warningsPerEvent.clear();\n  eventsPerWarning.clear();\n  allEventsStack.length = 0;\n  jsInvokeStack.length = 0;\n  taskReflowEvents.length = 0;\n}\n\nfunction storeWarning(event: Types.TraceEvents.TraceEventData, warning: Warning): void {\n  const existingWarnings = Platform.MapUtilities.getWithDefault(warningsPerEvent, event, () => []);\n  existingWarnings.push(warning);\n  warningsPerEvent.set(event, existingWarnings);\n\n  const existingEvents = Platform.MapUtilities.getWithDefault(eventsPerWarning, warning, () => []);\n  existingEvents.push(event);\n  eventsPerWarning.set(warning, existingEvents);\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  processForcedReflowWarning(event);\n  if (event.name === Types.TraceEvents.KnownEventName.RunTask) {\n    const {duration} = Helpers.Timing.eventTimingsMicroSeconds(event);\n    if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {\n      storeWarning(event, 'LONG_TASK');\n    }\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventFireIdleCallback(event)) {\n    const {duration} = Helpers.Timing.eventTimingsMilliSeconds(event);\n    if (duration > event.args.data.allottedMilliseconds) {\n      storeWarning(event, 'IDLE_CALLBACK_OVER_TIME');\n    }\n    return;\n  }\n}\n\n/**\n * Reflows* are added a warning to if:\n * 1. They are forced/sync, meaning they are invoked by JS and finish\n *    during the Script execution.\n * 2. Their duration exceeds a threshold.\n * - *Reflow: The style recalculation and layout steps in a render task.\n */\nfunction processForcedReflowWarning(event: Types.TraceEvents.TraceEventData): void {\n  // Update the event and the JS invocation stacks.\n  accomodateEventInStack(event, allEventsStack);\n  accomodateEventInStack(event, jsInvokeStack, /* pushEventToStack */ Types.TraceEvents.isJSInvocationEvent(event));\n  if (jsInvokeStack.length) {\n    // Current event falls inside a JS call.\n    if (event.name === Types.TraceEvents.KnownEventName.Layout ||\n        event.name === Types.TraceEvents.KnownEventName.UpdateLayoutTree) {\n      // A forced reflow happened. However we need to check if\n      // the threshold is surpassed to add a warning. Accumulate the\n      // event to check for this after the current Task is over.\n      taskReflowEvents.push(event);\n      return;\n    }\n  }\n  if (allEventsStack.length === 1) {\n    // We hit a new task. Check if the forced reflows in the previous\n    // task exceeded the threshold and add a warning if so.\n    const totalTime = taskReflowEvents.reduce((time, event) => time + (event.dur || 0), 0);\n    if (totalTime >= FORCED_REFLOW_THRESHOLD) {\n      taskReflowEvents.forEach(reflowEvent => storeWarning(reflowEvent, 'FORCED_REFLOW'));\n    }\n    taskReflowEvents.length = 0;\n  }\n}\n\n/**\n * Updates a given trace event stack given a new event.\n */\nfunction accomodateEventInStack(\n    event: Types.TraceEvents.TraceEventData, stack: Types.TraceEvents.TraceEventData[], pushEventToStack = true): void {\n  let nextItem = stack.at(-1);\n  while (nextItem && event.ts > nextItem.ts + (nextItem.dur || 0)) {\n    stack.pop();\n    nextItem = stack.at(-1);\n  }\n  if (!pushEventToStack) {\n    return;\n  }\n  stack.push(event);\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['UserInteractions'];\n}\n\nexport async function finalize(): Promise<void> {\n  // These events do exist on the UserInteractionsHandler, but we also put\n  // them into the WarningsHandler so that the warnings handler can be the\n  // source of truth and the way to look up all warnings for a given event.\n  // Otherwise, we would have to look up warnings across multiple handlers for\n  // a given event, which will start to get messy very quickly.\n  const longInteractions = userInteractionsHandlerData().interactionsOverThreshold;\n  for (const interaction of longInteractions) {\n    storeWarning(interaction, 'LONG_INTERACTION');\n  }\n}\n\nexport function data(): WarningsData {\n  return {\n    perEvent: warningsPerEvent,\n    perWarning: eventsPerWarning,\n  };\n}\n"]}