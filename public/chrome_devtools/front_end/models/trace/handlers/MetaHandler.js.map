{"version":3,"file":"MetaHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/MetaHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\n// We track the renderer processes we see in each frame on the way through the trace.\nconst rendererProcessesByFrameId: FrameProcessData = new Map();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId: string = '';\nlet mainFrameURL: string = '';\n\nconst framesByProcessId = new Map<Types.TraceEvents.ProcessID, Map<string, Types.TraceEvents.TraceFrame>>();\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet browserThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet gpuProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet gpuThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet viewportRect: DOMRect|null = null;\n\nconst processNames: Map<Types.TraceEvents.ProcessID, Types.TraceEvents.TraceEventProcessName> = new Map();\n\nconst topLevelRendererIds = new Set<Types.TraceEvents.ProcessID>();\nconst traceBounds: Types.Timing.TraceWindowMicroSeconds = {\n  min: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n  max: Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY),\n  range: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n};\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n *\n * We also additionally maintain an array of only navigations that occured on\n * the main frame. In many places in the UI we only care about highlighting\n * main frame navigations, so calculating this list here is better than\n * filtering either of the below maps over and over again at the UI layer.\n */\nconst navigationsByFrameId = new Map<string, Types.TraceEvents.TraceEventNavigationStart[]>();\nconst navigationsByNavigationId = new Map<string, Types.TraceEvents.TraceEventNavigationStart>();\nconst mainFrameNavigations: Types.TraceEvents.TraceEventNavigationStart[] = [];\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nconst threadsInProcess =\n    new Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>();\n\nlet traceStartedTimeFromTracingStartedEvent = Types.Timing.MicroSeconds(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.TraceEvents.Phase.BEGIN,\n  Types.TraceEvents.Phase.END,\n  Types.TraceEvents.Phase.COMPLETE,\n  Types.TraceEvents.Phase.INSTANT,\n]);\n\nlet handlerState = HandlerState.UNINITIALIZED;\n// Tracks if the trace is a generic trace, which here means that it did not come from athe DevTools Performance Panel recording.\n// We assume a trace is generic, and mark it as not generic if we see any of:\n// - TracingStartedInPage\n// - TracingStartedInBrowser\n// - TracingSessionIdForWorker\n// These are all events which indicate this is a Chrome browser trace.\nlet traceIsGeneric = true;\nconst CHROME_WEB_TRACE_EVENTS = new Set([\n  Types.TraceEvents.KnownEventName.TracingStartedInPage,\n  Types.TraceEvents.KnownEventName.TracingSessionIdForWorker,\n  Types.TraceEvents.KnownEventName.TracingStartedInBrowser,\n\n]);\n\nexport function reset(): void {\n  navigationsByFrameId.clear();\n  navigationsByNavigationId.clear();\n  processNames.clear();\n  mainFrameNavigations.length = 0;\n\n  browserProcessId = Types.TraceEvents.ProcessID(-1);\n  browserThreadId = Types.TraceEvents.ThreadID(-1);\n  gpuProcessId = Types.TraceEvents.ProcessID(-1);\n  gpuThreadId = Types.TraceEvents.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds.clear();\n  threadsInProcess.clear();\n  rendererProcessesByFrameId.clear();\n  framesByProcessId.clear();\n\n  traceBounds.min = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceBounds.max = Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY);\n  traceBounds.range = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceStartedTimeFromTracingStartedEvent = Types.Timing.MicroSeconds(-1);\n\n  traceIsGeneric = true;\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Meta Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nfunction updateRendererProcessByFrame(\n    event: Types.TraceEvents.TraceEventData, frame: Types.TraceEvents.TraceFrame): void {\n  const framesInProcessById = Platform.MapUtilities.getWithDefault(framesByProcessId, frame.processId, () => new Map());\n  framesInProcessById.set(frame.frame, frame);\n\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.TraceEvents.ProcessID,\n          {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return [];\n  });\n  const lastProcessData = rendererProcessInfo.at(-1);\n\n  // Only store a new entry if the URL changed, otherwise it's just\n  // redundant information.\n  if (lastProcessData && lastProcessData.frame.url === frame.url) {\n    return;\n  }\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.push({\n    frame,\n    window: {\n      min: event.ts,\n      max: Types.Timing.MicroSeconds(0),\n      range: Types.Timing.MicroSeconds(0),\n    },\n  });\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Meta Handler is not initialized');\n  }\n\n  if (traceIsGeneric && CHROME_WEB_TRACE_EVENTS.has(event.name as Types.TraceEvents.KnownEventName)) {\n    traceIsGeneric = false;\n  }\n\n  if (Types.TraceEvents.isProcessName(event)) {\n    processNames.set(event.pid, event);\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.MicroSeconds(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur || Types.Timing.MicroSeconds(0);\n    traceBounds.max = Types.Timing.MicroSeconds(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.TraceEvents.isProcessName(event) &&\n      (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.TraceEvents.isTraceEventMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.TraceEvents.isTraceEventTracingStartedInBrowser(event)) {\n    traceStartedTimeFromTracingStartedEvent = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (!frame.parent) {\n        topLevelRendererIds.add(frame.processId);\n      }\n      /**\n       * The code here uses a few different methods to try to determine the main frame.\n       * The ideal is that the frames have two flags present:\n       *\n       * 1. isOutermostMainFrame (added in April 2024 - crrev.com/c/5424783)\n       * 2. isInPrimaryMainFrame (added in June 2024 - crrev.com/c/5595033)\n       *\n       * The frame where both of these are set to `true` is the main frame. The\n       * reason we need both of these flags to have 100% confidence is because\n       * with the introduction of MPArch and pre-rendering, we can have other\n       * frames that are the outermost frame, but are not the primary process.\n       * Relying on isOutermostMainFrame in isolation caused the engine to\n       * incorrectly identify the wrong frame as main (see crbug.com/343873756).\n       *\n       * See https://source.chromium.org/chromium/chromium/src/+/main:docs/frame_trees.md\n       * for a bit more context on FrameTrees in Chromium.\n       *\n       * To avoid breaking entirely for traces pre-June 2024 that don't have\n       * both of these flags, we will fallback to less accurate methods:\n       *\n       * 1. If we have isOutermostMainFrame, we will use that\n       *    (and accept we might get it wrong)\n       * 2. If we don't have isOutermostMainFrame, we fallback to finding a\n       *    frame that has a URL, but doesn't have a parent. This is a crude\n       *    guess at the main frame...but better than nothing and is historically\n       *    how DevTools identified the main frame.\n       */\n\n      const traceHasPrimaryMainFrameFlag = 'isInPrimaryMainFrame' in frame;\n      const traceHasOutermostMainFrameFlag = 'isOutermostMainFrame' in frame;\n\n      if (traceHasPrimaryMainFrameFlag && traceHasOutermostMainFrameFlag) {\n        // Ideal situation: identify the main frame as the one that has both these flags set to true.\n        if (frame.isInPrimaryMainFrame && frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else if (traceHasOutermostMainFrameFlag) {\n        // Less ideal: \"guess\" at the main thread by using this falg.\n        if (frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else {\n        // Worst case: guess by seeing if the frame doesn't have a parent, and does have a URL.\n        if (!frame.parent && frame.url) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      }\n    }\n\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.TraceEvents.isTraceEventFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.TraceEvents.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  // (The filtering of empty URLs is done in the\n  // isTraceEventNavigationStartWithURL check)\n  if (Types.TraceEvents.isTraceEventNavigationStartWithURL(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      // We have only ever seen this situation once, in crbug.com/1503982, where the user ran:\n      // window.location.href = 'javascript:console.log(\"foo\")'\n      // In this situation two identical navigationStart events are emitted with the same data, URL and ID.\n      // So, in this situation we drop/ignore any subsequent navigations if we have already seen that ID.\n      return;\n    }\n    navigationsByNavigationId.set(navigationId, event);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    if (frameId === mainFrameId) {\n      mainFrameNavigations.push(event);\n    }\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  // We try to set the minimum time by finding the event with the smallest\n  // timestamp. However, if we also got a timestamp from the\n  // TracingStartedInBrowser event, we should always use that.\n  // But in some traces (for example, CPU profiles) we do not get that event,\n  // hence why we need to check we got a timestamp from it before setting it.\n  if (traceStartedTimeFromTracingStartedEvent >= 0) {\n    traceBounds.min = traceStartedTimeFromTracingStartedEvent;\n  }\n  traceBounds.range = Types.Timing.MicroSeconds(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    const processWindowValues = [...processWindows.values()].flat();\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.MicroSeconds(traceBounds.max);\n        currentWindow.window.range = Types.Timing.MicroSeconds(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.MicroSeconds(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.MicroSeconds(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  // Sometimes in traces the TracingStartedInBrowser event can give us an\n  // incorrect initial URL for the main frame's URL - about:blank or the URL of\n  // the previous page. This doesn't matter too much except we often use this\n  // URL as the visual name of the trace shown to the user (e.g. in the history\n  // dropdown). We can be more accurate by finding the first main frame\n  // navigaton, and using its URL, if we have it.\n  // However, to avoid doing this in a case where the first navigation is far\n  // into the trace's lifecycle, we only do this in situations where the first\n  // navigation happened very soon (0.5 seconds) after the trace started\n  // recording.\n  const firstMainFrameNav = mainFrameNavigations.at(0);\n  const firstNavTimeThreshold = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(0.5));\n  if (firstMainFrameNav) {\n    const navigationIsWithinThreshold = firstMainFrameNav.ts - traceBounds.min < firstNavTimeThreshold;\n    if (firstMainFrameNav.args.data?.isOutermostMainFrame && firstMainFrameNav.args.data?.documentLoaderURL &&\n        navigationIsWithinThreshold) {\n      mainFrameURL = firstMainFrameNav.args.data.documentLoaderURL;\n    }\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport type MetaHandlerData = {\n  traceIsGeneric: boolean,\n  traceBounds: Types.Timing.TraceWindowMicroSeconds,\n  browserProcessId: Types.TraceEvents.ProcessID,\n  processNames: Map<Types.TraceEvents.ProcessID, Types.TraceEvents.TraceEventProcessName>,\n  browserThreadId: Types.TraceEvents.ThreadID,\n  gpuProcessId: Types.TraceEvents.ProcessID,\n  gpuThreadId?: Types.TraceEvents.ThreadID,\n  viewportRect?: DOMRect,\n              navigationsByFrameId: Map<string, Types.TraceEvents.TraceEventNavigationStart[]>,\n              navigationsByNavigationId: Map<string, Types.TraceEvents.TraceEventNavigationStart>,\n              threadsInProcess:\n                  Map<Types.TraceEvents.ProcessID,\n                      Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>,\n              mainFrameId: string,\n              mainFrameURL: string,\n              /**\n               * A frame can have multiple renderer processes, at the same time,\n               * a renderer process can have multiple URLs. This map tracks the\n               * processes active on a given frame, with the time window in which\n               * they were active. Because a renderer process might have multiple\n               * URLs, each process in each frame has an array of windows, with an\n               * entry for each URL it had.\n               */\n              rendererProcessesByFrame: FrameProcessData,\n              topLevelRendererIds: Set<Types.TraceEvents.ProcessID>,\n              frameByProcessId: Map<Types.TraceEvents.ProcessID, Map<string, Types.TraceEvents.TraceFrame>>,\n              mainFrameNavigations: Types.TraceEvents.TraceEventNavigationStart[],\n};\n\n// Each frame has a single render process at a given time but it can have\n// multiple render processes  during a trace, for example if a navigation\n// occurred in the frame. This map tracks the process that was active for\n// each frame at each point in time. Also, because a process can be\n// assigned to multiple URLs, there is a window for each URL a process\n// was assigned.\n//\n// Note that different sites always end up in different render\n// processes, however two different URLs can point to the same site.\n// For example: https://google.com and https://maps.google.com point to\n// the same site.\n// Read more about this in\n// https://developer.chrome.com/articles/renderingng-architecture/#threads\n// and https://web.dev/same-site-same-origin/\nexport type FrameProcessData =\n    Map<string,\n        Map<Types.TraceEvents.ProcessID,\n            {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindowMicroSeconds}[]>>;\n\nexport function data(): MetaHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Meta Handler is not finalized');\n  }\n\n  return {\n    traceBounds: {...traceBounds},\n    browserProcessId,\n    browserThreadId,\n    processNames,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.TraceEvents.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId,\n    navigationsByNavigationId,\n    threadsInProcess,\n    rendererProcessesByFrame: rendererProcessesByFrameId,\n    topLevelRendererIds,\n    frameByProcessId: framesByProcessId,\n    mainFrameNavigations,\n    traceIsGeneric,\n  };\n}\n"]}