{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/types.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,aAAa,MAAM,oBAAoB,CAAC;AA0DpD;;;;;GAKG;AACH,MAAM,UAAU,yBAAyB,CAAC,IAA8C;IACtF,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAC7B,KAAK,MAAM,WAAW,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC;QACrD,IAAI,WAAW,IAAI,IAAI,KAAK,KAAK,EAAE,CAAC;YAClC,gBAAgB,GAAG,IAAI,CAAC;YACxB,MAAM;QACR,CAAC;IACH,CAAC;IACD,OAAO,CAAC,gBAAgB,CAAC;AAC3B,CAAC","sourcesContent":["\n// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Types from './../types/types.js';\nimport * as ModelHandlers from './ModelHandlers.js';\n\nexport interface TraceEventHandler {\n  reset(): void;\n  initialize?(freshRecording?: boolean): void;\n  handleEvent(data: {}): void;\n  finalize?(): Promise<void>;\n  data(): unknown;\n  deps?(): TraceEventHandlerName[];\n  handleUserConfig?(config: Types.Configuration.Configuration): void;\n}\nexport type TraceEventHandlerName = keyof typeof ModelHandlers;\n\n// This type maps TraceEventHandler names to the return type of their data\n// function. So, for example, if we are given an object with a key of 'foo'\n// and a value which is a TraceHandler containing a data() function that\n// returns a string, this type will be { foo: string }.\n//\n// This allows us to model the behavior of the TraceProcessor in the model,\n// which takes an object with TraceEventHandlers as part of its config, and\n// which ultimately returns an object keyed off the names of the\n// TraceEventHandlers, and with values that are derived from each\n// TraceEventHandler's data function.\n//\n// So, concretely, we provide a TraceEventHandler for calculating the #time\n// bounds of a trace called TraceBounds, whose data() function returns a\n// TraceWindow. The HandlerData, therefore, would determine that the\n// TraceProcessor would contain a key called 'TraceBounds' whose value is\n// a TraceWindow.\nexport type EnabledHandlerDataWithMeta<T extends {[key: string]: TraceEventHandler}> = {\n  // We allow the user to configure which handlers are created by passing them\n  // in when constructing a model instance. However, we then ensure that the\n  // Meta handler is added to that, as the Model relies on some of the data\n  // from the Meta handler when creating the file. Therefore, this type\n  // explicitly defines that the Meta data is present, before then extending it\n  // with the index type to represent all the other handlers.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Meta: Readonly<ReturnType<typeof ModelHandlers['Meta']['data']>>,\n}&{\n  // For every key in the object, look up the TraceEventHandler's data function\n  // and use its return type as the value for the object.\n  [K in keyof T]: Readonly<ReturnType<T[K]['data']>>;\n};\n\nexport type HandlersWithMeta<T extends {[key: string]: TraceEventHandler}> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Meta: typeof ModelHandlers.Meta,\n}&{\n  [K in keyof T]: T[K];\n};\n\n// Represents the final parsed data from all of the handlers. Note that because\n// we are currently in the middle of the migration of data engines, not all the\n// handlers are enabled. Therefore for now you should use the type defined in\n// models/trace/handlers/Migration.ts, `PartialTraceData`, which\n// represents the final parsed data for only the enabled handlers.\nexport type TraceParseData = Readonly<EnabledHandlerDataWithMeta<typeof ModelHandlers>>;\n\n/**\n * Because you can run the trace engine with a subset of handlers enabled,\n * there can be times when you need to confirm if the trace contains all\n * handlers or not, because some parts of the engine expect to be given all\n * the handlers.\n */\nexport function handlerDataHasAllHandlers(data: Readonly<EnabledHandlerDataWithMeta<{}>>): data is TraceParseData {\n  let isMissingHandler = false;\n  for (const handlerName of Object.keys(ModelHandlers)) {\n    if (handlerName in data === false) {\n      isMissingHandler = true;\n      break;\n    }\n  }\n  return !isMissingHandler;\n}\n\ntype DeepWriteable<T> = {\n  -readonly[P in keyof T]: DeepWriteable<T[P]>\n};\nexport type TraceParseDataMutable = DeepWriteable<TraceParseData>;\n\nexport type Handlers = typeof ModelHandlers;\n\nexport const enum HandlerState {\n  UNINITIALIZED = 1,\n  INITIALIZED = 2,\n  FINALIZED = 3,\n}\n"]}