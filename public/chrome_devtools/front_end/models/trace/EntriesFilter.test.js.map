{"version":3,"file":"EntriesFilter.test.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/EntriesFilter.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Copyright 2023222 The Chromium Author2s. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {TraceLoader} from '../../testing/TraceLoader.js';\nimport * as TraceEngine from '../trace/trace.js';\n\nfunction getMainThread(data: TraceEngine.Handlers.ModelHandlers.Renderer.RendererHandlerData):\n    TraceEngine.Handlers.ModelHandlers.Renderer.RendererThread {\n  let mainThread: TraceEngine.Handlers.ModelHandlers.Renderer.RendererThread|null = null;\n  for (const [, process] of data.processes) {\n    for (const [, thread] of process.threads) {\n      if (thread.name === 'CrRendererMain') {\n        mainThread = thread;\n        break;\n      }\n    }\n  }\n  if (!mainThread) {\n    throw new Error('Could not find main thread.');\n  }\n  return mainThread;\n}\n\nfunction findFirstEntry(\n    allEntries: readonly TraceEngine.Types.TraceEvents.SyntheticTraceEntry[],\n    predicate: (entry: TraceEngine.Types.TraceEvents.SyntheticTraceEntry) =>\n        boolean): TraceEngine.Types.TraceEvents.SyntheticTraceEntry {\n  const entry = allEntries.find(entry => predicate(entry));\n  if (!entry) {\n    throw new Error('Could not find expected entry.');\n  }\n  return entry;\n}\n\ndescribe('EntriesFilter', function() {\n  it('parses a stack and returns an empty list of invisible entries', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    assert.deepEqual([], stack?.invisibleEntries());\n  });\n\n  it('supports the user merging an entry into its parent', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *                  ==== fibonacci ===\n     *\n     * In this test we want to test the user merging basicTwo into its parent, so the resulting trace should look like so:\n     * ======== basicStackOne ============\n     * =========== basicThree ============ << No more basicTwo, it has been merged.\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *                  ==== fibonacci ===\n     *\n     **/\n    const entryTwo = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.MERGE_FUNCTION, entry: entryTwo});\n    assert.isTrue(stack.invisibleEntries().includes(entryTwo), 'entryTwo is invisble');\n    // Only one entry - the one for the `basicTwo` function - should have been hidden.\n    assert.strictEqual(stack.invisibleEntries().length, 1);\n  });\n\n  it('adds the parent of the merged entry into the expandableEntries array', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *\n     * In this test we want to test that the parent of the merged entry is added to the expandableEntries array,\n     * so that later an array decoration is added to it and the merged entry could be shown again if the array is clicked.\n     * the user merging basicTwo into its parent, so the resulting trace should look like so:\n     * ======== basicStackOne ============ << As parent of basicTwo, it belongs to the expandableEntries array\n     * =========== basicThree ============ << No more basicTwo, it has been merged.\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *\n     **/\n    const entryTwo = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.MERGE_FUNCTION, entry: entryTwo});\n    assert.isTrue(stack.invisibleEntries().includes(entryTwo), 'entryTwo is invisble');\n\n    // Get the parent of basicTwo, which is basicStackOne.\n    const basicStackOne = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicStackOne' &&\n          entry.dur === 827;\n    });\n    // Get the parent of basicTwo marked as expandable.\n    assert.isTrue(stack.isEntryExpandable(basicStackOne));\n  });\n\n  it('adds the collapsed entry into the expandableEntries array', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *\n     * In this test we want to test that the collapsed entry is added to the expandableEntries array,\n     * so that later an arrow decoration is added to it and the collapsed entries could be shown again if the arraw is clicked.\n     *\n     * The user collapses basicTwo, so the resulting trace should look like so:\n     * ======== basicStackOne ============\n     * =========== basicTwo ============ << All entries under basicTwo merged collapsed and it belongs to the expandableEntries array\n     *\n     **/\n    const entryTwo = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_FUNCTION, entry: entryTwo});\n    // basicTwo is marked as expandable.\n    assert.isTrue(stack.isEntryExpandable(entryTwo));\n  });\n\n  it('adds the next visible parent of the merged entry into the expandableEntries array if the direct parent is hidden',\n     async function() {\n       const data = await TraceLoader.traceEngine(this, 'two-functions-recursion.json.gz');\n       const mainThread = getMainThread(data.Renderer);\n       /** This stack looks roughly like so (with some events omitted):\n        * ======== onclick ============\n        * =========== foo =============\n        *               ==== foo2 =====\n        *               ===== foo =====\n        *               ==== foo2 =====\n        *               ===== foo =====\n        *               ==== foo2 =====\n        *               ===== foo =====\n        *\n        * In this test we want to test that the next visible parent of the merged entry is added to the\n        * expandableEntries array even if the direct one is hidden by some other action,\n        * so that later an array decoration is added to it and the merged entry could be shown again if the array is clicked.\n        *\n        * collapse all repeating calls of foo after the first one:\n        * ======== onclick ============\n        * =========== foo =============                  << all foo except first removed\n        *               ===== foo2 ====\n        *               ==== foo2 =====                  << direct parent is not visible anymore\n        *               ==== foo2 =====\n        *\n        * merge second foo2 and add the next visible parent to the expandableEntries array:\n        * ======== onclick ============\n        * =========== foo =============\n        *               ===== foo2 ====                  << added to expandableEntries as the next visible parent of the merged entry\n        *               ==== foo2 =====\n        *\n        **/\n       const firstFooCallEntry = findFirstEntry(mainThread.entries, entry => {\n         return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo' &&\n             entry.dur === 233;\n       });\n       const firstFooCallEndTime = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(firstFooCallEntry).endTime;\n       const fooCalls = mainThread.entries.filter(entry => {\n         const isFooCall = TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo';\n         if (!isFooCall) {\n           return false;\n         }\n         const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n         return endTime <= firstFooCallEndTime;\n       });\n       const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n       if (!stack) {\n         throw new Error('EntriesFilter does not exist');\n       }\n       // Collapse all foo calls after the first one.\n       stack.applyFilterAction({\n         type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_REPEATING_DESCENDANTS,\n         entry: firstFooCallEntry,\n       });\n\n       // First foo call is marked as expandable since its' children are hidden.\n       assert.isTrue(stack.isEntryExpandable(firstFooCallEntry));\n\n       // Make sure all foo calls after first are hidden.\n       const allFooExceptFirstInStackAreHidden = fooCalls.every((fooCall, i) => {\n         if (i === 0) {\n           // First foo should not be invisible.\n           return !stack.invisibleEntries().includes(fooCall);\n         }\n         return stack.invisibleEntries().includes(fooCall);\n       });\n       assert.isTrue(\n           allFooExceptFirstInStackAreHidden, 'First foo is invisible or some following foo calls are still visible');\n\n       const foo2Calls = mainThread.entries.filter(entry => {\n         const isFoo2Call =\n             TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo2';\n         if (!isFoo2Call) {\n           return false;\n         }\n         const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n         return endTime <= firstFooCallEndTime;\n       });\n\n       // Merge second foo2 entry.\n       stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.MERGE_FUNCTION, entry: foo2Calls[1]});\n       // First foo2 entry should be in the expandableEntries array.\n       assert.isTrue(stack.isEntryExpandable(foo2Calls[0]));\n     });\n\n  it('supports collapsing an entry', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *                  ==== fibonacci ===\n     *\n     * In this test we want to test the user collapsing basicTwo, which should have the effect of keeping basicTwo visible, but removing all of its children:\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     *                                    << all children removed\n     **/\n    const basicTwoCallEntry = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n\n    // Gather the fib() calls under the first basicTwo stack, by finding all\n    // the calls whose end time is less than or equal to the end time of the\n    // `basicTwo` function.\n    const fibonacciCalls = mainThread.entries.filter(entry => {\n      const isFibCall =\n          TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'fibonacci';\n      if (!isFibCall) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      const basicTwoCallEndTime = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(basicTwoCallEntry).endTime;\n      return endTime <= basicTwoCallEndTime;\n    });\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_FUNCTION, entry: basicTwoCallEntry});\n\n    // We collapsed at the `basicTwo` entry - so it should not be included in the invisible list itself.\n    assert.isFalse(stack.invisibleEntries().includes(basicTwoCallEntry), 'entryTwo is not visible');\n    // But all fib() calls below it in the stack should now be invisible.\n    const allFibonacciInStackAreHidden = fibonacciCalls.every(fibCall => {\n      return stack.invisibleEntries().includes(fibCall);\n    });\n    assert.isTrue(allFibonacciInStackAreHidden, 'Some fibonacci calls are still visible');\n  });\n\n  it('supports collapsing all repeating entries among descendants', async function() {\n    const data = await TraceLoader.traceEngine(this, 'two-functions-recursion.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== onclick ============\n     * =========== foo =============\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *\n     * In this test we want to test the user collapsing all descendant foo calls of the first first one,\n     * which should have the effect of keeping the first foo visible, but removing all of its other calls:\n     * ======== onclick ============\n     * =========== foo =============\n     *               ===== foo2 ====                  << all foo except first removed\n     *               ==== foo2 =====\n     *               ==== foo2 =====\n     **/\n\n    const firstFooCallEntry = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo' &&\n          entry.dur === 233;\n    });\n\n    // Gather the foo() and foo2() calls under and including the first foo entry, by finding all\n    // the calls whose end time is less than or equal to the end time of the first `foo` function.\n    const firstFooCallEndTime = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(firstFooCallEntry).endTime;\n    const fooCalls = mainThread.entries.filter(entry => {\n      const isFooCall = TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo';\n      if (!isFooCall) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      return endTime <= firstFooCallEndTime;\n    });\n\n    const foo2Calls = mainThread.entries.filter(entry => {\n      const isFoo2Call = TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo2';\n      if (!isFoo2Call) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      return endTime <= firstFooCallEndTime;\n    });\n\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction(\n        {type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_REPEATING_DESCENDANTS, entry: firstFooCallEntry});\n\n    // We collapsed identical descendants after the first `foo` entry - so it should not be included in the invisible list itself,\n    // but all foo() calls below it in the stack should now be invisible.\n    const allFooExceptFirstInStackAreHidden = fooCalls.every((fooCall, i) => {\n      if (i === 0) {\n        // First foo should not be invisible.\n        return !stack.invisibleEntries().includes(fooCall);\n      }\n      return stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(\n        allFooExceptFirstInStackAreHidden, 'First foo is invisible or some following foo calls are still visible');\n\n    // All of the foo2 calls that were inbetween foo calls should still be visible.\n    const allFoo2InStackAreVisible = foo2Calls.every(fooCall => {\n      return !stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(allFoo2InStackAreVisible, 'Some foo2 calls are invisible');\n  });\n\n  it('supports undo all filter actions by applying context menu undo action', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *                  ==== fibonacci ===\n     *\n     * In this test we want to test the user undoing all actions with 'undo all actions' after applying merge, collapse repeating descendants and collapse function.\n     *\n     * First, collapse all repeating descendants of the first fibonacci call:\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===                  << repeating children removed\n     *\n     * Then, merge basicStackOne:\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *\n     * Finally, collapse basicTwo():\n     * =========== basicTwo ==============\n     *\n     * Applying 'undo all actions' should bring the stack to the original state.\n     **/\n\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    const basicTwoCallEntry = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n    const fibonacciCalls = mainThread.entries.filter(entry => {\n      const isFibCall =\n          TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'fibonacci';\n      if (!isFibCall) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      const basicTwoCallEndTime = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(basicTwoCallEntry).endTime;\n      return endTime <= basicTwoCallEndTime;\n    });\n\n    // Collapse all repeating descendants of the first fibonacci call:\n    stack.applyFilterAction(\n        {type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_REPEATING_DESCENDANTS, entry: fibonacciCalls[0]});\n    // We collapsed identical descendants after the first `foo` entry - so it should not be included in the invisible list itself,\n    // but all foo() calls below it in the stack should now be invisible.\n    const allFibExceptFirstInStackAreHidden = fibonacciCalls.every((fibCall, i) => {\n      if (i === 0) {\n        // First foo should not be invisible.\n        return !stack.invisibleEntries().includes(fibCall);\n      }\n      return stack.invisibleEntries().includes(fibCall);\n    });\n    assert.isTrue(\n        allFibExceptFirstInStackAreHidden, 'First fib is invisible or some following fib calls are still visible');\n\n    // Merge basicStackOne:\n    const basicStackOne = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicStackOne' &&\n          entry.dur === 827;\n    });\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.MERGE_FUNCTION, entry: basicStackOne});\n    assert.isTrue(stack.invisibleEntries().includes(basicStackOne), 'entrybasicStackOneTwo is visble');\n\n    // Collapse basicTwo():\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_FUNCTION, entry: basicTwoCallEntry});\n    // basicThree and first fibnacci should now be hidden:\n    const basicThree = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicThree' &&\n          entry.dur === 827;\n    });\n    assert.isTrue(stack.invisibleEntries().includes(basicThree), 'basicThree is visble');\n    assert.isTrue(stack.invisibleEntries().includes(fibonacciCalls[0]), 'first fibonacci is visble');\n\n    // Apply UNDO_ALL_ACTIONS to bring back all of the hidden entries:\n    // UNDO_ALL_ACTIONS can be called on any visible entry\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.UNDO_ALL_ACTIONS, entry: basicTwoCallEntry});\n    // If the length of invisibleEntries list is 0, all of the entries added earlier were removed and are now visible.\n    assert.strictEqual(stack.invisibleEntries().length, 0);\n  });\n\n  it('supports resetting children of the closest expandable parent when a hidden entry is provided', async function() {\n    const data = await TraceLoader.traceEngine(this, 'basic-stack.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *              ======== fibonacci ===\n     *                  ==== fibonacci ===\n     *\n     * In this test we want to test the user selecting an entry that is hidden via a link.\n     * If this happens, we should reveal this entry to resetting children of the closest expandable parent.\n     *\n     * First, collapse all children of the basicTwo:\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============                  << children collapsed\n     * =========== basicThree ============\n     *              ======== fibonacci ===                  << repeating children removed\n     *\n     * Then, reveal the first fibonacci entry that is hidden:\n     * ======== basicStackOne ============\n     * =========== basicTwo ==============\n     * =========== basicThree ============\n     *              ======== fibonacci ===                  << reveal this hidden entry\n     *              ======== fibonacci ===\n     *\n     * This should result in all basicTwo children being removed from the invisible array and stack being in the initial state.\n     **/\n\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    const basicTwoCallEntry = findFirstEntry(mainThread.entries, entry => {\n      // Processing this trace ends up with two distinct stacks for basicTwo()\n      // So we find the first one so we can focus this test on just one stack.\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'basicTwo' &&\n          entry.dur === 827;\n    });\n\n    // Make sure no entries are hidden\n    assert.strictEqual(stack.invisibleEntries().length, 0);\n\n    // Collapse all children of basicTwo call:\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_FUNCTION, entry: basicTwoCallEntry});\n\n    // Make sure all 37 of basicTwo descdendants are hidden\n    assert.strictEqual(stack.invisibleEntries().length, 37);\n\n    // Get the first fibonacci call that is one of the hidden children and make sure it is hidden\n    const firstFibCallEntry = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'fibonacci';\n    });\n\n    assert.isTrue(stack.invisibleEntries().includes(firstFibCallEntry));\n\n    // Reveal the first fibonacci call and make sure that the all of the entries are now visible because the closest\n    // expandable parent to the fib call is basicTwo and, therefore, we need to reset its children.\n    stack.revealEntry(firstFibCallEntry);\n    assert.strictEqual(stack.invisibleEntries().length, 0);\n  });\n\n  it('supports resetting all hidden children of a selected entry', async function() {\n    const data = await TraceLoader.traceEngine(this, 'two-functions-recursion.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some events omitted):\n     * ======== onclick ============\n     * =========== foo =============\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *\n     * In this test we want to test the user collapsing all descendant foo calls of the first first one,\n     * which should have the effect of keeping the first foo visible, but removing all of its other calls:\n     * ======== onclick ============\n     * =========== foo =============\n     *               ===== foo2 ====                  << all foo except first removed\n     *               ==== foo2 =====\n     *               ==== foo2 =====\n     *\n     * Then, reset children on the second visible foo2.\n     * ======== onclick ============\n     * =========== foo =============\n     *               ===== foo2 ====                  << foo() after this entry still hidden\n     *               ==== foo2 =====                  << all children from this node are visible\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *\n     * This results in a stack where all children of an entry children were reset on (second foo2)\n     * are visible, but the entries hidden above the entry children were reset on stay hidden.\n     **/\n\n    const firstFooCallEntry = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo' &&\n          entry.dur === 233;\n    });\n\n    // Gather the foo() and foo2() calls under and including the first foo entry, by finding all\n    // the calls whose end time is less than or equal to the end time of the first `foo` function.\n    const firstFooCallEndTime = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(firstFooCallEntry).endTime;\n    const fooCalls = mainThread.entries.filter(entry => {\n      const isFooCall = TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo';\n      if (!isFooCall) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      return endTime <= firstFooCallEndTime;\n    });\n\n    const foo2Calls = mainThread.entries.filter(entry => {\n      const isFoo2Call = TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo2';\n      if (!isFoo2Call) {\n        return false;\n      }\n      const {endTime} = TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n      return endTime <= firstFooCallEndTime;\n    });\n\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    stack.applyFilterAction(\n        {type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_REPEATING_DESCENDANTS, entry: firstFooCallEntry});\n\n    // We collapsed identical descendants after the first `foo` entry - so it should not be included in the invisible list itself,\n    // but all foo() calls below it in the stack should now be invisible.\n    const allFooExceptFirstInStackAreHidden = fooCalls.every((fooCall, i) => {\n      if (i === 0) {\n        // First foo should not be invisible.\n        return !stack.invisibleEntries().includes(fooCall);\n      }\n      return stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(\n        allFooExceptFirstInStackAreHidden, 'First foo is invisible or some following foo calls are still visible');\n\n    // All of the foo2 calls that were inbetween foo calls should still be visible.\n    let allFoo2InStackAreVisible = foo2Calls.every(fooCall => {\n      return !stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(allFoo2InStackAreVisible, 'Some foo2 calls are invisible');\n\n    // Reset all children after second foo2 call\n    assert.strictEqual(foo2Calls.length, 3);\n    stack.applyFilterAction({type: TraceEngine.EntriesFilter.FilterAction.RESET_CHILDREN, entry: foo2Calls[1]});\n\n    // All foo and foo2 calls except the second foo cll should now be visible\n    allFoo2InStackAreVisible = foo2Calls.every(fooCall => {\n      return !stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(allFoo2InStackAreVisible, 'Some foo2 calls are invisible');\n\n    const allFooExceptSecondInStackAreVisible = fooCalls.every((fooCall, i) => {\n      if (i === 1) {\n        // Second foo should be invisible.\n        return stack.invisibleEntries().includes(fooCall);\n      }\n      return !stack.invisibleEntries().includes(fooCall);\n    });\n    assert.isTrue(\n        allFooExceptSecondInStackAreVisible,\n        'Some foo calls except the second one are invisible or the second one is visible');\n  });\n\n  it('correctly returns the amount of hidden children of a node', async function() {\n    const data = await TraceLoader.traceEngine(this, 'two-functions-recursion.json.gz');\n    const mainThread = getMainThread(data.Renderer);\n    /** This stack looks roughly like so (with some erlier events omitted):\n     * ======== onclick ============\n     * =========== foo =============\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *               ==== foo2 =====\n     *               ===== foo =====\n     *\n     * In this test we want to test if the amount of hidden children returned is correct:\n     * If we collapse repeating children on the first foo call, the 3 child foo calls should be removed.\n     * Therefore, the amount of hidden children should be equal to 3.\n     * ======== onclick ============\n     * =========== foo =============                  << all foo except first hidden\n     *               ===== foo2 ====\n     *               ==== foo2 =====\n     *               ==== foo2 =====\n     **/\n\n    const firstFooCallEntry = findFirstEntry(mainThread.entries, entry => {\n      return TraceEngine.Types.TraceEvents.isProfileCall(entry) && entry.callFrame.functionName === 'foo' &&\n          entry.dur === 233;\n    });\n\n    const stack = new TraceEngine.EntriesFilter.EntriesFilter(data.Renderer.entryToNode);\n    if (!stack) {\n      throw new Error('EntriesFilter does not exist');\n    }\n    // Before applying any action on a node, there should be no entries hidden under it\n    assert.strictEqual(stack.findHiddenDescendantsAmount(firstFooCallEntry), 0);\n\n    stack.applyFilterAction(\n        {type: TraceEngine.EntriesFilter.FilterAction.COLLAPSE_REPEATING_DESCENDANTS, entry: firstFooCallEntry});\n\n    // There should be 3 foo() entries hidden under the first foo call entry\n    assert.strictEqual(stack.findHiddenDescendantsAmount(firstFooCallEntry), 3);\n  });\n});\n"]}