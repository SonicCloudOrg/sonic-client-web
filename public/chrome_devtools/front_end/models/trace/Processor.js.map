{"version":3,"file":"Processor.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/Processor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from './handlers/handlers.js';\nimport * as Insights from './insights/insights.js';\nimport * as Types from './types/types.js';\n\nconst enum Status {\n  IDLE = 'IDLE',\n  PARSING = 'PARSING',\n  FINISHED_PARSING = 'FINISHED_PARSING',\n  ERRORED_WHILE_PARSING = 'ERRORED_WHILE_PARSING',\n}\n\nexport type TraceParseEventProgressData = {\n  index: number,\n  total: number,\n};\n\nexport class TraceParseProgressEvent extends Event {\n  static readonly eventName = 'traceparseprogress';\n  constructor(public data: TraceParseEventProgressData, init: EventInit = {bubbles: true}) {\n    super(TraceParseProgressEvent.eventName, init);\n  }\n}\ndeclare global {\n  interface HTMLElementEventMap {\n    [TraceParseProgressEvent.eventName]: TraceParseProgressEvent;\n  }\n}\n\nexport class TraceProcessor<EnabledModelHandlers extends {[key: string]: Handlers.Types.TraceEventHandler}> extends\n    EventTarget {\n  // We force the Meta handler to be enabled, so the TraceHandlers type here is\n  // the model handlers the user passes in and the Meta handler.\n  readonly #traceHandlers: Handlers.Types.HandlersWithMeta<EnabledModelHandlers>;\n  #status = Status.IDLE;\n  #modelConfiguration = Types.Configuration.defaults();\n  #data: Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>|null = null;\n  #insights: Insights.Types.TraceInsightData<EnabledModelHandlers>|null = null;\n\n  static createWithAllHandlers(): TraceProcessor<typeof Handlers.ModelHandlers> {\n    return new TraceProcessor(Handlers.ModelHandlers, Types.Configuration.defaults());\n  }\n\n  constructor(traceHandlers: EnabledModelHandlers, modelConfiguration?: Types.Configuration.Configuration) {\n    super();\n\n    this.#verifyHandlers(traceHandlers);\n    this.#traceHandlers = {\n      Meta: Handlers.ModelHandlers.Meta,\n      ...traceHandlers,\n    };\n    if (modelConfiguration) {\n      this.#modelConfiguration = modelConfiguration;\n    }\n    this.#passConfigToHandlers();\n  }\n\n  #passConfigToHandlers(): void {\n    for (const handler of Object.values(this.#traceHandlers)) {\n      // Bit of an odd double check, but without this TypeScript refuses to let\n      // you call the function as it thinks it might be undefined.\n      if ('handleUserConfig' in handler && handler.handleUserConfig) {\n        handler.handleUserConfig(this.#modelConfiguration);\n      }\n    }\n  }\n\n  /**\n   * When the user passes in a set of handlers, we want to ensure that we have all\n   * the required handlers. Handlers can depend on other handlers, so if the user\n   * passes in FooHandler which depends on BarHandler, they must also pass in\n   * BarHandler too. This method verifies that all dependencies are met, and\n   * throws if not.\n   **/\n  #verifyHandlers(providedHandlers: EnabledModelHandlers): void {\n    // Tiny optimisation: if the amount of provided handlers matches the amount\n    // of handlers in the Handlers.ModelHandlers object, that means that the\n    // user has passed in every handler we have. So therefore they cannot have\n    // missed any, and there is no need to iterate through the handlers and\n    // check the dependencies.\n    if (Object.keys(providedHandlers).length === Object.keys(Handlers.ModelHandlers).length) {\n      return;\n    }\n    const requiredHandlerKeys: Set<Handlers.Types.TraceEventHandlerName> = new Set();\n    for (const [handlerName, handler] of Object.entries(providedHandlers)) {\n      requiredHandlerKeys.add(handlerName as Handlers.Types.TraceEventHandlerName);\n      for (const depName of (handler.deps?.() || [])) {\n        requiredHandlerKeys.add(depName);\n      }\n    }\n\n    const providedHandlerKeys = new Set(Object.keys(providedHandlers));\n    // We always force the Meta handler to be enabled when creating the\n    // Processor, so if it is missing from the set the user gave us that is OK,\n    // as we will have enabled it anyway.\n    requiredHandlerKeys.delete('Meta');\n\n    for (const requiredKey of requiredHandlerKeys) {\n      if (!providedHandlerKeys.has(requiredKey)) {\n        throw new Error(`Required handler ${requiredKey} not provided.`);\n      }\n    }\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#data = null;\n    this.#insights = null;\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording = false): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);\n    }\n    try {\n      this.#status = Status.PARSING;\n      await this.#parse(traceEvents, freshRecording);\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    }\n  }\n\n  async #parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording: boolean): Promise<void> {\n    /**\n     * We want to yield regularly to maintain responsiveness. If we yield too often, we're wasting idle time.\n     * We could do this by checking `performance.now()` regularly, but it's an expensive call in such a hot loop.\n     * `eventsPerChunk` is an approximated proxy metric.\n     * But how big a chunk? We're aiming for long tasks that are no smaller than 100ms and not bigger than 200ms.\n     * It's CPU dependent, so it should be calibrated on oldish hardware.\n     * Illustration of a previous change to `eventsPerChunk`: https://imgur.com/wzp8BnR\n     */\n    const eventsPerChunk = 50_000;\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n\n    // Reset.\n    for (const handler of sortedHandlers) {\n      handler.reset();\n    }\n\n    // Initialize.\n    for (const handler of sortedHandlers) {\n      handler.initialize?.(freshRecording);\n    }\n\n    // Handle each event.\n    for (let i = 0; i < traceEvents.length; ++i) {\n      // Every so often we take a break just to render.\n      if (i % eventsPerChunk === 0 && i) {\n        // Take the opportunity to provide status update events.\n        this.dispatchEvent(new TraceParseProgressEvent({index: i, total: traceEvents.length}));\n        // TODO(paulirish): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n      const event = traceEvents[i];\n      for (let j = 0; j < sortedHandlers.length; ++j) {\n        sortedHandlers[j].handleEvent(event);\n      }\n    }\n\n    // Finalize.\n    for (const handler of sortedHandlers) {\n      if (handler.finalize) {\n        // Yield to the UI because finalize() calls can be expensive\n        // TODO(jacktfranklin): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n        await new Promise(resolve => setTimeout(resolve, 0));\n        await handler.finalize();\n      }\n    }\n  }\n\n  get traceParsedData(): Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    if (this.#data) {\n      return this.#data;\n    }\n\n    // Handlers that depend on other handlers do so via .data(), which used to always\n    // return a shallow clone of its internal data structures. However, that pattern\n    // easily results in egregious amounts of allocation. Now .data() does not do any\n    // cloning, and it happens here instead so that users of the trace processor may\n    // still assume that the parsed data is theirs.\n    // See: crbug/41484172\n    const shallowClone = (value: unknown, recurse = true): unknown => {\n      if (value instanceof Map) {\n        return new Map(value);\n      }\n      if (value instanceof Set) {\n        return new Set(value);\n      }\n      if (Array.isArray(value)) {\n        return [...value];\n      }\n      if (typeof value === 'object' && value && recurse) {\n        const obj: Record<string, unknown> = {};\n        for (const [key, v] of Object.entries(value)) {\n          obj[key] = shallowClone(v, false);\n        }\n        return obj;\n      }\n      return value;\n    };\n\n    const traceParsedData = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      const data = shallowClone(handler.data());\n      Object.assign(traceParsedData, {[name]: data});\n    }\n\n    this.#data = traceParsedData as Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>;\n    return this.#data;\n  }\n\n  #getEnabledInsightRunners(traceParsedData: Handlers.Types.EnabledHandlerDataWithMeta<EnabledModelHandlers>):\n      Insights.Types.EnabledInsightRunners<EnabledModelHandlers> {\n    const enabledInsights = {} as Insights.Types.EnabledInsightRunners<EnabledModelHandlers>;\n    for (const [name, insight] of Object.entries(Insights.InsightRunners)) {\n      const deps = insight.deps();\n      if (deps.some(dep => !traceParsedData[dep])) {\n        continue;\n      }\n      Object.assign(enabledInsights, {[name]: insight.generateInsight});\n    }\n    return enabledInsights;\n  }\n\n  get insights(): Insights.Types.TraceInsightData<EnabledModelHandlers>|null {\n    if (!this.traceParsedData) {\n      return null;\n    }\n\n    if (this.#insights) {\n      return this.#insights;\n    }\n\n    this.#insights = new Map();\n\n    const enabledInsightRunners = this.#getEnabledInsightRunners(this.traceParsedData);\n\n    for (const nav of this.traceParsedData.Meta.mainFrameNavigations) {\n      if (!nav.args.frame || !nav.args.data?.navigationId) {\n        continue;\n      }\n\n      const context = {\n        frameId: nav.args.frame,\n        navigationId: nav.args.data.navigationId,\n      };\n\n      const navInsightData = {} as Insights.Types.NavigationInsightData<EnabledModelHandlers>;\n      for (const [name, generateInsight] of Object.entries(enabledInsightRunners)) {\n        let insightResult;\n        try {\n          insightResult = generateInsight(this.traceParsedData, context);\n        } catch (err) {\n          insightResult = err;\n        }\n        Object.assign(navInsightData, {[name]: insightResult});\n      }\n\n      this.#insights.set(context.navigationId, navInsightData);\n    }\n\n    return this.#insights;\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(\n    traceHandlers: Partial<{[key in Handlers.Types.TraceEventHandlerName]: Handlers.Types.TraceEventHandler}>):\n    Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler> {\n  const sortedMap = new Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler>();\n  const visited = new Set<Handlers.Types.TraceEventHandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.TraceEventHandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.TraceEventHandlerName);\n  }\n  return sortedMap;\n}\n"]}