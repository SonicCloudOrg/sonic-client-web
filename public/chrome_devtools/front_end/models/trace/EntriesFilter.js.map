{"version":3,"file":"EntriesFilter.js","sourceRoot":"","sources":["../../../../../../front_end/models/trace/EntriesFilter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Helpers from './helpers/helpers.js';\nimport * as Types from './types/types.js';\n\ntype EntryToNodeMap = Map<Types.TraceEvents.SyntheticTraceEntry, Helpers.TreeHelpers.TraceEntryNode>;\n\nexport const enum FilterAction {\n  MERGE_FUNCTION = 'MERGE_FUNCTION',\n  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',\n  COLLAPSE_REPEATING_DESCENDANTS = 'COLLAPSE_REPEATING_DESCENDANTS',\n  RESET_CHILDREN = 'RESET_CHILDREN',\n  UNDO_ALL_ACTIONS = 'UNDO_ALL_ACTIONS',\n}\n\nexport interface UserFilterAction {\n  type: FilterAction;\n  entry: Types.TraceEvents.SyntheticTraceEntry;\n}\n\n// Object used to indicate to the Context Menu if an action is possible on the selected entry.\nexport interface PossibleFilterActions {\n  [FilterAction.MERGE_FUNCTION]: boolean;\n  [FilterAction.COLLAPSE_FUNCTION]: boolean;\n  [FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: boolean;\n  [FilterAction.RESET_CHILDREN]: boolean;\n  [FilterAction.UNDO_ALL_ACTIONS]: boolean;\n}\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the invisibleEntries() method will return the\n * entries that are invisible, and this is the list of entries that should be\n * removed before rendering the resulting thread on the timeline.\n */\nexport class EntriesFilter {\n  // Maps from an individual TraceEvent entry to its representation as a\n  // RendererEntryNode. We need this so we can then parse the tree structure\n  // generated by the RendererHandler.\n  #entryToNode: EntryToNodeMap;\n\n  // Track the set of invisible entries.\n  #invisibleEntries: Types.TraceEvents.TraceEventData[] = [];\n  // List of entries whose children are hidden. This list is used to\n  // keep track of entries that should be identified in the UI as \"expandable\",\n  // since they can be clicked to reveal their hidden children.\n  #expandableEntries: Types.TraceEvents.TraceEventData[] = [];\n  // Cache for descendants of entry that have already been gathered. The descendants\n  // will never change so we can avoid running the potentially expensive search again.\n  #entryToDescendantsMap: Map<Helpers.TreeHelpers.TraceEntryNode, Types.TraceEvents.TraceEventData[]> = new Map();\n\n  constructor(entryToNodeMap: EntryToNodeMap) {\n    this.#entryToNode = entryToNodeMap;\n  }\n\n  /**\n   * Checks which actions can be applied on an entry. This allows us to only show possible actions in the Context Menu.\n   * For example, if an entry has no children, COLLAPSE_FUNCTION will not change the FlameChart, therefore there is no need to show this action as an option.\n   */\n  findPossibleActions(entry: Types.TraceEvents.SyntheticTraceEntry): PossibleFilterActions {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, return no possible actions.\n      return {\n        [FilterAction.MERGE_FUNCTION]: false,\n        [FilterAction.COLLAPSE_FUNCTION]: false,\n        [FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: false,\n        [FilterAction.RESET_CHILDREN]: false,\n        [FilterAction.UNDO_ALL_ACTIONS]: false,\n      };\n    }\n    const entryParent = entryNode.parent;\n    const allVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => !this.#invisibleEntries.includes(descendant));\n    const allVisibleRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode).filter(\n        descendant => !this.#invisibleEntries.includes(descendant));\n    const allInVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => this.#invisibleEntries.includes(descendant));\n\n    // If there are children to hide, indicate action as possible\n    const possibleActions: PossibleFilterActions = {\n      [FilterAction.MERGE_FUNCTION]: entryParent !== null,\n      [FilterAction.COLLAPSE_FUNCTION]: allVisibleDescendants.length > 0,\n      [FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: allVisibleRepeatingDescendants.length > 0,\n      [FilterAction.RESET_CHILDREN]: allInVisibleDescendants.length > 0,\n      [FilterAction.UNDO_ALL_ACTIONS]: this.#invisibleEntries.length > 0,\n    };\n    return possibleActions;\n  }\n\n  /**\n   * Returns the amount of entry descendants that belong to the hidden entries array.\n   * */\n  findHiddenDescendantsAmount(entry: Types.TraceEvents.SyntheticTraceEntry): number {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      return 0;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    return allDescendants.filter(descendant => this.invisibleEntries().includes(descendant)).length;\n  }\n\n  /**\n   * Returns the set of entries that are invisible given the set of applied actions.\n   */\n  invisibleEntries(): Types.TraceEvents.TraceEventData[] {\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Sets hidden and expandable. Called when a trace with modifications is loaded and some entries are set as hidden and expandable.\n   * Both arrays are set together because if there is one, the other must be present too.\n   */\n  setHiddenAndExpandableEntries(\n      invisibleEntries: Types.TraceEvents.TraceEventData[],\n      expandableEntries: Types.TraceEvents.TraceEventData[]): void {\n    this.#invisibleEntries.push(...invisibleEntries);\n    this.#expandableEntries.push(...expandableEntries);\n  }\n\n  inEntryInvisible(entry: Types.TraceEvents.TraceEventData): boolean {\n    return this.#invisibleEntries.includes(entry);\n  }\n\n  /**\n   * Returns the array of entries that have a sign indicating that entries below are hidden,\n   * and so that they can be \"expanded\" to reveal their hidden children.\n   */\n  expandableEntries(): Types.TraceEvents.TraceEventData[] {\n    return this.#expandableEntries;\n  }\n\n  /**\n   * Applies an action to hide entries or removes entries\n   * from hidden entries array depending on the action.\n   */\n  applyFilterAction(action: UserFilterAction): Types.TraceEvents.TraceEventData[] {\n    // We apply new user action to the set of all entries, and mark\n    // any that should be hidden by adding them to this set.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set and return it as an array at the end.\n    const entriesToHide = new Set<Types.TraceEvents.TraceEventData>();\n\n    switch (action.type) {\n      case FilterAction.MERGE_FUNCTION: {\n        // The entry that was clicked on is merged into its parent. All its\n        // children remain visible, so we just have to hide the entry that was\n        // selected.\n        entriesToHide.add(action.entry);\n        // If parent node exists, add it to expandableEntries, so it would be possible to uncollapse its children.\n        const actionNode = this.#entryToNode.get(action.entry) || null;\n        const parentNode = actionNode && this.#findNextVisibleParent(actionNode);\n        if (parentNode) {\n          this.#addExpandableEntry(parentNode.entry);\n        }\n        break;\n      }\n      case FilterAction.COLLAPSE_FUNCTION: {\n        // The entry itself remains visible, but all of its descendants are hidden.\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n        allDescendants.forEach(descendant => entriesToHide.add(descendant));\n        this.#addExpandableEntry(action.entry);\n        break;\n      }\n      case FilterAction.COLLAPSE_REPEATING_DESCENDANTS: {\n        const entryNode = this.#entryToNode.get(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n        allRepeatingDescendants.forEach(descendant => entriesToHide.add(descendant));\n        if (entriesToHide.size > 0) {\n          this.#addExpandableEntry(action.entry);\n        }\n        break;\n      }\n      case FilterAction.UNDO_ALL_ACTIONS: {\n        this.#invisibleEntries = [];\n        this.#expandableEntries = [];\n        break;\n      }\n      case FilterAction.RESET_CHILDREN: {\n        this.#makeEntryChildrenVisible(action.entry);\n        break;\n      }\n      default:\n        Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);\n    }\n\n    this.#invisibleEntries.push(...entriesToHide);\n\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Add an entry to the array of entries that have a sign indicating that entries below are hidden.\n   * Also, remove all of the child entries of the new expandable entry from the expandable array. Do that because\n   * to draw the initiator from the closest visible entry, we need to get the closest entry that is\n   * marked as expandable and we do not want to get some that are hidden.\n   */\n  #addExpandableEntry(entry: Types.TraceEvents.TraceEventData): void {\n    this.#expandableEntries.push(entry);\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    if (allDescendants.length > 0) {\n      this.#expandableEntries = this.#expandableEntries.filter(entry => {\n        return !allDescendants.includes(entry);\n      });\n    }\n  }\n\n  // The direct parent might be hidden by other actions, therefore we look for the next visible parent.\n  #findNextVisibleParent(node: Helpers.TreeHelpers.TraceEntryNode): Helpers.TreeHelpers.TraceEntryNode|null {\n    let parent = node.parent;\n    while (parent && this.#invisibleEntries.includes(parent.entry)) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  #findAllDescendantsOfNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEventData[] {\n    const cachedDescendants = this.#entryToDescendantsMap.get(root);\n    if (cachedDescendants) {\n      return cachedDescendants;\n    }\n\n    const descendants: Types.TraceEvents.TraceEventData[] = [];\n\n    // Walk through all the descendants, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        descendants.push(childNode.entry);\n        const childNodeCachedDescendants = this.#entryToDescendantsMap.get(childNode);\n        // If the descendants of a child are cached, get them from the cache instead of iterating through them again\n        if (childNodeCachedDescendants) {\n          descendants.push(...childNodeCachedDescendants);\n        } else {\n          children.push(...childNode.children);\n        }\n      }\n    }\n\n    this.#entryToDescendantsMap.set(root, descendants);\n    return descendants;\n  }\n\n  #findAllRepeatingDescendantsOfNext(root: Helpers.TreeHelpers.TraceEntryNode):\n      Types.TraceEvents.SyntheticTraceEntry[] {\n    // Walk through all the ancestors, starting at the root node.\n    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    const repeatingNodes: Types.TraceEvents.SyntheticTraceEntry[] = [];\n    const rootIsProfileCall = Types.TraceEvents.isProfileCall(root.entry);\n\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        const childIsProfileCall = Types.TraceEvents.isProfileCall(childNode.entry);\n        if (/* Handle SyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {\n          const rootNodeEntry = root.entry as Types.TraceEvents.SyntheticProfileCall;\n          const childNodeEntry = childNode.entry as Types.TraceEvents.SyntheticProfileCall;\n\n          if (Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(\n                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {\n            repeatingNodes.push(childNode.entry);\n          }\n        } /* Handle SyntheticRendererEvents */ else if (!rootIsProfileCall && !childIsProfileCall) {\n          if (root.entry.name === childNode.entry.name) {\n            repeatingNodes.push(childNode.entry);\n          }\n        }\n        children.push(...childNode.children);\n      }\n    }\n\n    return repeatingNodes;\n  }\n\n  /**\n   * If an entry was selected from a link instead of clicking on it,\n   * it might be in the invisible entries array.\n   * If it is, reveal it by resetting clidren the closest expandable entry,\n   */\n  revealEntry(entry: Types.TraceEvents.SyntheticTraceEntry): void {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    let closestExpandableParent = entryNode;\n    while (closestExpandableParent.parent && !this.#expandableEntries.includes(closestExpandableParent.entry)) {\n      closestExpandableParent = closestExpandableParent.parent;\n    }\n    this.#makeEntryChildrenVisible(closestExpandableParent.entry);\n  }\n\n  /**\n   * Removes all of the entry children from the\n   * invisible entries array to make them visible.\n   */\n  #makeEntryChildrenVisible(entry: Types.TraceEvents.SyntheticTraceEntry): void {\n    const entryNode = this.#entryToNode.get(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const descendants = this.#findAllDescendantsOfNode(entryNode);\n\n    /**\n     * Filter out all descendant of the node\n     * from the invisible entries list.\n     */\n    this.#invisibleEntries = this.#invisibleEntries.filter(entry => {\n      if (descendants.includes(entry)) {\n        return false;\n      }\n      return true;\n    });\n\n    /**\n     * Filter out all descentants and entry from expandable entries\n     * list to not show that some entries below those are hidden.\n     */\n    this.#expandableEntries = this.#expandableEntries.filter(iterEntry => {\n      if (descendants.includes(iterEntry) || iterEntry === entry) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  isEntryExpandable(event: Types.TraceEvents.TraceEventData): boolean {\n    return this.#expandableEntries.includes(event);\n  }\n}\n"]}