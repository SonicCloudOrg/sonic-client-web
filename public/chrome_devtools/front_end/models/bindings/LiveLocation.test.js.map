{"version":3,"file":"LiveLocation.test.js","sourceRoot":"","sources":["../../../../../../front_end/models/bindings/LiveLocation.test.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,QAAQ,MAAM,eAAe,CAAC;AAE1C,MAAM,gBAAgB,GAAG,QAAQ,CAAC,YAAY,CAAC,gBAAgB,CAAC;AAChE,MAAM,oBAAoB,GAAG,QAAQ,CAAC,YAAY,CAAC,oBAAoB,CAAC;AAExE,QAAQ,CAAC,cAAc,EAAE,GAAG,EAAE;IAC5B,EAAE,CAAC,6BAA6B,EAAE,KAAK,IAAI,EAAE;QAC3C,MAAM,IAAI,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAEpC,+EAA+E;QAC/E,iDAAiD;QACjD,oCAAoC;QACpC,+BAA+B;QAC/B,8DAA8D;QAC9D,IAAI,sBAAsB,GAAG,CAAC,CAAU,EAAE,EAAE,GAAE,CAAC,CAAC;QAChD,MAAM,eAAe,GAAG,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YAC5C,sBAAsB,GAAG,OAAO,CAAC;QACnC,CAAC,CAAC,CAAC;QAEH,MAAM,iBAAiB,GAAa,EAAE,CAAC;QACvC,MAAM,YAAY,GAAG,IAAI,oBAAoB,CAAC,KAAK,IAAI,EAAE;YACvD,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAChC,MAAM,eAAe,CAAC;YACtB,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC,EAAE,IAAI,CAAC,CAAC;QAET,KAAK,YAAY,CAAC,MAAM,EAAE,CAAC;QAC3B,KAAK,YAAY,CAAC,MAAM,EAAE,CAAC;QAC3B,sBAAsB,CAAC,SAAS,CAAC,CAAC;QAClC,MAAM,YAAY,CAAC,MAAM,EAAE,CAAC;QAE5B,MAAM,CAAC,SAAS,CAAC,iBAAiB,EAAE,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;IAC3F,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,uDAAuD,EAAE,GAAG,EAAE;QAC/D,MAAM,IAAI,GAAG,IAAI,gBAAgB,EAAE,CAAC;QACpC,MAAM,YAAY,GAAG,IAAI,oBAAoB,CAAC,KAAK,IAAI,EAAE,GAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAEpE,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;QAC1C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;IAC3C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Bindings from './bindings.js';\n\nconst LiveLocationPool = Bindings.LiveLocation.LiveLocationPool;\nconst LiveLocationWithPool = Bindings.LiveLocation.LiveLocationWithPool;\n\ndescribe('LiveLocation', () => {\n  it('executes updates atomically', async () => {\n    const pool = new LiveLocationPool();\n\n    // Create a promise that our async update is blocked on. The test then becomes:\n    //   1. schedule two updates to the live location\n    //   2. resolve the blocking promise\n    //   3. schedule a third update\n    //   4. check that all actions were still executed atomically.\n    let fulfillBlockingPromise = (_: unknown) => {};\n    const blockingPromise = new Promise(fulfill => {\n      fulfillBlockingPromise = fulfill;\n    });\n\n    const updateDelegateLog: string[] = [];\n    const liveLocation = new LiveLocationWithPool(async () => {\n      updateDelegateLog.push('enter');\n      await blockingPromise;\n      updateDelegateLog.push('exit');\n    }, pool);\n\n    void liveLocation.update();\n    void liveLocation.update();\n    fulfillBlockingPromise(undefined);\n    await liveLocation.update();\n\n    assert.deepEqual(updateDelegateLog, ['enter', 'exit', 'enter', 'exit', 'enter', 'exit']);\n  });\n\n  it('isDisposed returns true after locationPool.disposeAll', () => {\n    const pool = new LiveLocationPool();\n    const liveLocation = new LiveLocationWithPool(async () => {}, pool);\n\n    assert.isFalse(liveLocation.isDisposed());\n    pool.disposeAll();\n    assert.isTrue(liveLocation.isDisposed());\n  });\n});\n"]}