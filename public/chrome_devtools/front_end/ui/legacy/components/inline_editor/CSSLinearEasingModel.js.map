{"version":3,"file":"CSSLinearEasingModel.js","sourceRoot":"","sources":["../../../../../../../../front_end/ui/legacy/components/inline_editor/CSSLinearEasingModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as CodeMirror from '../../../../third_party/codemirror.next/codemirror.next.js';\n\nconst cssParser = CodeMirror.css.cssLanguage.parser;\n\nexport type Point = {\n  input: number,\n  output: number,\n};\n\ntype LinearStop = {\n  number: number,\n  lengthA?: number,\n  lengthB?: number,\n};\n\nconst numberFormatter = new Intl.NumberFormat('en', {\n  maximumFractionDigits: 2,\n});\n\nfunction findNextDefinedInputIndex(points: Point[], currentIndex: number): number {\n  for (let i = currentIndex; i < points.length; i++) {\n    if (!isNaN(points[i].input)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction consumeLinearStop(cursor: CodeMirror.TreeCursor, referenceText: string): LinearStop|null {\n  const tokens = [];\n  while (cursor.type.name !== ',' && cursor.type.name !== ')') {\n    const token = referenceText.substring(cursor.from, cursor.to);\n    if (cursor.type.name !== 'NumberLiteral') {\n      // There is something that is not a number inside the argument.\n      return null;\n    }\n\n    tokens.push(token);\n    cursor.next(false);\n  }\n\n  // Invalid syntax `linear(0 50% 60% 40%, 1)`.\n  if (tokens.length > 3) {\n    return null;\n  }\n\n  const percentages = tokens.filter(token => token.includes('%'));\n  // There can't be more than 2 percentages.\n  if (percentages.length > 2) {\n    return null;\n  }\n\n  const numbers = tokens.filter(token => !token.includes('%'));\n  // There must only be 1 number.\n  if (numbers.length !== 1) {\n    return null;\n  }\n\n  return {\n    number: Number(numbers[0]),\n    lengthA: percentages[0] ? Number(percentages[0].substring(0, percentages[0].length - 1)) : undefined,\n    lengthB: percentages[1] ? Number(percentages[1].substring(0, percentages[1].length - 1)) : undefined,\n  };\n}\n\nfunction consumeLinearFunction(text: string): LinearStop[]|null {\n  const textToParse = `*{--a: ${text}}`;\n  const parsed = cssParser.parse(textToParse);\n  // Take the cursor from declaration\n  const cursor = parsed.cursorAt(textToParse.indexOf(':') + 1);\n\n  // Move until the `ArgList`\n  while (cursor.name !== 'ArgList' && cursor.next(true)) {\n    // If the callee is not the `linear` function, return null\n    if (cursor.name === 'Callee' && textToParse.substring(cursor.from, cursor.to) !== 'linear') {\n      return null;\n    }\n  }\n\n  if (cursor.name !== 'ArgList') {\n    return null;\n  }\n\n  // We're on the `ArgList`, enter into it\n  cursor.firstChild();\n  const stops = [];\n  while (cursor.type.name !== ')' && cursor.next(false)) {\n    const linearStop = consumeLinearStop(cursor, textToParse);\n    if (!linearStop) {\n      // Parsing a `linearStop` was invalid; abort.\n      return null;\n    }\n\n    stops.push(linearStop);\n  }\n  return stops;\n}\n\nconst KeywordToValue: Record<string, string> = {\n  'linear': 'linear(0 0%, 1 100%)',\n};\n\nexport class CSSLinearEasingModel {\n  #points: Point[];\n\n  constructor(points: Point[]) {\n    this.#points = points;\n  }\n\n  // https://w3c.github.io/csswg-drafts/css-easing/#linear-easing-function-parsing\n  static parse(text: string): CSSLinearEasingModel|null {\n    // Parse `linear` keyword as `linear(0 0%, 1 100%)` function.\n    if (KeywordToValue[text]) {\n      return CSSLinearEasingModel.parse(KeywordToValue[text]);\n    }\n\n    const stops = consumeLinearFunction(text);\n    // 1. Let function be a new linear easing function.\n    // 2. Let largestInput be negative infinity.\n    // 3. If there are less than two items in stopList, then return failure.\n    if (!stops || stops.length < 2) {\n      return null;\n    }\n\n    // 4. For each stop in stopList:\n    let largestInput = -Infinity;\n    const points: Point[] = [];\n    for (let i = 0; i < stops.length; i++) {\n      const stop = stops[i];\n      // 4.1. Let point be a new linear easing point with its output set\n      // to stop’s <number> as a number.\n      const point: Point = {input: NaN, output: stop.number};\n      // 4.2. Append point to function’s points.\n      points.push(point);\n\n      // 4.3. If stop has a <linear-stop-length>, then:\n      if (stop.lengthA !== undefined) {\n        // 4.3.1. Set point’s input to whichever is greater:\n        // stop’s <linear-stop-length>'s first <percentage> as a number,\n        // or largestInput.\n        point.input = Math.max(stop.lengthA, largestInput);\n        // 4.3.2. Set largestInput to point’s input.\n        largestInput = point.input;\n\n        // 4.3.3. If stop’s <linear-stop-length> has a second <percentage>, then:\n        if (stop.lengthB !== undefined) {\n          // 4.3.3.1. Let extraPoint be a new linear easing point with its output\n          // set to stop’s <number> as a number.\n          const extraPoint: Point = {input: NaN, output: point.output};\n          // 4.3.3.2. Append extraPoint to function’s points.\n          points.push(extraPoint);\n          // 4.3.3.3. Set extraPoint’s input to whichever is greater:\n          // stop’s <linear-stop-length>'s second <percentage>\n          // as a number, or largestInput.\n          extraPoint.input = Math.max(stop.lengthB, largestInput);\n          // 4.3.3.4. Set largestInput to extraPoint’s input.\n          largestInput = extraPoint.input;\n        }\n        // 4.4. Otherwise, if stop is the first item in stopList, then:\n      } else if (i === 0) {\n        // 4.4.1. Set point’s input to 0.\n        point.input = 0;\n        // 4.4.2. Set largestInput to 0.\n        largestInput = 0;\n        // 4.5. Otherwise, if stop is the last item in stopList,\n        // then set point’s input to whichever is greater: 1 or largestInput.\n      } else if (i === stops.length - 1) {\n        point.input = Math.max(100, largestInput);\n      }\n    }\n\n    // 5. For runs of items in function’s points that have a null input, assign a\n    // number to the input by linearly interpolating between the closest previous\n    // and next points that have a non-null input.\n    let upperIndex = 0;\n    for (let i = 1; i < points.length; i++) {\n      if (isNaN(points[i].input)) {\n        if (i > upperIndex) {\n          // Since the last point's input is always defined\n          // we know that `upperIndex` cannot be `-1`.\n          upperIndex = findNextDefinedInputIndex(points, i);\n        }\n\n        points[i].input =\n            points[i - 1].input + (points[upperIndex].input - points[i - 1].input) / (upperIndex - (i - 1));\n      }\n    }\n\n    return new CSSLinearEasingModel(points);\n  }\n\n  addPoint(point: Point, index?: number): void {\n    if (index !== undefined) {\n      this.#points.splice(index, 0, point);\n      return;\n    }\n\n    this.#points.push(point);\n  }\n\n  removePoint(index: number): void {\n    this.#points.splice(index, 1);\n  }\n\n  setPoint(index: number, point: Point): void {\n    this.#points[index] = point;\n  }\n\n  points(): Point[] {\n    return this.#points;\n  }\n\n  asCSSText(): string {\n    const args =\n        this.#points.map(point => `${numberFormatter.format(point.output)} ${numberFormatter.format(point.input)}%`)\n            .join(', ');\n    const text = `linear(${args})`;\n\n    // If a keyword matches to this function, return the keyword value of it.\n    for (const [keyword, value] of Object.entries(KeywordToValue)) {\n      if (value === text) {\n        return keyword;\n      }\n    }\n\n    return text;\n  }\n}\n"]}