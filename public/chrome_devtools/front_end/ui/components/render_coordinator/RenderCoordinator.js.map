{"version":3,"file":"RenderCoordinator.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/render_coordinator/RenderCoordinator.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,QAAQ,MAAM,oCAAoC,CAAC;AAoB/D,MAAM,QAAQ;IACH,OAAO,CAAa;IACpB,OAAO,CAAa;IACpB,MAAM,CAAqB;IAC3B,KAAK,CAAS;IACvB,QAAQ,CAAyB;IAEjC,YAAY,KAAa,EAAE,cAAsC;QAC/D,MAAM,EAAC,OAAO,EAAE,OAAO,EAAE,MAAM,EAAC,GAAG,QAAQ,CAAC,gBAAgB,CAAC,oBAAoB,EAAQ,CAAC;QAC1F,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QACnD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC;IACjC,CAAC;IAED,IAAI,OAAO,CAAC,UAAkC;QAC5C,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC;IAC7B,CAAC;CACF;AAYD,MAAM,OAAO,gCAAiC,SAAQ,KAAK;IACzD,MAAM,CAAU,SAAS,GAAG,kBAAkB,CAAC;IAC/C;QACE,KAAK,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;IACpD,CAAC;;AAGH,MAAM,OAAO,8BAA+B,SAAQ,KAAK;IACvD,MAAM,CAAU,SAAS,GAAG,UAAU,CAAC;IACvC;QACE,KAAK,CAAC,8BAA8B,CAAC,SAAS,CAAC,CAAC;IAClD,CAAC;;AAGH,IAAI,yBAA4C,CAAC;AAEjD,MAAM,YAAY,GAAG,cAAc,CAAC;AACpC,MAAM,aAAa,GAAG,eAAe,CAAC;AACtC,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,gBAAgB,GAAG,IAAI,CAAC;AAE9B,8DAA8D;AAC7D,UAAkB,CAAC,mCAAmC,GAAG;IACxD,OAAO,iBAAiB,CAAC,kBAAkB,EAAE,CAAC;AAChD,CAAC,CAAC;AAEF,MAAM,OAAO,iBAAkB,SAAQ,WAAW;IAChD,MAAM,CAAC,QAAQ,CAAC,EAAC,QAAQ,GAAG,KAAK,EAAC,GAAG,EAAE;QACrC,IAAI,CAAC,yBAAyB,IAAI,QAAQ,EAAE,CAAC;YAC3C,yBAAyB,GAAG,IAAI,iBAAiB,EAAE,CAAC;QACtD,CAAC;QAED,OAAO,yBAAyB,CAAC;IACnC,CAAC;IAED,MAAM,CAAC,kBAAkB;QACvB,IAAI,CAAC,yBAAyB,EAAE,CAAC;YAC/B,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC3D,CAAC;QAED,OAAO,yBAAyB,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,8DAA8D;IAC9D,+EAA+E;IAC/E,OAAO,GAAG,KAAK,CAAC;IAChB,kBAAkB,GAAG,GAAG,CAAC;IAEzB,qDAAqD;IACrD,6DAA6D;IAC7D,gBAAgB,GAAG,IAAI,CAAC;IAEf,YAAY,GAA0B,EAAE,CAAC;IAElD,eAAe,GAAwB,EAAE,CAAC;IAC1C,eAAe,GAAwB,EAAE,CAAC;IAC1C,gBAAgB,GAAG,CAAC,CAAC;IAErB,cAAc;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,CAAC;IAChF,CAAC;IAED,IAAI,CAAC,OAAgC;QACnC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE,CAAC;YACpD,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;YACpC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;QACD,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,EAAE,EAAC,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC;IAC1G,CAAC;IASD,KAAK,CAAC,IAAI,CAAI,eAA8C,EAAE,QAAiC;QAC7F,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE,CAAC;YACxC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACd,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;YAC5D,CAAC;YACD,OAAO,IAAI,CAAC,eAAe,CAAC,QAAQ,4BAAe,eAAe,CAAC,CAAC;QACtE,CAAC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,eAAe,4BAAe,YAAY,CAAC,CAAC;IAC1E,CAAC;IAQD,KAAK,CAAC,KAAK,CAAI,eAA8C,EAAE,QAAiC;QAC9F,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE,CAAC;YACxC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACd,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;YAC7D,CAAC;YACD,OAAO,IAAI,CAAC,eAAe,CAAC,QAAQ,8BAAgB,eAAe,CAAC,CAAC;QACvE,CAAC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,eAAe,8BAAgB,aAAa,CAAC,CAAC;IAC5E,CAAC;IAED,WAAW;QACT,MAAM,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;QACpC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7B,OAAO,IAAI,CAAC;IACd,CAAC;IAYD,KAAK,CAAC,MAAM,CAAI,eAA8C,EAAE,QAAiC;QAC/F,IAAI,OAAO,eAAe,KAAK,QAAQ,EAAE,CAAC;YACxC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACd,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;YAC9D,CAAC;YACD,OAAO,IAAI,CAAC,eAAe,CAAC,QAAQ,4BAAe,eAAe,CAAC,CAAC;QACtE,CAAC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,eAAe,4BAAe,cAAc,CAAC,CAAC;IAC5E,CAAC;IAED,eAAe,CAAI,QAAgC,EAAE,MAAc,EAAE,KAAa;QAChF,MAAM,OAAO,GAAG,CAAC,CAAC,YAAY,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC/E,KAAK,GAAG,GAAG,MAAM,6BAAgB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,KAAK,EAAE,CAAC;QAErE,IAAI,SAAS,GAAG,IAAI,CAAC;QACrB,QAAQ,MAAM,EAAE,CAAC;YACf;gBACE,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC;gBACjC,MAAM;YAER;gBACE,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC;gBACjC,MAAM;YAER;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,MAAM,EAAE,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAA2B,CAAC,CAAC,CAAC,SAAS,CAAC;QACtG,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,QAAQ,GAAG,IAAI,QAAQ,CAAI,KAAK,EAAE,QAAQ,CAAC,CAAC;YAC5C,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;aAAM,CAAC;YACN,yEAAyE;YACzE,yFAAyF;YACzF,2CAA2C;YAC3C,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC;QAC9B,CAAC;QAED,IAAI,CAAC,aAAa,EAAE,CAAC;QACrB,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC1B,CAAC;IAED,aAAa;QACX,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,KAAK,CAAC,CAAC;QACrD,IAAI,gBAAgB,EAAE,CAAC;YACrB,OAAO;QACT,CAAC;QAED,IAAI,CAAC,gBAAgB,GAAG,qBAAqB,CAAC,KAAK,IAAI,EAAE;YACvD,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC;gBAC3B,kCAAkC;gBAClC,+DAA+D;gBAC/D,6DAA6D;gBAC7D,gEAAgE;gBAChE,oEAAoE;gBACpE,IAAI,CAAC,aAAa,CAAC,IAAI,gCAAgC,EAAE,CAAC,CAAC;gBAC3D,MAAM,CAAC,aAAa,CAAC,IAAI,gCAAgC,EAAE,CAAC,CAAC;gBAE7D,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;gBACpC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;gBAC1B,OAAO;YACT,CAAC;YAED,IAAI,CAAC,aAAa,CAAC,IAAI,8BAA8B,EAAE,CAAC,CAAC;YACzD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;YAElC,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;YACrC,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;YAC1B,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;YACrC,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;YAE1B,4CAA4C;YAC5C,uBAAuB;YACvB,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;gBAC7B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,CAAC;YAED,gCAAgC;YAChC,IAAI,CAAC;gBACH,MAAM,OAAO,CAAC,IAAI,CAAC;oBACjB,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;oBACxC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;wBACxB,MAAM,CAAC,UAAU,CACb,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,qBAAqB,gBAAgB,wBAAwB,CAAC,CAAC,EACtF,gBAAgB,CAAC,CAAC;oBACxB,CAAC,CAAC;iBACH,CAAC,CAAC;YACL,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YAChC,CAAC;YAED,sCAAsC;YACtC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;gBAC7B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,CAAC;YAED,qCAAqC;YACrC,IAAI,CAAC;gBACH,MAAM,OAAO,CAAC,IAAI,CAAC;oBACjB,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;oBACxC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE;wBACxB,MAAM,CAAC,UAAU,CACb,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,qBAAqB,gBAAgB,wBAAwB,CAAC,CAAC,EACtF,gBAAgB,CAAC,CAAC;oBACxB,CAAC,CAAC;iBACH,CAAC,CAAC;YACL,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YAChC,CAAC;YAED,mDAAmD;YACnD,4DAA4D;YAC5D,oBAAoB;YACpB,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;YAC1B,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,UAAU,CAAC,QAA6B,EAAE,KAAY;QACpD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC/B,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACxB,CAAC;IACH,CAAC;IAED,aAAa;QACX,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;QAC1B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;QAC7C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED,aAAa,CAAC,KAAuB;QACnC,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;YAC5B,OAAO;QACT,CAAC;QACD,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QAClH,IAAI,SAAS,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvC,OAAO;QACT,CAAC;QAED,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,WAAW,CAAC,GAAG,EAAE,EAAE,KAAK,EAAC,CAAC,CAAC;QAEzD,gCAAgC;QAChC,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1D,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback<T> {\n  (): T|PromiseLike<T>;\n}\n\nclass WorkItem<T> {\n  readonly promise: Promise<T>;\n  readonly trigger: () => void;\n  readonly cancel: (e: Error) => void;\n  readonly label: string;\n  #handler: CoordinatorCallback<T>;\n\n  constructor(label: string, initialHandler: CoordinatorCallback<T>) {\n    const {promise, resolve, reject} = Platform.PromiseUtilities.promiseWithResolvers<void>();\n    this.promise = promise.then(() => this.#handler());\n    this.trigger = resolve;\n    this.cancel = reject;\n    this.label = label;\n    this.#handler = initialHandler;\n  }\n\n  set handler(newHandler: CoordinatorCallback<T>) {\n    this.#handler = newHandler;\n  }\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return RenderCoordinator.pendingFramesCount();\n};\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  static pendingFramesCount(): number {\n    if (!renderCoordinatorInstance) {\n      throw new Error('No render coordinator instance found.');\n    }\n\n    return renderCoordinatorInstance.hasPendingWork() ? 1 : 0;\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  readonly #logInternal: CoordinatorLogEntry[] = [];\n\n  #pendingReaders: WorkItem<unknown>[] = [];\n  #pendingWriters: WorkItem<unknown>[] = [];\n  #scheduledWorkId = 0;\n\n  hasPendingWork(): boolean {\n    return this.#pendingReaders.length !== 0 || this.#pendingWriters.length !== 0;\n  }\n\n  done(options?: {waitForWork: boolean}): Promise<void> {\n    if (!this.hasPendingWork() && !options?.waitForWork) {\n      this.#logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  // Schedules a 'read' job which is being executed within an animation frame\n  // before all 'write' jobs. If multiple jobs are scheduled with the same\n  // non-empty label, only the latest callback would be executed. Such\n  // invocations would return the same promise that will resolve to the value of\n  // the latest callback.\n  async read<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async read<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async read<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.#enqueueHandler(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler(labelOrCallback, ACTION.READ, UNNAMED_READ);\n  }\n\n  // Schedules a 'write' job which is being executed within an animation frame\n  // after all 'read' and 'scroll' jobs. If multiple jobs are scheduled with\n  // the same non-empty label, only the latest callback would be executed. Such\n  // invocations would return the same promise that will resolve when the latest callback is run.\n  async write<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async write<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async write<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.#enqueueHandler(callback, ACTION.WRITE, labelOrCallback);\n    }\n\n    return this.#enqueueHandler(labelOrCallback, ACTION.WRITE, UNNAMED_WRITE);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.#logInternal];\n    this.#logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.  If multiple jobs are scheduled with the same non-empty label, only\n   * the latest callback would be executed. Such invocations would return the same promise that\n   * will resolve when the latest callback is run.\n   */\n  async scroll<T>(callback: CoordinatorCallback<T>): Promise<T>;\n  async scroll<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\n  async scroll<T>(labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.#enqueueHandler(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler(labelOrCallback, ACTION.READ, UNNAMED_SCROLL);\n  }\n\n  #enqueueHandler<T>(callback: CoordinatorCallback<T>, action: ACTION, label: string): Promise<T> {\n    const hasName = ![UNNAMED_READ, UNNAMED_WRITE, UNNAMED_SCROLL].includes(label);\n    label = `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`;\n\n    let workItems = null;\n    switch (action) {\n      case ACTION.READ:\n        workItems = this.#pendingReaders;\n        break;\n\n      case ACTION.WRITE:\n        workItems = this.#pendingWriters;\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    let workItem = hasName ? workItems.find(w => w.label === label) as WorkItem<T>| undefined : undefined;\n    if (!workItem) {\n      workItem = new WorkItem<T>(label, callback);\n      workItems.push(workItem);\n    } else {\n      // We are always using the latest handler, so that we don't end up with a\n      // stale results. We are reusing the promise to avoid blocking the first invocation, when\n      // it is being \"overridden\" by another one.\n      workItem.handler = callback;\n    }\n\n    this.#scheduleWork();\n    return workItem.promise;\n  }\n\n  #scheduleWork(): void {\n    const hasScheduledWork = this.#scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.#scheduledWorkId = requestAnimationFrame(async () => {\n      if (!this.hasPendingWork()) {\n        // All pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.#logIfEnabled('[Queue empty]');\n        this.#scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.#logIfEnabled('[New frame]');\n\n      const readers = this.#pendingReaders;\n      this.#pendingReaders = [];\n      const writers = this.#pendingWriters;\n      this.#pendingWriters = [];\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      for (const reader of readers) {\n        this.#logIfEnabled(reader.label);\n        reader.trigger();\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(readers.map(r => r.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(readers, err);\n      }\n\n      // Next do all the writers as a block.\n      for (const writer of writers) {\n        this.#logIfEnabled(writer.label);\n        writer.trigger();\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(writers.map(w => w.promise)),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.#scheduledWorkId = 0;\n      this.#scheduleWork();\n    });\n  }\n\n  #rejectAll(handlers: WorkItem<unknown>[], error: Error): void {\n    for (const handler of handlers) {\n      handler.cancel(error);\n    }\n  }\n\n  cancelPending(): void {\n    const error = new Error();\n    this.#rejectAll(this.#pendingReaders, error);\n    this.#rejectAll(this.#pendingWriters, error);\n  }\n\n  #logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.#logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.#logInternal.length > this.recordStorageLimit) {\n      this.#logInternal.shift();\n    }\n  }\n}\n"]}