{"version":3,"file":"DataGridControllerIntegrator.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/data_grid/DataGridControllerIntegrator.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,gCAAgC,CAAC;AACzD,OAAO,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAE7C,OAAO,EAAC,kBAAkB,EAA8B,MAAM,yBAAyB,CAAC;AAExF,MAAM,OAAO,4BAA6B,SAAQ,EAAE,CAAC,MAAM,CAAC,IAAI;IACrD,QAAQ,CAAqB;IAC7B,gBAAgB,CAA6B;IACtD,qEAAqE;IACrE,oFAAoF;IACpF,+EAA+E;IAC/E,2BAA2B;IAC3B,KAAK,CAAyB;IAE9B,YAAY,IAA4B;QACtC;;;;;WAKG;QACH,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAElB,IAAI,CAAC,QAAQ,GAAG,IAAI,kBAAkB,EAAE,CAAC;QACzC,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC/C,IAAI,CAAC,gBAAgB,GAAG,IAAI,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,MAAM,CAAC,IAAsC;QAC3C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,6DAA6D;QAC7D,+DAA+D;QAC/D,KAAK,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE;YAC7C,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC;QAC5B,CAAC,CAAC,CAAC;IACL,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport {DataGridController, type DataGridControllerData} from './DataGridController.js';\n\nexport class DataGridControllerIntegrator extends UI.Widget.VBox {\n  readonly dataGrid: DataGridController;\n  readonly #updateThrottler: Common.Throttler.Throttler;\n  // The `data` here mirrors the data of the DataGridController because\n  // the users of this class expects the `data` to be up to date after `update` calls.\n  // However, the `update` calls below are debounced for setting `dataGrid`s data\n  // for performance reasons.\n  #data: DataGridControllerData;\n\n  constructor(data: DataGridControllerData) {\n    /**\n     * first true = isWebComponent and tells the widget system it's rendering a\n     * component\n     * second true = delegatesFocus, which tells the widget system to\n     * let the component deal with its own focusing.\n     */\n    super(true, true);\n\n    this.dataGrid = new DataGridController();\n    this.dataGrid.data = data;\n    this.#data = data;\n    this.contentElement.appendChild(this.dataGrid);\n    this.#updateThrottler = new Common.Throttler.Throttler(0);\n  }\n\n  data(): Readonly<DataGridControllerData> {\n    return this.#data;\n  }\n\n  update(data: Readonly<DataGridControllerData>): void {\n    this.#data = data;\n    // Setting of `dataGrid.data` is compute heavy because of the\n    // filtering logic. Thus, we're debouncing calls to the setter.\n    void this.#updateThrottler.schedule(async () => {\n      this.dataGrid.data = data;\n    });\n  }\n}\n"]}