{"version":3,"file":"scheduled-render.js","sourceRoot":"","sources":["../../../../../../../front_end/ui/components/helpers/scheduled-render.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAC7B,OAAO,KAAK,WAAW,MAAM,6CAA6C,CAAC;AAE3E,MAAM,WAAW,GAAG,WAAW,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,CAAC;AAC/E,MAAM,cAAc,GAAG,IAAI,OAAO,EAAe,CAAC;AAClD,MAAM,aAAa,GAAG,IAAI,OAAO,EAAe,CAAC;AACjD,MAAM,gBAAgB,GAAG,IAAI,OAAO,EAA2B,CAAC;AAChE,MAAM,gBAAgB,GAAG,IAAI,OAAO,EAA0B,CAAC;AAC/D,MAAM,CAAC,KAAK,UAAU,cAAc,CAAC,SAAsB,EAAE,QAAoB;IAC/E,gFAAgF;IAChF,2EAA2E;IAC3E,qBAAqB;IACrB,IAAI,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;QACjC,gBAAgB,CAAC,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;QAC1C,OAAO;IACT,CAAC;IAED,4EAA4E;IAC5E,IAAI,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;QAClC,OAAO;IACT,CAAC;IAED,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAE9B,8EAA8E;IAC9E,mFAAmF;IACnF,IAAI,eAAe,GAAG,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACrD,IAAI,CAAC,eAAe,EAAE,CAAC;QACrB,eAAe,GAAG,KAAK,IAAI,EAAE;YAC3B,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACjC,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YAC7B,IAAI,CAAC;gBACH,MAAM,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACjC,CAAC;YAAC,OAAO,KAAc,EAAE,CAAC;gBACxB,OAAO,CAAC,KAAK,CAAC,8BAA8B,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;gBACjF,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACrB,MAAM,KAAK,CAAC;YACd,CAAC;oBAAS,CAAC;gBACT,aAAa,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YAClC,CAAC;QACH,CAAC,CAAC;QAEF,uEAAuE;QACvE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;IAClD,CAAC;IAED,kFAAkF;IAClF,MAAM,WAAW,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;IAEzC,mEAAmE;IACnE,8CAA8C;IAC9C,IAAI,gBAAgB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;QACpC,MAAM,WAAW,GAAG,gBAAgB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACpD,gBAAgB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,CAAC,WAAW,EAAE,CAAC;YACjB,OAAO;QACT,CAAC;QAED,KAAK,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IAC9C,CAAC;AACH,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,SAAsB;IACtD,OAAO,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AACtC,CAAC","sourcesContent":["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\nconst pendingRenders = new WeakSet<HTMLElement>();\nconst activeRenders = new WeakSet<HTMLElement>();\nconst subsequentRender = new WeakMap<HTMLElement, () => void>();\nconst wrappedCallbacks = new WeakMap<() => void, () => void>();\nexport async function scheduleRender(component: HTMLElement, callback: () => void): Promise<void> {\n  // If scheduleRender is called when there is already a render scheduled for this\n  // component, store the callback against the renderer for after the current\n  // call has finished.\n  if (activeRenders.has(component)) {\n    subsequentRender.set(component, callback);\n    return;\n  }\n\n  // If this render was already scheduled but hasn't started yet, just return.\n  if (pendingRenders.has(component)) {\n    return;\n  }\n\n  pendingRenders.add(component);\n\n  // Create a wrapper around the callback so that we know that it has moved from\n  // pending to active. When it has completed we remove it from the active renderers.\n  let wrappedCallback = wrappedCallbacks.get(callback);\n  if (!wrappedCallback) {\n    wrappedCallback = async () => {\n      pendingRenders.delete(component);\n      activeRenders.add(component);\n      try {\n        await callback.call(component);\n      } catch (error: unknown) {\n        console.error(`ScheduledRender: rendering ${component.nodeName.toLowerCase()}:`);\n        console.error(error);\n        throw error;\n      } finally {\n        activeRenders.delete(component);\n      }\n    };\n\n    // Store it for next time so we aren't creating wrappers unnecessarily.\n    wrappedCallbacks.set(callback, wrappedCallback);\n  }\n\n  // Track that there is render rendering, wait for it to finish, and stop tracking.\n  await coordinator.write(wrappedCallback);\n\n  // If during the render there was another schedule render call, get\n  // the callback and schedule it to happen now.\n  if (subsequentRender.has(component)) {\n    const newCallback = subsequentRender.get(component);\n    subsequentRender.delete(component);\n    if (!newCallback) {\n      return;\n    }\n\n    void scheduleRender(component, newCallback);\n  }\n}\n\nexport function isScheduledRender(component: HTMLElement): boolean {\n  return activeRenders.has(component);\n}\n"]}