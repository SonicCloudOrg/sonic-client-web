{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Initiators.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TraceEngine from '../../models/trace/trace.js';\n\nexport interface InitiatorData {\n  event: TraceEngine.Types.TraceEvents.TraceEventData;\n  initiator: TraceEngine.Types.TraceEvents.TraceEventData;\n  isEntryHidden?: boolean;\n  isInitiatorHidden?: boolean;\n}\n/**\n * Given an event that the user has selected, this function returns all the\n * data of events and their initiators that need to be drawn on the flamechart.\n * The reason that this can return multiple InitiatorEntry objects is because we draw the\n * entire chain: for each, we see if it had an initiator, and\n * work backwards to draw each one, as well as the events initiated directly by the entry.\n */\nexport function initiatorsDataToDraw(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    hiddenEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    expandableEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    ): readonly InitiatorData[] {\n  const initiatorsData = [\n    ...findInitiatorDataPredecessors(traceEngineData, selectedEvent),\n    ...findInitiatorDataDirectSuccessors(traceEngineData, selectedEvent),\n  ];\n\n  // For each InitiatorData, call a function that makes sure that neither the initirator or initiated entry is hidden.\n  // If they are, it will reassign the event or initiator to the closest ancestor.\n  initiatorsData.forEach(\n      initiatorData =>\n          getClosestVisibleInitiatorEntriesAncestors(initiatorData, expandableEntries, hiddenEntries, traceEngineData));\n  return initiatorsData;\n}\n\nfunction findInitiatorDataPredecessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorData[] {\n  const initiatorsData: InitiatorData[] = [];\n\n  let currentEvent: TraceEngine.Types.TraceEvents.TraceEventData|null = selectedEvent;\n\n  // Build event initiator data up to the selected one\n  while (currentEvent) {\n    const currentInitiator = traceEngineData.Initiators.eventToInitiator.get(currentEvent);\n\n    if (currentInitiator) {\n      // Store the current initiator data, and then set the initiator to\n      // be the current event, so we work back through the\n      // trace and find the initiator of the initiator, and so\n      // on...\n      initiatorsData.push({event: currentEvent, initiator: currentInitiator});\n      currentEvent = currentInitiator;\n      continue;\n    }\n\n    if (!TraceEngine.Types.TraceEvents.isSyntheticTraceEntry(currentEvent)) {\n      // If the current event is not a renderer, we have no\n      // concept of a parent event, so we can bail.\n      currentEvent = null;\n      break;\n    }\n\n    const nodeForCurrentEvent = traceEngineData.Renderer.entryToNode.get(currentEvent);\n    if (!nodeForCurrentEvent) {\n      // Should not happen - if it does something odd is going\n      // on so let's give up.\n      currentEvent = null;\n      break;\n    }\n\n    // Go up to the parent, and loop again.\n    currentEvent = nodeForCurrentEvent.parent?.entry || null;\n  }\n\n  return initiatorsData;\n}\n\nfunction findInitiatorDataDirectSuccessors(\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData,\n    selectedEvent: TraceEngine.Types.TraceEvents.TraceEventData,\n    ): readonly InitiatorData[] {\n  const initiatorsData: InitiatorData[] = [];\n\n  // Add all of the initiated events to the initiatorsData array.\n  const eventsInitiatedByCurrent = traceEngineData.Initiators.initiatorToEvents.get(selectedEvent);\n  if (eventsInitiatedByCurrent) {\n    eventsInitiatedByCurrent.forEach(event => {\n      initiatorsData.push({event: event, initiator: selectedEvent});\n    });\n  }\n\n  return initiatorsData;\n}\n\n/**\n * Given an InitiatorData object that contains an initiator and event, this function returns\n * the closest visible ancestors. We need to apply this to each initiatorData because\n * the actual initiator or initiated event might be hidden form the flame chart.\n * If neither entry is hidden, this function returns the initial initiatorData object.\n */\nfunction getClosestVisibleInitiatorEntriesAncestors(\n    initiatorData: InitiatorData, expandableEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    hiddenEntries: TraceEngine.Types.TraceEvents.TraceEventData[],\n    traceEngineData: TraceEngine.Handlers.Types.TraceParseData): InitiatorData {\n  if (hiddenEntries.includes(initiatorData.event)) {\n    let nextParent = traceEngineData.Renderer.entryToNode.get(initiatorData.event)?.parent;\n    while (nextParent?.entry && !expandableEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    initiatorData.event = nextParent?.entry ?? initiatorData.event;\n    initiatorData.isEntryHidden = true;\n  }\n\n  if (hiddenEntries.includes(initiatorData.initiator)) {\n    let nextParent = traceEngineData.Renderer.entryToNode.get(initiatorData.initiator)?.parent;\n    while (nextParent?.entry && !expandableEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    initiatorData.initiator = nextParent?.entry ?? initiatorData.initiator;\n    initiatorData.isInitiatorHidden = true;\n  }\n\n  return initiatorData;\n}\n"]}