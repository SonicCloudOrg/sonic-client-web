{"version":3,"file":"TimelineLoader.test.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/TimelineLoader.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\nimport type * as TimelineModel from '../../models/timeline_model/timeline_model.js';\nimport type * as TraceEngine from '../../models/trace/trace.js';\nimport {describeWithEnvironment} from '../../testing/EnvironmentHelpers.js';\nimport {makeInstantEvent} from '../../testing/TraceHelpers.js';\n\nimport * as Timeline from './timeline.js';\n\nasync function loadWebDevTraceAsFile(): Promise<File> {\n  const file = new URL('./fixtures/traces/web-dev.json.gz', import.meta.url);\n  const response = await fetch(file);\n  const asBlob = await response.blob();\n  const asFile = new File([asBlob], 'web-dev.json.gz', {\n    type: 'application/gzip',\n  });\n  return asFile;\n}\n\nasync function loadBasicCpuProfileAsFile(): Promise<File> {\n  const file = new URL('./fixtures/traces/node-fibonacci-website.cpuprofile.gz', import.meta.url);\n  const response = await fetch(file);\n  const asBlob = await response.blob();\n  const asFile = new File([asBlob], 'node-fibonacci-website.cpuprofile.gz', {\n    type: 'application/gzip',\n  });\n  return asFile;\n}\n\ndescribeWithEnvironment('TimelineLoader', () => {\n  const loadingStartedSpy = sinon.spy();\n  const loadingProgressSpy = sinon.spy();\n  const processingStartedSpy = sinon.spy();\n  const loadingCompleteSpy = sinon.spy();\n  const recordingProgressSpy = sinon.spy();\n  const loadingCompleteForTestSpy = sinon.spy();\n\n  const client: Timeline.TimelineController.Client = {\n    async loadingStarted() {\n      loadingStartedSpy();\n    },\n    async loadingProgress(progress?: number) {\n      loadingProgressSpy(progress);\n    },\n    async processingStarted() {\n      processingStartedSpy();\n    },\n    async loadingComplete(\n        collectedEvents: TraceEngine.Types.TraceEvents.TraceEventData[],\n        exclusiveFilter: TimelineModel.TimelineModelFilter.TimelineModelFilter|null,\n        isCpuProfile: boolean,\n    ) {\n      loadingCompleteSpy(collectedEvents, exclusiveFilter, isCpuProfile);\n    },\n    recordingProgress: function(usage: number): void {\n      recordingProgressSpy(usage);\n    },\n    loadingCompleteForTest: function(): void {\n      loadingCompleteForTestSpy();\n    },\n  };\n\n  beforeEach(() => {\n    loadingStartedSpy.resetHistory();\n    loadingProgressSpy.resetHistory();\n    processingStartedSpy.resetHistory();\n    loadingCompleteSpy.resetHistory();\n    recordingProgressSpy.resetHistory();\n    loadingCompleteForTestSpy.resetHistory();\n  });\n\n  it('can load a saved trace file', async () => {\n    const file = await loadWebDevTraceAsFile();\n    const loader = await Timeline.TimelineLoader.TimelineLoader.loadFromFile(file, client);\n    await loader.traceFinalizedForTest();\n    assert.isTrue(loadingStartedSpy.calledOnce);\n    // Exact number is deterministic so we can assert, but the fact it was 29\n    // calls doesn't really matter. We just want to check it got called \"a\n    // bunch of times\".\n    assert.strictEqual(loadingProgressSpy.callCount, 29);\n    assert.isTrue(processingStartedSpy.calledOnce);\n    assert.isTrue(loadingCompleteSpy.calledOnce);\n\n    // Get the arguments of the first (and only) call to the loadingComplete\n    // function. TS doesn't know what the types are (they are [any, any] by\n    // default), so we tell it that they align with the types of the\n    // loadingComplete parameters.\n    const [collectedEvents, exclusiveFilter, isCpuProfile] =\n        loadingCompleteSpy.args[0] as Parameters<Timeline.TimelineController.Client['loadingComplete']>;\n    assert.isNull(exclusiveFilter);  // We are not filtering out any events for this trace.\n    // Ensure that we loaded something that looks about right!\n    assert.lengthOf(collectedEvents, 8252);\n    assert.isFalse(isCpuProfile);\n  });\n\n  it('can load a saved CPUProfile file', async () => {\n    const file = await loadBasicCpuProfileAsFile();\n    const loader = await Timeline.TimelineLoader.TimelineLoader.loadFromFile(file, client);\n    await loader.traceFinalizedForTest();\n    assert.isTrue(loadingStartedSpy.calledOnce);\n    // For the CPU Profile we are testing, loadingProgress will be called three times, because the\n    // file is not that big.\n    assert.strictEqual(loadingProgressSpy.callCount, 3);\n    assert.isTrue(processingStartedSpy.calledOnce);\n    assert.isTrue(loadingCompleteSpy.calledOnce);\n\n    // Get the arguments of the first (and only) call to the loadingComplete\n    // function. TS doesn't know what the types are (they are [any, any] by\n    // default), so we tell it that they align with the types of the\n    // loadingComplete parameters.\n    const [collectedEvents, /* exclusiveFilter */, isCpuProfile] =\n        loadingCompleteSpy.args[0] as Parameters<Timeline.TimelineController.Client['loadingComplete']>;\n    // We create fake trace event for CPU profile, includes one for\n    // TracingStartedInPage, one for metadata, one for root, and one for CPU\n    // profile\n    assert.lengthOf(collectedEvents, 4);\n    assert.isTrue(isCpuProfile);\n  });\n\n  it('can load recorded trace events correctly', async () => {\n    const testTraceEvents: TraceEngine.Types.TraceEvents.TraceEventData[] = [\n      makeInstantEvent('test-event-1', 1),\n      makeInstantEvent('test-event-2', 2),\n    ];\n    const loader = Timeline.TimelineLoader.TimelineLoader.loadFromEvents(testTraceEvents, client);\n    await loader.traceFinalizedForTest();\n    assert.isTrue(loadingStartedSpy.calledOnce);\n    // For the trace events we are testing, loadingProgress will be called only once, because the\n    // fake trace events array is very short.\n    assert.isTrue(loadingProgressSpy.calledOnce);\n    assert.isTrue(processingStartedSpy.calledOnce);\n    assert.isTrue(loadingCompleteSpy.calledOnce);\n\n    // Get the arguments of the first (and only) call to the loadingComplete\n    // function. TS doesn't know what the types are (they are [any, any] by\n    // default), so we tell it that they align with the types of the\n    // loadingComplete parameters.\n    const [collectedEvents, exclusiveFilter, isCpuProfile] =\n        loadingCompleteSpy.args[0] as Parameters<Timeline.TimelineController.Client['loadingComplete']>;\n    assert.isNull(exclusiveFilter);\n    // Ensure that we loaded something that looks about right!\n    assert.lengthOf(collectedEvents, testTraceEvents.length);\n    assert.isFalse(isCpuProfile);\n  });\n\n  it('can load recorded CPUProfile correctly', async () => {\n    const testProfile: Protocol.Profiler.Profile = {nodes: [], startTime: 0, endTime: 0};\n    const loader = Timeline.TimelineLoader.TimelineLoader.loadFromCpuProfile(testProfile, client);\n    await loader.traceFinalizedForTest();\n    assert.isTrue(loadingStartedSpy.calledOnce);\n    // For the CPU Profile we are testing, loadingProgress will be called only once, because the\n    // fake Profile is basically empty.\n    assert.strictEqual(loadingProgressSpy.callCount, 1);\n    assert.isTrue(processingStartedSpy.calledOnce);\n    assert.isTrue(loadingCompleteSpy.calledOnce);\n\n    // Get the arguments of the first (and only) call to the loadingComplete\n    // function. TS doesn't know what the types are (they are [any, any] by\n    // default), so we tell it that they align with the types of the\n    // loadingComplete parameters.\n    const [collectedEvents, /* exclusiveFilter */, isCpuProfile] =\n        loadingCompleteSpy.args[0] as Parameters<Timeline.TimelineController.Client['loadingComplete']>;\n    // We create fake trace event for CPU profile, includes one for TracingStartedInPage,\n    // one for metadata, one for root, and one for CPU profile\n    assert.lengthOf(collectedEvents, 4);\n    assert.isTrue(isCpuProfile);\n  });\n});\n"]}