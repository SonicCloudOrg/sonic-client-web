{"version":3,"file":"Overlays.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Overlays.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TraceEngine from '../../models/trace/trace.js';\nimport type * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\n\nimport * as Components from './components/components.js';\nimport {type TimelineFlameChartDataProvider} from './TimelineFlameChartDataProvider.js';\nimport {type TimelineFlameChartNetworkDataProvider} from './TimelineFlameChartNetworkDataProvider.js';\n\n/**\n * Below the network track there is a resize bar the user can click and drag.\n */\nconst NETWORK_RESIZE_ELEM_HEIGHT_PX = 8;\n\n/**\n * Represents which flamechart an entry is rendered in.\n * We need to know this because when we place an overlay for an entry we need\n * to adjust its Y value if it's in the main chart which is drawn below the\n * network chart\n */\nexport type EntryChartLocation = 'main'|'network';\n\n/**\n * You can add overlays to trace events, but also right now frames are drawn on\n * the timeline but they are not trace events, so we need to allow for that.\n * In the future when the frames track has been migrated to be powered by\n * animation frames (crbug.com/345144583), we can remove the requirement to\n * support TimelineFrame instances (which themselves will be removed from the\n * codebase.)\n */\nexport type OverlayEntry =\n    TraceEngine.Types.TraceEvents.TraceEventData|TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame;\n\n/**\n * Represents when a user has selected an entry in the timeline\n */\nexport interface EntrySelected {\n  type: 'ENTRY_SELECTED';\n  entry: OverlayEntry;\n}\n\n/**\n * Represents a time range on the trace. Also used when the user shift+clicks\n * and drags to create a time range.\n */\nexport interface TimeRangeLabel {\n  type: 'TIME_RANGE';\n  bounds: TraceEngine.Types.Timing.TraceWindowMicroSeconds;\n  label: string;\n  showDuration: boolean;\n}\n\n/**\n * All supported overlay types. Expected to grow in time!\n */\nexport type TimelineOverlay = EntrySelected|TimeRangeLabel;\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n * Note that we can't use the visible trace window from the TraceBounds\n * service as that can get out of sync with rapid FlameChart draws. To ensure\n * we draw overlays smoothly as the FlameChart renders we use the latest values\n * provided to us from the FlameChart. In `FlameChart#draw` we dispatch an\n * event containing the latest dimensions, and those are passed into the\n * Overlays system via TimelineFlameChartView.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\n/**\n * The dimensions each flame chart reports. Note that in the current UI they\n * will always have the same width, so theoretically we could only gather that\n * from one chart, but we gather it from both for simplicity and to cover us in\n * the future should the UI change and the charts have different widths.\n */\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n  // If every single group (e.g. track) within the chart is collapsed or not.\n  // This matters because in the network track if every group (there is only\n  // one) is collapsed, there is no resizer bar shown, which impacts our pixel\n  // calculations for overlay positioning.\n  allGroupsCollapsed: boolean;\n}\n\nexport interface TimelineCharts {\n  mainChart: PerfUI.FlameChart.FlameChart;\n  mainProvider: TimelineFlameChartDataProvider;\n  networkChart: PerfUI.FlameChart.FlameChart;\n  networkProvider: TimelineFlameChartNetworkDataProvider;\n}\n\nexport class Overlays {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #overlaysToElements: Map<TimelineOverlay, HTMLElement|null> = new Map();\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * To calculate the Y pixel value for an event we need access to the chart\n   * and data provider in order to find out what level the event is on, and from\n   * there calculate the pixel value for that level.\n   */\n  #charts: TimelineCharts;\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement;\n\n  constructor(init: {\n    container: HTMLElement,\n    charts: TimelineCharts,\n  }) {\n    this.#overlaysContainer = init.container;\n    this.#charts = init.charts;\n  }\n\n  /**\n   * Because entries can be a TimelineFrame, which is not a trace event, this\n   * helper exists to return a consistent set of timings regardless of the type\n   * of entry.\n   */\n  #timingsForOverlayEntry(entry: OverlayEntry):\n      TraceEngine.Helpers.Timing.EventTimingsData<TraceEngine.Types.Timing.MicroSeconds> {\n    if (entry instanceof TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame) {\n      return {\n        startTime: entry.startTime,\n        endTime: entry.endTime,\n        duration: entry.duration,\n        selfTime: TraceEngine.Types.Timing.MicroSeconds(0),\n      };\n    }\n\n    return TraceEngine.Helpers.Timing.eventTimingsMicroSeconds(entry);\n  }\n\n  #chartForOverlayEntry(entry: OverlayEntry): EntryChartLocation {\n    if (entry instanceof TraceEngine.Handlers.ModelHandlers.Frames.TimelineFrame) {\n      return 'main';\n    }\n    if (TraceEngine.Types.TraceEvents.isSyntheticNetworkRequestDetailsEvent(entry)) {\n      return 'network';\n    }\n\n    return 'main';\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  add<T extends TimelineOverlay>(overlay: T): T {\n    if (this.#overlaysToElements.has(overlay)) {\n      return overlay;\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#overlaysToElements.set(overlay, null);\n    return overlay;\n  }\n\n  /**\n   * Update an existing overlay without destroying and recreating its\n   * associated DOM.\n   *\n   * This is useful if you need to rapidly update an overlay's data - e.g.\n   * dragging to create time ranges - without the thrashing of destroying the\n   * old overlay and re-creating the new one.\n   */\n  updateExisting<T extends TimelineOverlay>(existingOverlay: T, newData: Partial<T>): void {\n    if (!this.#overlaysToElements.has(existingOverlay)) {\n      console.error('Trying to update an overlay that does not exist.');\n      return;\n    }\n\n    for (const [key, value] of Object.entries(newData)) {\n      // newData is of type Partial<T>, so each key must exist in T, but\n      // Object.entries doesn't carry that information.\n      const k = key as keyof T;\n      existingOverlay[k] = value;\n    }\n  }\n\n  /**\n   * @returns the list of overlays associated with a given entry.\n   */\n  overlaysForEntry(entry: OverlayEntry): TimelineOverlay[] {\n    const matches: TimelineOverlay[] = [];\n    for (const [overlay] of this.#overlaysToElements) {\n      if ('entry' in overlay && overlay.entry === entry) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Removes any active overlays that match the provided type.\n   */\n  removeOverlaysOfType(type: TimelineOverlay['type']): void {\n    const overlaysToRemove = Array.from(this.#overlaysToElements.keys()).filter(overlay => {\n      return overlay.type === type;\n    });\n    for (const overlay of overlaysToRemove) {\n      this.remove(overlay);\n    }\n  }\n\n  /**\n   * Removes the provided overlay from the list of overlays and destroys any\n   * DOM associated with it.\n   */\n  remove(overlay: TimelineOverlay): void {\n    const htmlElement = this.#overlaysToElements.get(overlay);\n    if (htmlElement && this.#overlaysContainer) {\n      this.#overlaysContainer.removeChild(htmlElement);\n    }\n    this.#overlaysToElements.delete(overlay);\n  }\n\n  /**\n   * Update the dimenions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: EntryChartLocation, dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: TraceEngine.Types.Timing.TraceWindowMicroSeconds): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the preivous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#overlaysToElements.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  /**\n   * Updates the Overlays UI: new overlays will be rendered onto the view, and\n   * existing overlays will have their positions changed to ensure they are\n   * rendered in the right place.\n   */\n  update(): void {\n    for (const [overlay, existingElement] of this.#overlaysToElements) {\n      const element = existingElement || this.#createElementForNewOverlay(overlay);\n      if (existingElement) {\n        this.#updateOverlayElementIfRequired(overlay, element);\n\n      } else {\n        // This is a new overlay, so we have to store the element and add it to the DOM.\n        this.#overlaysToElements.set(overlay, element);\n        this.#overlaysContainer.appendChild(element);\n      }\n      this.#positionOverlay(overlay, element);\n    }\n  }\n\n  #positionOverlay(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED': {\n        if (this.entryIsVisibleOnChart(overlay.entry)) {\n          element.style.visibility = 'visible';\n          this.#positionEntrySelectedOverlay(overlay, element);\n        } else {\n          element.style.visibility = 'hidden';\n        }\n        break;\n      }\n      case 'TIME_RANGE': {\n        this.#positionTimeRangeOverlay(overlay, element);\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.afterOverlayUpdate();\n        }\n        break;\n      }\n\n      default: {\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unknown overlay: ${JSON.stringify(overlay)}`);\n      }\n    }\n  }\n\n  #positionTimeRangeOverlay(overlay: TimeRangeLabel, element: HTMLElement): void {\n    // Time ranges span both charts, it doesn't matter which one we pass here.\n    // It's used to get the width of the container, and both charts have the\n    // same width.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.min);\n    const rightEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n  }\n  /**\n   * Positions an EntrySelected overlay. As we extend the list of overlays,\n   * some of the code in here around positioning may be re-used elsewhere.\n   * @param overlay - the EntrySelected overlay that we need to position.\n   * @param element - the DOM element representing the overlay\n   */\n  #positionEntrySelectedOverlay(overlay: EntrySelected, element: HTMLElement): void {\n    const chartName = this.#chartForOverlayEntry(overlay.entry);\n    let x = this.xPixelForEventOnChart(overlay.entry);\n    let y = this.yPixelForEventOnChart(overlay.entry);\n\n    if (x === null || y === null) {\n      return;\n    }\n\n    const {endTime, duration} = this.#timingsForOverlayEntry(overlay.entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    if (endX === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    let widthPixels = endX - x;\n\n    if (!duration) {\n      // No duration = instant event, so we check in case it's a marker.\n      const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n      const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n      // It could be a marker event, in which case we need to know the\n      // exact position the marker was rendered. This is because markers\n      // which have the same timestamp are rendered next to each other, so\n      // the timestamp is not necessarily exactly where the marker was\n      // rendered.\n      const index = provider.indexForEvent(overlay.entry);\n      const markerPixels = chart.getMarkerPixelsForEntryIndex(index ?? -1);\n      if (markerPixels) {\n        x = markerPixels.x;\n        widthPixels = markerPixels.width;\n      }\n    }\n\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.#networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${x}px`;\n  }\n\n  #createElementForNewOverlay(overlay: TimelineOverlay): HTMLElement {\n    const div = document.createElement('div');\n    div.classList.add('overlay-item', `overlay-type-${overlay.type}`);\n    if (overlay.type === 'TIME_RANGE') {\n      const component = new Components.TimeRangeOverlay.TimeRangeOverlay();\n      component.duration = overlay.showDuration ? overlay.bounds.range : null;\n      component.label = overlay.label;\n      component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n      div.appendChild(component);\n    }\n    return div;\n  }\n\n  /**\n   * Some of the HTML elements for overlays might need updating between each render\n   * (for example, if a time range has changed, we update its duration text)\n   */\n  #updateOverlayElementIfRequired(overlay: TimelineOverlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        // Nothing to do here.\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.duration = overlay.showDuration ? overlay.bounds.range : null;\n          component.label = overlay.label;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n\n  /**\n   * @returns true if the entry is visible on chart, which means that both\n   * horizontally and vertically it is at least partially in view.\n   */\n  entryIsVisibleOnChart(entry: OverlayEntry): boolean {\n    const verticallyVisible = this.#entryIsVerticallyVisibleOnChart(entry);\n    const horiziontallyVisible = this.#entryIsHorizontallyVisibleOnChart(entry);\n    return verticallyVisible && horiziontallyVisible;\n  }\n\n  /**\n   * Calculates if an entry is visible horizontally. This is easy because we\n   * don't have to consider any pixels and can instead check that its start and\n   * end times intersect with the visible window.\n   */\n  #entryIsHorizontallyVisibleOnChart(entry: OverlayEntry): boolean {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      return false;\n    }\n    const {startTime, endTime} = this.#timingsForOverlayEntry(entry);\n\n    const {min: visibleMin, max: visibleMax} = this.#dimensions.trace.visibleWindow;\n\n    // The event is visible if\n    // 1. Its endTime is within the visible window\n    // OR\n    // 2. Its startTime is within the visible window\n    // OR\n    // 3. Its startTime is less than the visible window, and its endTime is\n    // greater than it. This means that the event spans the entire visible\n    // window but starts and ends outside of it.\n    // If none of these cases are true, the event must be off screen.\n\n    // 1. End time is within the visible window.\n    if (endTime >= visibleMin && endTime <= visibleMax) {\n      return true;\n    }\n\n    // 2. Start time is within the visible window.\n    if (startTime >= visibleMin && startTime <= visibleMax) {\n      return true;\n    }\n\n    // 3. Start time is before the visible window and end time is after.\n    if (startTime <= visibleMin && endTime >= visibleMax) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate if an entry is visible vertically on the chart. A bit fiddly as\n   * we have to figure out its pixel offset and go on that. Unlike horizontal\n   * visibility, we can't work soley from its microsecond values.\n   */\n  #entryIsVerticallyVisibleOnChart(entry: OverlayEntry): boolean {\n    const chartName = this.#chartForOverlayEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return false;\n    }\n\n    const eventHeight = this.pixelHeightForEventOnChart(entry);\n    if (!eventHeight) {\n      return false;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return false;\n      }\n\n      // The yPixelForEventOnChart method returns the y pixel including an adjustment for the network track.\n      // To see if an entry on the main flame chart is visible, we can check\n      // its y value without the network track adjustment. If it is < 0, then\n      // it's off the top of the screen.\n      //\n      const yWithoutNetwork = y - this.#networkChartOffsetHeight();\n      // Check if the y position + the height is less than 0. We add height so\n      // that we correctly consider an event only partially scrolled off to be\n      // visible.\n      if (yWithoutNetwork + eventHeight < 0) {\n        return false;\n      }\n\n      if (yWithoutNetwork > this.#dimensions.charts.main.heightPixels) {\n        // The event is off the bottom of the screen.\n        return false;\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        // The network chart can be hidden if there are no requests in the trace.\n        return false;\n      }\n      if (y <= -14) {\n        // Weird value, but the network chart has the header row with\n        // timestamps on it: events stay visible behind those timestamps, so we\n        // want any overlays to treat themselves as visible too.\n        return false;\n      }\n\n      if (y > this.#dimensions.charts.network.heightPixels ?? 0) {\n        // The event is off the bottom of the network chart.\n        return false;\n      }\n    }\n    // If we got here, none of the conditions to mark an event as invisible got\n    // triggered, so the event must be visible.\n    return true;\n  }\n\n  /**\n   * Calculate the X pixel position for an event on the timeline.\n   * @param chartName - the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   *\n   * @param event - the trace event you want to get the pixel position of\n   */\n  xPixelForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const {startTime} = this.#timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, startTime);\n  }\n\n  /**\n   * Calculate the xPixel for a given timestamp. To do this we calculate how\n   * far in microseconds from the left of the visible window an event is, and\n   * divide that by the total time span. This gives us a fraction representing\n   * how far along the timeline the event is. We can then multiply that by the\n   * width of the canvas to get its pixel position.\n   */\n  #xPixelForMicroSeconds(chart: EntryChartLocation, timestamp: TraceEngine.Types.Timing.MicroSeconds): number|null {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      console.error('Cannot calculate xPixel without visible trace window.');\n      return null;\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (!canvasWidthPixels) {\n      console.error(`Cannot calculate xPixel without ${chart} dimensions.`);\n      return null;\n    }\n\n    const timeFromLeft = timestamp - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n\n  /**\n   * Calculate the Y pixel position for the event on the timeline relative to\n   * the entire window.\n   * This means if the event is in the main flame chart and below the network,\n   * we add the height of the network chart to the Y value to position it\n   * correctly.\n   * This can return null if any data waas missing, or if the event is not\n   * visible (if the level it's on is hidden because the track is collapsed,\n   * for example)\n   */\n  yPixelForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n\n    if (!chart.levelIsVisible(level)) {\n      return null;\n    }\n\n    const pixelOffsetForLevel = chart.levelToOffset(level);\n    // Now we have the offset for the level, we need to adjust it by the user's scroll offset.\n    let pixelAdjustedForScroll = pixelOffsetForLevel - (this.#dimensions.charts[chartName]?.scrollOffsetPixels ?? 0);\n\n    // Now if the event is in the main chart, we need to pad its Y position\n    // down by the height of the network chart + the network resize element.\n    if (chartName === 'main') {\n      pixelAdjustedForScroll += this.#networkChartOffsetHeight();\n    }\n\n    return pixelAdjustedForScroll;\n  }\n\n  /**\n   * Calculate the height of the event on the timeline.\n   */\n  pixelHeightForEventOnChart(event: OverlayEntry): number|null {\n    const chartName = this.#chartForOverlayEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n    return chart.levelHeight(level);\n  }\n\n  /**\n   * Calculate the height of the network chart. If the network chart has\n   * height, we also allow for the size of the resize handle shown between the\n   * two charts.\n   *\n   * Note that it is possible for the chart to have 0 height if the user is\n   * looking at a trace with no network requests.\n   */\n  #networkChartOffsetHeight(): number {\n    if (this.#dimensions.charts.network === null) {\n      return 0;\n    }\n\n    if (this.#dimensions.charts.network.heightPixels === 0) {\n      return 0;\n    }\n\n    // At this point we know the network track exists and has height. But we\n    // need to check if it is collapsed, because if it is collapsed there is no\n    // resizer shown.\n    if (this.#dimensions.charts.network.allGroupsCollapsed) {\n      return this.#dimensions.charts.network.heightPixels;\n    }\n\n    return this.#dimensions.charts.network.heightPixels + NETWORK_RESIZE_ELEM_HEIGHT_PX;\n  }\n}\n"]}