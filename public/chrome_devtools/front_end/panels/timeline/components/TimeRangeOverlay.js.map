{"version":3,"file":"TimeRangeOverlay.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/components/TimeRangeOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport type * as TraceEngine from '../../../models/trace/trace.js';\nimport * as ComponentHelpers from '../../../ui/components/helpers/helpers.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\n\nimport styles from './timeRangeOverlay.css.js';\n\nexport class TimeRangeOverlay extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-time-range-overlay`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #boundRender = this.#render.bind(this);\n  #duration: TraceEngine.Types.Timing.MicroSeconds|null = null;\n  #label = '';\n  #canvasRect: DOMRect|null = null;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [styles];\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    this.#canvasRect = rect;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  set duration(duration: TraceEngine.Types.Timing.MicroSeconds|null) {\n    if (duration === this.#duration) {\n      return;\n    }\n    this.#duration = duration;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  set label(label: string) {\n    if (label === this.#label) {\n      return;\n    }\n    this.#label = label;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);\n  }\n\n  /**\n   * This calculates how much of the time range is in the user's view. This is\n   * used to determine how much of the label can fit into the view, and if we\n   * should even show the label.\n   */\n  #visibleOverlayWidth(overlayRect: DOMRect): number {\n    if (!this.#canvasRect) {\n      return 0;\n    }\n\n    const {x: overlayStartX, width} = overlayRect;\n    const overlayEndX = overlayStartX + width;\n\n    const canvasStartX = this.#canvasRect.x;\n    const canvasEndX = this.#canvasRect.x + this.#canvasRect.width;\n\n    const leftVisible = Math.max(canvasStartX, overlayStartX);\n    const rightVisible = Math.min(canvasEndX, overlayEndX);\n    return rightVisible - leftVisible;\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  afterOverlayUpdate(): void {\n    const label = this.#shadow.querySelector<HTMLElement>('.label');\n    if (!label) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    const overlayRect = this.getBoundingClientRect();\n    const labelRect = label.getBoundingClientRect();\n    const visibleOverlayWidth = this.#visibleOverlayWidth(overlayRect) - paddingForScrollbar;\n    const overlayTooNarrow = visibleOverlayWidth <= labelRect.width - paddingForScrollbar;\n    label.classList.toggle('labelHidden', overlayTooNarrow);\n\n    if (overlayTooNarrow) {\n      // Label is invisible, no need to do all the layout.\n      return;\n    }\n\n    // Check if label is off the LHS of the screen.\n    const labelLeftMarginToCenter = (overlayRect.width - labelRect.width) / 2;\n    const newLabelX = overlayRect.x + labelLeftMarginToCenter;\n\n    const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n    label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n    // Check if label is off the RHS of the screen\n    const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n    // The label's right hand edge is the gap from the left of the range to the\n    // label, and then the width of the label.\n    const labelRightEdge = overlayRect.x + labelLeftMarginToCenter + labelRect.width;\n    const labelOffRightOfScreen = labelRightEdge > rightBound;\n    label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n    if (labelOffLeftOfScreen) {\n      // If the label is off the left of the screen, we adjust by the\n      // difference between the X that represents the start of the cavnas, and\n      // the X that represents the start of the overlay.\n      // We then take the absolute value of this - because if the canvas starts\n      // at 0, and the overlay is -200px, we have to adjust the label by +200.\n      // Add on 9 pixels to pad from the left; this is the width of the sidebar\n      // on the RHS so we match it so the label is equally padded on either\n      // side.\n      label.style.marginLeft = `${Math.abs(this.#canvasRect.x - overlayRect.x) + paddingForScrollbar}px`;\n    } else if (labelOffRightOfScreen) {\n      // To calculate how far left to push the label, we take the right hand\n      // bound (the canvas width and subtract the label's width).\n      // Finally, we subtract the X position of the overlay (if the overlay is\n      // 200px within the view, we don't need to push the label that 200px too\n      // otherwise it will be off-screen)\n      const leftMargin = rightBound - labelRect.width - overlayRect.x;\n\n      label.style.marginLeft = `${leftMargin}px`;\n\n    } else {\n      // Keep the label central.\n      label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n    }\n  }\n\n  #render(): void {\n    const durationText = this.#duration ? i18n.TimeUtilities.formatMicroSecondsTime(this.#duration) : '';\n\n    LitHtml.render(\n        LitHtml.html`<span class=\"label\">${this.#label}<br>${durationText}</span>`, this.#shadow, {host: this});\n  }\n}\n\ncustomElements.define('devtools-time-range-overlay', TimeRangeOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-time-range-overlay': TimeRangeOverlay;\n  }\n}\n"]}