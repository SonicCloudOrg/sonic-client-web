{"version":3,"file":"SourceMapsResolver.test.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/SourceMapsResolver.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {type Chrome} from '../../../extension-api/ExtensionAPI.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport * as TraceEngine from '../../models/trace/trace.js';\nimport {createTarget} from '../../testing/EnvironmentHelpers.js';\nimport {TestPlugin} from '../../testing/LanguagePluginHelpers.js';\nimport {\n  describeWithMockConnection,\n} from '../../testing/MockConnection.js';\nimport {loadBasicSourceMapExample} from '../../testing/SourceMapHelpers.js';\nimport {\n  makeMockSamplesHandlerData,\n  makeProfileCall,\n} from '../../testing/TraceHelpers.js';\n\nimport * as Timeline from './timeline.js';\n\nconst MINIFIED_FUNCTION_NAME = 'minified';\nconst AUTHORED_FUNCTION_NAME = 'someFunction';\n\ndescribeWithMockConnection('SourceMapsResolver', () => {\n  let target: SDK.Target.Target;\n  let script: SDK.Script.Script;\n  let traceParsedData: TraceEngine.Handlers.Types.TraceParseData;\n  let profileCall: TraceEngine.Types.TraceEvents.SyntheticProfileCall;\n  beforeEach(async function() {\n    target = createTarget();\n    script = (await loadBasicSourceMapExample(target)).script;\n    // Ideally we would get a column number we can use from the source\n    // map however the current status of the source map helpers makes\n    // it difficult to do so.\n    const columnNumber = 51;\n    profileCall = makeProfileCall(\n        'function', 10, 100, TraceEngine.Types.TraceEvents.ProcessID(1), TraceEngine.Types.TraceEvents.ThreadID(1));\n\n    profileCall.callFrame = {\n      'columnNumber': columnNumber,\n      'functionName': 'minified',\n      'lineNumber': 0,\n      'scriptId': script.scriptId,\n      'url': 'file://gen.js',\n    };\n\n    const workersData: TraceEngine.Handlers.ModelHandlers.Workers.WorkersData = {\n      workerSessionIdEvents: [],\n      workerIdByThread: new Map(),\n      workerURLById: new Map(),\n    };\n    // This only includes data used in the SourceMapsResolver\n    traceParsedData = {\n      Samples: makeMockSamplesHandlerData([profileCall]),\n      Workers: workersData,\n    } as TraceEngine.Handlers.Types.TraceParseData;\n  });\n\n  it('renames nodes from the profile models when the corresponding scripts and source maps have loaded',\n     async function() {\n       const resolver = new Timeline.SourceMapsResolver.SourceMapsResolver(traceParsedData);\n\n       // Test the node's name is minified before the script and source maps load.\n       assert.strictEqual(\n           TraceEngine.Handlers.ModelHandlers.Samples.getProfileCallFunctionName(traceParsedData.Samples, profileCall),\n           MINIFIED_FUNCTION_NAME);\n\n       await resolver.install();\n\n       // Now that the script and source map have loaded, test that the model has been automatically\n       // reparsed to resolve function names.\n       assert.strictEqual(\n           TraceEngine.Handlers.ModelHandlers.Samples.getProfileCallFunctionName(traceParsedData.Samples, profileCall),\n           AUTHORED_FUNCTION_NAME);\n\n       // Ensure we populate the cache\n       assert.strictEqual(\n           Timeline.SourceMapsResolver.SourceMapsResolver.resolvedNodeNameForEntry(profileCall),\n           AUTHORED_FUNCTION_NAME);\n     });\n\n  it('resolves function names using a plugin when available', async () => {\n    const PLUGIN_FUNCTION_NAME = 'PLUGIN_FUNCTION_NAME';\n    class Plugin extends TestPlugin {\n      constructor() {\n        super('InstrumentationBreakpoints');\n      }\n\n      override getFunctionInfo(_rawLocation: Chrome.DevTools.RawLocation):\n          Promise<{frames: Chrome.DevTools.FunctionInfo[], missingSymbolFiles?: string[]|undefined}> {\n        return Promise.resolve({frames: [{name: PLUGIN_FUNCTION_NAME}]});\n      }\n      override handleScript(_: SDK.Script.Script) {\n        return true;\n      }\n    }\n\n    const {pluginManager} = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n    pluginManager.addPlugin(new Plugin());\n    const resolver = new Timeline.SourceMapsResolver.SourceMapsResolver(traceParsedData);\n    await resolver.install();\n    assert.strictEqual(\n        TraceEngine.Handlers.ModelHandlers.Samples.getProfileCallFunctionName(traceParsedData.Samples, profileCall),\n        PLUGIN_FUNCTION_NAME);\n  });\n});\n"]}