{"version":3,"file":"SourceMapsResolver.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/SourceMapsResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as SourceMapScopes from '../../models/source_map_scopes/source_map_scopes.js';\nimport type * as TraceEngine from '../../models/trace/trace.js';\n\nexport class NodeNamesUpdated extends Event {\n  static readonly eventName = 'nodenamesupdated';\n\n  constructor() {\n    super(NodeNamesUpdated.eventName, {\n      composed: true,\n      bubbles: true,\n    });\n  }\n}\n\n// Track node function names resolved by sourcemaps.\n// Because NodeIDs could conflict, we key these based on:\n// ProcessID=>ThreadID=>NodeId=>resolved function name.\n// Keying it by the IDs rather than the Node itself means we can avoid passing around trace data in order to get or set values in this map.\nconst resolvedNodeNames:\n    Map<TraceEngine.Types.TraceEvents.ProcessID,\n        Map<TraceEngine.Types.TraceEvents.ThreadID, Map<number, string|null>>> = new Map();\n\nexport class SourceMapsResolver extends EventTarget {\n  #traceData: TraceEngine.Handlers.Types.TraceParseData;\n\n  #isResolvingNames = false;\n\n  // We need to gather up a list of all the DebuggerModels that we should\n  // listen to for source map attached events. For most pages this will be\n  // the debugger model for the primary page target, but if a trace has\n  // workers, we would also need to gather up the DebuggerModel instances for\n  // those workers too.\n  #debuggerModelsToListen = new Set<SDK.DebuggerModel.DebuggerModel>();\n\n  constructor(traceData: TraceEngine.Handlers.Types.TraceParseData) {\n    super();\n    this.#traceData = traceData;\n  }\n\n  static clearResolvedNodeNames(): void {\n    resolvedNodeNames.clear();\n  }\n\n  static resolvedNodeNameForEntry(entry: TraceEngine.Types.TraceEvents.SyntheticProfileCall): string|null {\n    return resolvedNodeNames.get(entry.pid)?.get(entry.tid)?.get(entry.nodeId) ?? null;\n  }\n\n  static storeResolvedNodeNameForEntry(\n      pid: TraceEngine.Types.TraceEvents.ProcessID, tid: TraceEngine.Types.TraceEvents.ThreadID, nodeId: number,\n      resolvedFunctionName: string|null): void {\n    const resolvedForPid =\n        resolvedNodeNames.get(pid) || new Map<TraceEngine.Types.TraceEvents.ThreadID, Map<number, string|null>>();\n    const resolvedForTid = resolvedForPid.get(tid) || new Map<number, string|null>();\n    resolvedForTid.set(nodeId, resolvedFunctionName);\n    resolvedForPid.set(tid, resolvedForTid);\n    resolvedNodeNames.set(pid, resolvedForPid);\n  }\n\n  async install(): Promise<void> {\n    // Required as during the migration we might not always run the Renderer/Samples\n    // handlers. Once we are fully migrated, this check can go as that data will\n    // always be present.\n    if (!this.#traceData.Samples) {\n      return;\n    }\n\n    for (const threadToProfileMap of this.#traceData.Samples.profilesInProcess.values()) {\n      for (const [tid, profile] of threadToProfileMap) {\n        const nodes = profile.parsedProfile.nodes();\n        if (!nodes || nodes.length === 0) {\n          continue;\n        }\n\n        const target = this.#targetForThread(tid);\n        const debuggerModel = target?.model(SDK.DebuggerModel.DebuggerModel);\n        if (!debuggerModel) {\n          continue;\n        }\n        for (const node of nodes) {\n          const script = debuggerModel.scriptForId(String(node.callFrame.scriptId));\n          const shouldListenToSourceMap = !script || script.sourceMapURL;\n          if (!shouldListenToSourceMap) {\n            continue;\n          }\n          this.#debuggerModelsToListen.add(debuggerModel);\n        }\n      }\n    }\n\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().addEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n\n    // Although we have added listeners for SourceMapAttached events, we also\n    // immediately try to resolve function names. This ensures we use any\n    // sourcemaps that were attached before we bound our event listener.\n    await this.#resolveNamesForNodes();\n  }\n\n  /**\n   * Removes the event listeners and stops tracking newly added sourcemaps.\n   * Should be called before destroying an instance of this class to avoid leaks\n   * with listeners.\n   */\n  uninstall(): void {\n    for (const debuggerModel of this.#debuggerModelsToListen) {\n      debuggerModel.sourceMapManager().removeEventListener(\n          SDK.SourceMapManager.Events.SourceMapAttached, this.#onAttachedSourceMap, this);\n    }\n    this.#debuggerModelsToListen.clear();\n  }\n\n  async #resolveNamesForNodes(): Promise<void> {\n    if (!this.#traceData.Samples) {\n      return;\n    }\n\n    for (const [pid, threadsInProcess] of this.#traceData.Samples.profilesInProcess) {\n      for (const [tid, threadProfile] of threadsInProcess) {\n        const nodes = threadProfile.parsedProfile.nodes() ?? [];\n        const target = this.#targetForThread(tid);\n        if (!target) {\n          continue;\n        }\n        for (const node of nodes) {\n          const resolvedFunctionName =\n              await SourceMapScopes.NamesResolver.resolveProfileFrameFunctionName(node.callFrame, target);\n          node.setFunctionName(resolvedFunctionName);\n\n          SourceMapsResolver.storeResolvedNodeNameForEntry(pid, tid, node.id, resolvedFunctionName);\n        }\n      }\n    }\n    this.dispatchEvent(new NodeNamesUpdated());\n  }\n\n  #onAttachedSourceMap(): void {\n    // Exit if we are already resolving so that we batch requests; if pages\n    // have a lot of sourcemaps we can get a lot of events at once.\n    if (this.#isResolvingNames) {\n      return;\n    }\n\n    this.#isResolvingNames = true;\n    // Resolving names triggers a repaint of the flame chart. Instead of attempting to resolve\n    // names every time a source map is attached, wait for some time once the first source map is\n    // attached. This way we allow for other source maps to be parsed before attempting a name\n    // resolving using the available source maps. Otherwise the UI is blocked when the number\n    // of source maps is particularly large.\n    setTimeout(async () => {\n      this.#isResolvingNames = false;\n      await this.#resolveNamesForNodes();\n    }, 500);\n  }\n\n  // Figure out the target for the node. If it is in a worker thread,\n  // that is the target, otherwise we use the primary page target.\n  #targetForThread(tid: TraceEngine.Types.TraceEvents.ThreadID): SDK.Target.Target|null {\n    const maybeWorkerId = this.#traceData.Workers.workerIdByThread.get(tid);\n    if (maybeWorkerId) {\n      return SDK.TargetManager.TargetManager.instance().targetById(maybeWorkerId);\n    }\n    return SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n  }\n}\n"]}