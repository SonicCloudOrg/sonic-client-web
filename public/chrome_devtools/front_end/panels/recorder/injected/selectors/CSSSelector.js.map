{"version":3,"file":"CSSSelector.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/recorder/injected/selectors/CSSSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {SelectorPart, type Selector} from './Selector.js';\n\nexport interface QueryableNode extends Node {\n  querySelectorAll(selectors: string): NodeListOf<Element>;\n}\n\nconst idSelector = (id: string): string => {\n  return `#${CSS.escape(id)}`;\n};\n\nconst attributeSelector = (name: string, value: string): string => {\n  return `[${name}='${CSS.escape(value)}']`;\n};\n\nconst classSelector = (selector: string, className: string): string => {\n  return `${selector}.${CSS.escape(className)}`;\n};\n\nconst nthTypeSelector = (selector: string, index: number): string => {\n  return `${selector}:nth-of-type(${index + 1})`;\n};\n\nconst typeSelector = (selector: string, type: string): string => {\n  return `${selector}${attributeSelector('type', type)}`;\n};\n\nconst hasUniqueId = (node: Element): boolean => {\n  return (Boolean(node.id) && (node.getRootNode() as QueryableNode).querySelectorAll(idSelector(node.id)).length === 1);\n};\n\nconst isUniqueAmongTagNames = (\n    node: Element,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child.tagName === node.tagName) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isUniqueAmongInputTypes = (\n    node: HTMLInputElement,\n    children: Iterable<Element>,\n    ): boolean => {\n  for (const child of children) {\n    if (child !== node && child instanceof HTMLInputElement && child.type === node.type) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getUniqueClassName = (\n    node: Element,\n    children: Iterable<Element>,\n    ): string|undefined => {\n  const classNames = new Set(node.classList);\n  for (const child of children) {\n    if (child !== node) {\n      for (const className of child.classList) {\n        classNames.delete(className);\n      }\n      if (classNames.size === 0) {\n        break;\n      }\n    }\n  }\n  if (classNames.size > 0) {\n    return classNames.values().next().value;\n  }\n  return undefined;\n};\n\nconst getTypeIndex = (node: Element, children: Iterable<Element>): number => {\n  let nthTypeIndex = 0;\n  for (const child of children) {\n    if (child === node) {\n      return nthTypeIndex;\n    }\n    if (child.tagName === node.tagName) {\n      ++nthTypeIndex;\n    }\n  }\n  throw new Error('Node not found in children');\n};\n\nexport const getSelectorPart = (\n    node: Node,\n    attributes: string[] = [],\n    ): SelectorPart|undefined => {\n  if (!(node instanceof Element)) {\n    return;\n  }\n\n  // Declared attibutes have the greatest priority.\n  for (const attribute of attributes) {\n    const value = node.getAttribute(attribute);\n    if (value) {\n      return new SelectorPart(attributeSelector(attribute, value), true);\n    }\n  }\n\n  // IDs are supposed to be globally unique, so this has second priority.\n  if (hasUniqueId(node)) {\n    return new SelectorPart(idSelector(node.id), true);\n  }\n\n  // All selectors will be prefixed with the tag name starting here.\n  const selector = node.tagName.toLowerCase();\n\n  // These can only appear once in the entire document, so handle this fast.\n  switch (node.tagName) {\n    case 'BODY':\n    case 'HEAD':\n    case 'HTML':\n      return new SelectorPart(selector, true);\n  }\n\n  const parent = node.parentNode;\n  // If the node has no parent, then the node must be detached. We handle this\n  // gracefully.\n  if (!parent) {\n    return new SelectorPart(selector, true);\n  }\n\n  const children = parent.children;\n\n  // Determine if the child has a unique node name among all children.\n  if (isUniqueAmongTagNames(node, children)) {\n    return new SelectorPart(selector, true);\n  }\n\n  // If it's an input, check uniqueness among types.\n  if (node instanceof HTMLInputElement && isUniqueAmongInputTypes(node, children)) {\n    return new SelectorPart(typeSelector(selector, node.type), true);\n  }\n\n  // Determine if the child has a unique class name.\n  const className = getUniqueClassName(node, children);\n  if (className !== undefined) {\n    return new SelectorPart(classSelector(selector, className), true);\n  }\n\n  // Last resort. Just use the nth-type index. A priori, this will always exists.\n  return new SelectorPart(\n      nthTypeSelector(selector, getTypeIndex(node, children)),\n      false,\n  );\n};\n\n/**\n * This interface represents operations on an ordered range of indices of type\n * `I`. Implementations must have the following assumptions:\n *\n *  1. `self(self(i)) = self(i)`, i.e. `self` must be idempotent.\n *  2. `inc(i) > i`.\n *  3. `j >= i` implies `gte(valueOf(j), i)`, i.e. `gte` preserves the order of\n *     the range.\n *\n */\nexport interface RangeOps<I, V> {\n  // Returns a suitable version of an index (e.g. ShadowRoot.host instead of\n  // ShadowRoot).\n  self?(index: I): I;\n\n  // Increments the given index by 1.\n  inc(index: I): I;\n\n  // Gets the value at the given index.\n  valueOf(index: I): V;\n\n  // Must preserve `j >= i` if `value === valueOf(j)`.\n  gte(value: V, index: I): boolean;\n}\n\n/**\n * The goal of this function is to find the smallest index `i` that makes\n * `gte(valueOf(i), j)` true for all `j` in `[min, max)`. We do not use binary\n * search because\n *\n *  1. We expect the min-max to be concentrated towards the minimum (< 10\n *     iterations).\n *  2. We expect `valueOf` to be `O(n)`, so together with (1), the average will\n *     be around `O(n)` which is significantly faster than binary search in this\n *     case.\n */\nexport const findMinMax = <I, V>(\n    [min, max]: [I, I],\n    fns: RangeOps<I, V>,\n    ): V => {\n  fns.self ??= (i): I => i;\n\n  let index = fns.inc(min);\n  let value: V;\n  let isMax: boolean;\n  do {\n    value = fns.valueOf(min);\n    isMax = true;\n    while (index !== max) {\n      min = fns.self(index);\n      index = fns.inc(min);\n      if (!fns.gte(value, index)) {\n        isMax = false;\n        break;\n      }\n    }\n  } while (!isMax);\n  return value;\n};\n\nexport class SelectorRangeOps implements RangeOps<QueryableNode, string> {\n  // Close chains (using `>`) are stored in inner arrays.\n  #buffer: SelectorPart[][] = [[]];\n  #attributes: string[];\n  #depth = 0;\n\n  constructor(attributes: string[] = []) {\n    this.#attributes = attributes;\n  }\n\n  inc(node: Node): QueryableNode {\n    return node.parentNode ?? (node.getRootNode() as QueryableNode);\n  }\n  valueOf(node: Node): string {\n    const part = getSelectorPart(node, this.#attributes);\n    if (!part) {\n      throw new Error('Node is not an element');\n    }\n    if (this.#depth > 1) {\n      // Implies this selector is for a distant ancestor.\n      this.#buffer.unshift([part]);\n    } else {\n      // Implies this selector is for a parent.\n      this.#buffer[0].unshift(part);\n    }\n    this.#depth = 0;\n    return this.#buffer.map(parts => parts.join(' > ')).join(' ');\n  }\n  gte(selector: string, node: QueryableNode): boolean {\n    ++this.#depth;\n    return node.querySelectorAll(selector).length === 1;\n  }\n}\n\n/**\n * Computes the CSS selector for a node.\n *\n * @param node - The node to compute.\n * @returns The computed CSS selector.\n *\n * @internal\n */\nexport const computeCSSSelector = (\n    node: Node,\n    attributes?: string[],\n    ): Selector|undefined => {\n  const selectors = [];\n\n  // We want to find the minimal selector that is unique within a document. We\n  // are slightly restricted since selectors cannot cross ShadowRoot borders, so\n  // the actual goal is to find the minimal selector that is unique within a\n  // root node. We then need to repeat this for each shadow root.\n  try {\n    let root: Document|ShadowRoot;\n    while (node instanceof Element) {\n      root = node.getRootNode() as Document | ShadowRoot;\n      selectors.unshift(\n          findMinMax(\n              [node as QueryableNode, root],\n              new SelectorRangeOps(attributes),\n              ),\n      );\n      node = root instanceof ShadowRoot ? root.host : root;\n    }\n  } catch {\n    return undefined;\n  }\n\n  return selectors;\n};\n\nexport const queryCSSSelectorAll = (selectors: Selector): Element[] => {\n  if (typeof selectors === 'string') {\n    selectors = [selectors];\n  } else if (selectors.length === 0) {\n    return [];\n  }\n  let lists: NodeListOf<Element>[] = [\n    [document.documentElement] as unknown as NodeListOf<Element>,\n  ];\n  do {\n    const selector = selectors.shift() as string;\n    const roots: NodeListOf<Element>[] = [];\n    for (const nodes of lists) {\n      for (const node of nodes) {\n        const list = (node.shadowRoot ?? node).querySelectorAll(selector);\n        if (list.length > 0) {\n          roots.push(list);\n        }\n      }\n    }\n    lists = roots;\n  } while (selectors.length > 0 && lists.length > 0);\n  return lists.flatMap(list => [...list]);\n};\n"]}