{"version":3,"file":"SharedObject.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/recorder/util/SharedObject.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,gCAAgC,CAAC;AAMzD;;;;;;;;;;;;GAYG;AACH,MAAM,OAAO,YAAY;IACvB,MAAM,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IAClC,QAAQ,GAAG,CAAC,CAAC;IACb,MAAM,CAAc;IAEpB,OAAO,CAAqB;IAC5B,QAAQ,CAAgC;IAExC,YAAY,MAA0B,EAAE,OAAsC;QAC5E,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,OAAO;QACX,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE;YAC/B,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;gBACxB,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;YACrC,CAAC;YACD,EAAE,IAAI,CAAC,QAAQ,CAAC;QAClB,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,IAAI,CAAC,MAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,EAAC,QAAQ,EAAE,KAAK,EAAC,CAAC,CAAC,CAAC;IACzE,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,GAAG,CAAI,MAAkC;QAC7C,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;QAC9C,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,CAAC;YACnC,OAAO,MAAM,CAAC;QAChB,CAAC;gBAAS,CAAC;YACT,MAAM,OAAO,EAAE,CAAC;QAClB,CAAC;IACH,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,KAA0B;QACvC,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;QACjE,CAAC;QACD,IAAI,CAAC;YACH,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;YACtB,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE;gBAC/B,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE,CAAC;oBACxB,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAW,CAAC,CAAC;oBACtC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;gBAC1B,CAAC;gBACD,EAAE,IAAI,CAAC,QAAQ,CAAC;YAClB,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC;YACvB,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\n\ntype Awaitable<T> = Promise<T>|T;\n\nexport type ReleaseFunction = () => Promise<void>;\n\n/**\n * SharedObject is similar to a C++ shared pointer, i.e. a reference counted\n * object.\n *\n * A object is \"created\" whenever there are no acquirers and it's then acquired.\n * Subsequent acquirers use the same object. Only until all acquirers release\n * will the object be \"destroyed\".\n *\n * Using an object after it's destroyed is undefined behavior.\n *\n * The definition of \"created\" and \"destroyed\" is dependent on the functions\n * passed into the constructor.\n */\nexport class SharedObject<T> {\n  #mutex = new Common.Mutex.Mutex();\n  #counter = 0;\n  #value: T|undefined;\n\n  #create: () => Awaitable<T>;\n  #destroy: (value: T) => Awaitable<void>;\n\n  constructor(create: () => Awaitable<T>, destroy: (value: T) => Awaitable<void>) {\n    this.#create = create;\n    this.#destroy = destroy;\n  }\n\n  /**\n   * @returns The shared object and a release function. If the release function\n   * throws, you may attempt to call it again (however this probably implies\n   * your destroy function is bad).\n   */\n  async acquire(): Promise<[T, ReleaseFunction]> {\n    await this.#mutex.run(async () => {\n      if (this.#counter === 0) {\n        this.#value = await this.#create();\n      }\n      ++this.#counter;\n    });\n    return [this.#value as T, this.#release.bind(this, {released: false})];\n  }\n\n  /**\n   * Automatically perform an acquire and release.\n   *\n   * **If the release fails**, then this will throw and the object will be\n   * permanently alive. This is expected to be a fatal error and you should\n   * debug your destroy function.\n   */\n  async run<U>(action: (value: T) => Awaitable<U>): Promise<U> {\n    const [value, release] = await this.acquire();\n    try {\n      const result = await action(value);\n      return result;\n    } finally {\n      await release();\n    }\n  }\n\n  async #release(state: {released: boolean}): Promise<void> {\n    if (state.released) {\n      throw new Error('Attempted to release object multiple times.');\n    }\n    try {\n      state.released = true;\n      await this.#mutex.run(async () => {\n        if (this.#counter === 1) {\n          await this.#destroy(this.#value as T);\n          this.#value = undefined;\n        }\n        --this.#counter;\n      });\n    } catch (error) {\n      state.released = false;\n      throw error;\n    }\n  }\n}\n"]}