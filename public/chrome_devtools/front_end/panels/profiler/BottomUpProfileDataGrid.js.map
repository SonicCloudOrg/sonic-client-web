{"version":3,"file":"BottomUpProfileDataGrid.js","sourceRoot":"","sources":["../../../../../../front_end/panels/profiler/BottomUpProfileDataGrid.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2009 280 North Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// Bottom Up Profiling shows the entire callstack backwards:\n// The root node is a representation of each individual function called, and each child of that node represents\n// a reverse-callstack showing how many of those calls came from it. So, unlike top-down, the statistics in\n// each child still represent the root node. We have to be particularly careful of recursion with this mode\n// because a root node can represent itself AND an ancestor.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as UI from '../../ui/legacy/legacy.js';\n\nimport {ProfileDataGridNode, ProfileDataGridTree, type Formatter} from './ProfileDataGrid.js';\nimport {type TopDownProfileDataGridTree} from './TopDownProfileDataGrid.js';\nimport type * as CPUProfile from '../../models/cpu_profile/cpu_profile.js';\n\nexport interface NodeInfo {\n  ancestor: CPUProfile.ProfileTreeModel.ProfileNode;\n  focusNode: CPUProfile.ProfileTreeModel.ProfileNode;\n  totalAccountedFor: boolean;\n}\n\nexport class BottomUpProfileDataGridNode extends ProfileDataGridNode {\n  remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(profileNode: CPUProfile.ProfileTreeModel.ProfileNode, owningTree: TopDownProfileDataGridTree) {\n    super(profileNode, owningTree, profileNode.parent !== null && Boolean(profileNode.parent.parent));\n    this.remainingNodeInfos = [];\n  }\n\n  static sharedPopulate(container: BottomUpProfileDataGridNode|BottomUpProfileDataGridTree): void {\n    if (container.remainingNodeInfos === undefined) {\n      return;\n    }\n    const remainingNodeInfos = container.remainingNodeInfos;\n    const count = remainingNodeInfos.length;\n\n    for (let index = 0; index < count; ++index) {\n      const nodeInfo = remainingNodeInfos[index];\n      const ancestor = nodeInfo.ancestor;\n      const focusNode = nodeInfo.focusNode;\n      let child: BottomUpProfileDataGridNode|(BottomUpProfileDataGridNode | null) =\n          (container.findChild(ancestor) as BottomUpProfileDataGridNode | null);\n\n      // If we already have this child, then merge the data together.\n      if (child) {\n        const totalAccountedFor = nodeInfo.totalAccountedFor;\n\n        child.self += focusNode.self;\n\n        if (!totalAccountedFor) {\n          child.total += focusNode.total;\n        }\n      } else {\n        child = new BottomUpProfileDataGridNode(ancestor, (container.tree as TopDownProfileDataGridTree));\n\n        if (ancestor !== focusNode) {\n          // But the actual statistics from the \"root\" node (bottom of the callstack).\n          child.self = focusNode.self;\n          child.total = focusNode.total;\n        }\n\n        container.appendChild(child);\n      }\n\n      const parent = ancestor.parent;\n      if (parent && parent.parent) {\n        nodeInfo.ancestor = parent;\n        if (!child.remainingNodeInfos) {\n          child.remainingNodeInfos = [];\n        }\n        child.remainingNodeInfos.push(nodeInfo);\n      }\n    }\n\n    delete container.remainingNodeInfos;\n  }\n\n  takePropertiesFromProfileDataGridNode(profileDataGridNode: ProfileDataGridNode): void {\n    this.save();\n    this.self = profileDataGridNode.self;\n    this.total = profileDataGridNode.total;\n  }\n\n  /**\n   * When focusing, we keep just the members of the callstack.\n   */\n  keepOnlyChild(child: ProfileDataGridNode): void {\n    this.save();\n\n    this.removeChildren();\n    this.appendChild(child);\n  }\n\n  exclude(aCallUID: string): void {\n    if (this.remainingNodeInfos) {\n      this.populate();\n    }\n\n    this.save();\n\n    const children = this.children;\n    let index = this.children.length;\n\n    while (index--) {\n      (children[index] as BottomUpProfileDataGridNode).exclude(aCallUID);\n    }\n\n    const child = this.childrenByCallUID.get(aCallUID);\n\n    if (child) {\n      this.merge(child, true);\n    }\n  }\n\n  override restore(): void {\n    super.restore();\n\n    if (!this.children.length) {\n      this.setHasChildren(this.willHaveChildren(this.profileNode));\n    }\n  }\n\n  override merge(child: ProfileDataGridNode, shouldAbsorb: boolean): void {\n    this.self -= child.self;\n    super.merge(child, shouldAbsorb);\n  }\n\n  override populateChildren(): void {\n    BottomUpProfileDataGridNode.sharedPopulate(this);\n  }\n\n  willHaveChildren(profileNode: CPUProfile.ProfileTreeModel.ProfileNode): boolean {\n    // In bottom up mode, our parents are our children since we display an inverted tree.\n    // However, we don't want to show the very top parent since it is redundant.\n    return Boolean(profileNode.parent && profileNode.parent.parent);\n  }\n}\n\nexport class BottomUpProfileDataGridTree extends ProfileDataGridTree {\n  override deepSearch: boolean;\n  remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(\n      formatter: Formatter, searchableView: UI.SearchableView.SearchableView,\n      rootProfileNode: CPUProfile.ProfileTreeModel.ProfileNode, total: number) {\n    super(formatter, searchableView, total);\n    this.deepSearch = false;\n\n    // Iterate each node in pre-order.\n    let profileNodeUIDs = 0;\n    const profileNodeGroups = [[], [rootProfileNode]];\n    const visitedProfileNodesForCallUID = new Map<string, Set<number>>();\n\n    this.remainingNodeInfos = [];\n\n    for (let profileNodeGroupIndex = 0; profileNodeGroupIndex < profileNodeGroups.length; ++profileNodeGroupIndex) {\n      const parentProfileNodes = profileNodeGroups[profileNodeGroupIndex];\n      const profileNodes = profileNodeGroups[++profileNodeGroupIndex];\n      const count = profileNodes.length;\n\n      const profileNodeUIDValues = new WeakMap<CPUProfile.ProfileTreeModel.ProfileNode, number>();\n\n      for (let index = 0; index < count; ++index) {\n        const profileNode = profileNodes[index];\n\n        if (!profileNodeUIDValues.get(profileNode)) {\n          profileNodeUIDValues.set(profileNode, ++profileNodeUIDs);\n        }\n\n        if (profileNode.parent) {\n          // The total time of this ancestor is accounted for if we're in any form of recursive cycle.\n          let visitedNodes = visitedProfileNodesForCallUID.get(profileNode.callUID);\n          let totalAccountedFor = false;\n\n          if (!visitedNodes) {\n            visitedNodes = new Set();\n            visitedProfileNodesForCallUID.set(profileNode.callUID, visitedNodes);\n          } else {\n            // The total time for this node has already been accounted for iff one of it's parents has already been visited.\n            // We can do this check in this style because we are traversing the tree in pre-order.\n            const parentCount = parentProfileNodes.length;\n            for (let parentIndex = 0; parentIndex < parentCount; ++parentIndex) {\n              const parentUID = profileNodeUIDValues.get(parentProfileNodes[parentIndex]);\n              if (parentUID && visitedNodes.has(parentUID)) {\n                totalAccountedFor = true;\n                break;\n              }\n            }\n          }\n\n          const uid = profileNodeUIDValues.get(profileNode);\n          if (uid) {\n            visitedNodes.add(uid);\n          }\n\n          this.remainingNodeInfos.push(\n              {ancestor: profileNode, focusNode: profileNode, totalAccountedFor: totalAccountedFor});\n        }\n\n        const children = profileNode.children;\n        if (children.length) {\n          profileNodeGroups.push(parentProfileNodes.concat([profileNode]));\n          profileNodeGroups.push(children);\n        }\n      }\n    }\n\n    // Populate the top level nodes.\n    ProfileDataGridNode.populate(this);\n\n    return this;\n  }\n\n  /**\n   * When focusing, we keep the entire callstack up to this ancestor.\n   */\n  override focus(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    let currentNode: ProfileDataGridNode = profileDataGridNode;\n    let focusNode: (ProfileDataGridNode&BottomUpProfileDataGridNode)|ProfileDataGridNode = profileDataGridNode;\n\n    while (currentNode.parent && (currentNode instanceof BottomUpProfileDataGridNode)) {\n      currentNode.takePropertiesFromProfileDataGridNode(profileDataGridNode);\n\n      focusNode = currentNode;\n      currentNode = (currentNode.parent as ProfileDataGridNode);\n\n      if (currentNode instanceof BottomUpProfileDataGridNode) {\n        currentNode.keepOnlyChild(focusNode);\n      }\n    }\n\n    this.children = [focusNode];\n    this.total = profileDataGridNode.total;\n  }\n\n  override exclude(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    const excludedCallUID = profileDataGridNode.callUID;\n    const excludedTopLevelChild = this.childrenByCallUID.get(excludedCallUID);\n\n    // If we have a top level node that is excluded, get rid of it completely (not keeping children),\n    // since bottom up data relies entirely on the root node.\n    if (excludedTopLevelChild) {\n      Platform.ArrayUtilities.removeElement(this.children, excludedTopLevelChild);\n    }\n\n    const children = this.children;\n    const count = children.length;\n\n    for (let index = 0; index < count; ++index) {\n      (children[index] as BottomUpProfileDataGridNode).exclude(excludedCallUID);\n    }\n\n    if (this.lastComparator) {\n      this.sort(this.lastComparator, true);\n    }\n  }\n\n  override populateChildren(): void {\n    BottomUpProfileDataGridNode.sharedPopulate(this);\n  }\n}\n"]}