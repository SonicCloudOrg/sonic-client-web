{"version":3,"file":"ErrorStackParser.js","sourceRoot":"","sources":["../../../../../../front_end/panels/console/ErrorStackParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport interface ParsedErrorFrame {\n  line: string;\n  link?: {\n    url: Platform.DevToolsPath.UrlString,\n    prefix: string,\n    suffix: string,\n    lineNumber?: number,\n    columnNumber?: number, enclosedInBraces: boolean,\n    scriptId?: Protocol.Runtime.ScriptId,\n  };\n}\n\n/**\n * Takes a V8 Error#stack string and extracts source position information.\n *\n * The result includes the url, line and column number, as well as where\n * the url is found in the raw line.\n *\n * @returns Null if the provided string has an unexpected format. A\n *          populated `ParsedErrorFrame[]` otherwise.\n */\nexport function parseSourcePositionsFromErrorStack(\n    runtimeModel: SDK.RuntimeModel.RuntimeModel, stack: string): ParsedErrorFrame[]|null {\n  if (!/^[\\w.]*Error\\b/.test(stack)) {\n    return null;\n  }\n  const debuggerModel = runtimeModel.debuggerModel();\n  const baseURL = runtimeModel.target().inspectedURL();\n\n  const lines = stack.split('\\n');\n  const linkInfos = [];\n  for (const line of lines) {\n    const match = /^\\s*at\\s(async\\s)?/.exec(line);\n    if (!match) {\n      if (linkInfos.length && linkInfos[linkInfos.length - 1].link) {\n        return null;\n      }\n      linkInfos.push({line});\n      continue;\n    }\n\n    let left = match[0].length;\n    let right = line.length;\n    let enclosedInBraces = false;\n    while (line[right - 1] === ')') {\n      right--;\n      enclosedInBraces = true;\n      do {\n        left = line.indexOf('(', left);\n        if (left < 0) {\n          return null;\n        }\n        left++;\n        if (!line.substring(left).startsWith('eval at ')) {\n          break;\n        }\n        left += 8;\n        right = line.lastIndexOf(', ', right) - 1;\n        if (right < 0) {\n          return null;\n        }\n      } while (true);\n    }\n\n    const linkCandidate = line.substring(left, right);\n    const splitResult = Common.ParsedURL.ParsedURL.splitLineAndColumn(linkCandidate);\n    if (splitResult.url === '<anonymous>') {\n      linkInfos.push({line});\n      continue;\n    }\n    let url = parseOrScriptMatch(debuggerModel, splitResult.url);\n    if (!url && Common.ParsedURL.ParsedURL.isRelativeURL(splitResult.url)) {\n      url = parseOrScriptMatch(debuggerModel, Common.ParsedURL.ParsedURL.completeURL(baseURL, splitResult.url));\n    }\n    if (!url) {\n      return null;\n    }\n\n    linkInfos.push({\n      line,\n      link: {\n        url,\n        prefix: line.substring(0, left),\n        suffix: line.substring(right),\n        enclosedInBraces,\n        lineNumber: splitResult.lineNumber,\n        columnNumber: splitResult.columnNumber,\n      },\n    });\n  }\n  return linkInfos;\n}\n\nfunction parseOrScriptMatch(debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString|null):\n    Platform.DevToolsPath.UrlString|null {\n  if (!url) {\n    return null;\n  }\n  if (Common.ParsedURL.ParsedURL.isValidUrlString(url)) {\n    return url;\n  }\n  if (debuggerModel.scriptsForSourceURL(url).length) {\n    return url;\n  }\n  // nodejs stack traces contain (absolute) file paths, but v8 reports them as file: urls.\n  const fileUrl = new URL(url, 'file://');\n  if (debuggerModel.scriptsForSourceURL(fileUrl.href).length) {\n    return fileUrl.href as Platform.DevToolsPath.UrlString;\n  }\n  return null;\n}\n\n/**\n * Error#stack output only contains script URLs. In some cases we are able to\n * retrieve additional exception details from V8 that we can use to augment\n * the parsed Error#stack with script IDs.\n * This function sets the `scriptId` field in `ParsedErrorFrame` when it finds\n * the corresponding info in `Protocol.Runtime.StackTrace`.\n */\nexport function augmentErrorStackWithScriptIds(\n    parsedFrames: ParsedErrorFrame[], protocolStackTrace: Protocol.Runtime.StackTrace): void {\n  // Note that the number of frames between the two stack traces can differ. The\n  // parsed Error#stack can contain Builtin frames which are not present in the protocol\n  // stack. This means its easier to always search the whole protocol stack for a matching\n  // frame rather then trying to detect the Builtin frames and skipping them.\n  for (const parsedFrame of parsedFrames) {\n    const protocolFrame = protocolStackTrace.callFrames.find(frame => framesMatch(parsedFrame, frame));\n    if (protocolFrame && parsedFrame.link) {\n      parsedFrame.link.scriptId = protocolFrame.scriptId;\n    }\n  }\n}\n\n/** Returns true iff both stack frames have the same url and line/column numbers. The function name is ignored */\nfunction framesMatch(parsedFrame: ParsedErrorFrame, protocolFrame: Protocol.Runtime.CallFrame): boolean {\n  if (!parsedFrame.link) {\n    return false;\n  }\n\n  const {url, lineNumber, columnNumber} = parsedFrame.link;\n  return url === protocolFrame.url && lineNumber === protocolFrame.lineNumber &&\n      columnNumber === protocolFrame.columnNumber;\n}\n"]}