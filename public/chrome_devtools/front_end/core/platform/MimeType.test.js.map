{"version":3,"file":"MimeType.test.js","sourceRoot":"","sources":["../../../../../../front_end/core/platform/MimeType.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from './platform.js';\n\ndescribe('parseContentType', () => {\n  interface ContentTypeTest {\n    contentType: string;\n    expectedMimeType?: string|null;\n    expectedCharset?: string|null;\n  }\n\n  const TEST_CASES: ContentTypeTest[] = [\n    {\n      contentType: 'text/html',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html;',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html; charset=utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // Parameter name is \"charset \" not \"charset\".\n    {\n      contentType: 'text/html; charset =utf-8',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html; charset= utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    {\n      contentType: 'text/html; charset=utf-8 ',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    {\n      contentType: 'text/html; charset',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html; charset=',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html; charset= ',\n      expectedMimeType: 'text/html',\n    },\n    {\n      contentType: 'text/html; charset= ;',\n      expectedMimeType: 'text/html',\n    },\n    // Empty quotes are allowed.\n    {\n      contentType: 'text/html; charset=\"\"',\n      expectedMimeType: 'text/html',\n      expectedCharset: '',\n    },\n    // Leading/trailing whitespace in quotes is trimmed\n    {\n      contentType: 'text/html; charset=\" \"',\n      expectedMimeType: 'text/html',\n      expectedCharset: '',\n    },\n    {\n      contentType: 'text/html; charset=\" foo \"',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'foo',\n    },\n    // With multiple values, should use the first one\n    {\n      contentType: 'text/html; charset=foo; charset=utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'foo',\n    },\n    {\n      contentType: 'text/html; charset; charset=; charset=utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    {\n      contentType: 'text/html; charset=utf-8; charset=; charset',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // Stray quotes ignored.\n    {\n      contentType: 'text/html; \" \"\"; charset=utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // Non-leading quotes kept as-is.\n    {\n      contentType: 'text/html; charset=u\"tf-8\"',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'u\"tf-8\"',\n    },\n    {\n      contentType: 'text/html; charset=\"utf-8\"',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // No closing quote.\n    {\n      contentType: 'text/html; charset=\"utf-8',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // Check that \\ is treated as an escape character.\n    {\n      contentType: 'text/html; charset=\"\\\\utf\\\\-\\\\8\"',\n      expectedMimeType: 'text/html',\n      expectedCharset: 'utf-8',\n    },\n    // More interseting escape character test - test escaped backslash, escaped\n    // quote, and backslash at end of input in unterminated quoted string.\n    {\n      contentType: 'text/html; charset=\"\\\\\\\\\\\\\"\\\\',\n      expectedMimeType: 'text/html',\n      expectedCharset: '\\\\\"\\\\',\n    },\n    // Check quoted semicolon\n    {\n      contentType: 'text/html; charset=\";charset=utf-8;\"',\n      expectedMimeType: 'text/html',\n      expectedCharset: ';charset=utf-8;',\n    },\n    // Single quotes are not delimiters but must be treated as part of charset.\n    {\n      contentType: 'text/html; charset=\\'utf-8\\'',\n      expectedMimeType: 'text/html',\n      expectedCharset: '\\'utf-8\\'',\n    },\n    // Empty subtype should be accepted.\n    {\n      contentType: 'text/',\n      expectedMimeType: 'text/',\n    },\n    // */* is ignored unless it has parmas or is not an exact match.\n    {\n      contentType: '*/*',\n      expectedMimeType: null,\n    },\n    {\n      contentType: '*/* ',\n      expectedMimeType: '*/*',\n    },\n    {\n      contentType: '*/*; charset=utf-8',\n      expectedMimeType: '*/*',\n      expectedCharset: 'utf-8',\n    },\n    // mime type is lowercase.\n    {\n      contentType: 'teXT/html',\n      expectedMimeType: 'text/html',\n    },\n  ];\n\n  for (const test of TEST_CASES) {\n    it(`parses '${test.contentType}'`, () => {\n      const {mimeType, charset} = Platform.MimeType.parseContentType(test.contentType);\n      assert.strictEqual(mimeType, test.expectedMimeType ?? null);\n      assert.strictEqual(charset, test.expectedCharset ?? null);\n    });\n  }\n});\n\ndescribe('isTextType', () => {\n  const TEST_CASES = new Map<string, boolean>([\n    ['text/html', true],\n    ['application/pdf', false],\n    ['application/json', true],\n    ['image/svg+xml', true],\n    ['application/manifest+json', true],\n  ]);\n\n  it('determines if a mime type has text content', () => {\n    for (const [mimeType, expectedResult] of TEST_CASES) {\n      assert.strictEqual(Platform.MimeType.isTextType(mimeType), expectedResult);\n    }\n  });\n});\n"]}