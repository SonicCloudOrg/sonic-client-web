{"version":3,"file":"CPUThrottlingManager.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/CPUThrottlingManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\n\nimport {EmulationModel} from './EmulationModel.js';\nimport {type SDKModelObserver, TargetManager} from './TargetManager.js';\n\nlet throttlingManagerInstance: CPUThrottlingManager;\n\nexport class CPUThrottlingManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDKModelObserver<EmulationModel> {\n  #cpuThrottlingRateInternal: number;\n  #hardwareConcurrencyInternal?: number;\n  #pendingMainTargetPromise?: (r: number) => void;\n\n  private constructor() {\n    super();\n    this.#cpuThrottlingRateInternal = CPUThrottlingRates.NoThrottling;\n    TargetManager.instance().observeModels(EmulationModel, this);\n  }\n\n  static instance(opts: {forceNew: boolean|null} = {forceNew: null}): CPUThrottlingManager {\n    const {forceNew} = opts;\n    if (!throttlingManagerInstance || forceNew) {\n      throttlingManagerInstance = new CPUThrottlingManager();\n    }\n\n    return throttlingManagerInstance;\n  }\n\n  cpuThrottlingRate(): number {\n    return this.#cpuThrottlingRateInternal;\n  }\n\n  setCPUThrottlingRate(rate: number): void {\n    this.#cpuThrottlingRateInternal = rate;\n    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {\n      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);\n    }\n    this.dispatchEventToListeners(Events.RateChanged, this.#cpuThrottlingRateInternal);\n  }\n\n  setHardwareConcurrency(concurrency: number): void {\n    this.#hardwareConcurrencyInternal = concurrency;\n    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {\n      void emulationModel.setHardwareConcurrency(concurrency);\n    }\n    this.dispatchEventToListeners(Events.HardwareConcurrencyChanged, this.#hardwareConcurrencyInternal);\n  }\n\n  hasPrimaryPageTargetSet(): boolean {\n    // In some environments, such as Node, trying to check if we have a page\n    // target may error. So if we get any errors here at all, assume that we do\n    // not have a target.\n    try {\n      return TargetManager.instance().primaryPageTarget() !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  async getHardwareConcurrency(): Promise<number> {\n    const target = TargetManager.instance().primaryPageTarget();\n    const existingCallback = this.#pendingMainTargetPromise;\n\n    // If the main target hasn't attached yet, block callers until it appears.\n    if (!target) {\n      if (existingCallback) {\n        return new Promise(r => {\n          this.#pendingMainTargetPromise = (result: number) => {\n            r(result);\n            existingCallback(result);\n          };\n        });\n      }\n      return new Promise(r => {\n        this.#pendingMainTargetPromise = r;\n      });\n    }\n\n    const evalResult = await target.runtimeAgent().invoke_evaluate(\n        {expression: 'navigator.hardwareConcurrency', returnByValue: true, silent: true, throwOnSideEffect: true});\n    const error = evalResult.getError();\n    if (error) {\n      throw new Error(error);\n    }\n    const {result, exceptionDetails} = evalResult;\n    if (exceptionDetails) {\n      throw new Error(exceptionDetails.text);\n    }\n    return result.value;\n  }\n\n  modelAdded(emulationModel: EmulationModel): void {\n    if (this.#cpuThrottlingRateInternal !== CPUThrottlingRates.NoThrottling) {\n      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);\n    }\n    if (this.#hardwareConcurrencyInternal !== undefined) {\n      void emulationModel.setHardwareConcurrency(this.#hardwareConcurrencyInternal);\n    }\n\n    // If there are any callers blocked on a getHardwareConcurrency call, let's wake them now.\n    if (this.#pendingMainTargetPromise) {\n      const existingCallback = this.#pendingMainTargetPromise;\n      this.#pendingMainTargetPromise = undefined;\n      void this.getHardwareConcurrency().then(existingCallback);\n    }\n  }\n\n  modelRemoved(_emulationModel: EmulationModel): void {\n    // Implemented as a requirement for being a SDKModelObserver.\n  }\n}\n\nexport const enum Events {\n  RateChanged = 'RateChanged',\n  HardwareConcurrencyChanged = 'HardwareConcurrencyChanged',\n}\n\nexport type EventTypes = {\n  [Events.RateChanged]: number,\n  [Events.HardwareConcurrencyChanged]: number,\n};\n\nexport function throttlingManager(): CPUThrottlingManager {\n  return CPUThrottlingManager.instance();\n}\n\nexport enum CPUThrottlingRates {\n  NoThrottling = 1,\n  MidTierMobile = 4,\n  LowEndMobile = 6,\n  ExtraSlow = 20,\n}\n"]}