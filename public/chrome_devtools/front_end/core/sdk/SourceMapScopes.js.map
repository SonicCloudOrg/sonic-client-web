{"version":3,"file":"SourceMapScopes.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapScopes.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B;;;;;;;;GAQG;AAEH,OAAO,EAAC,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAiE7C,MAAM,UAAU,oBAAoB,CAAC,qBAA+B,EAAE,KAAe;IACnF,OAAO,qBAAqB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,mBAAmB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AAC/E,CAAC;AAED,SAAS,mBAAmB,CAAC,oBAA4B,EAAE,KAAe;IACxE,MAAM,iBAAiB,GAAG,IAAI,GAAG,EAAyB,CAAC;IAC3D,MAAM,UAAU,GAAoB,EAAE,CAAC;IACvC,IAAI,IAAI,GAAG,CAAC,CAAC;IAEb,KAAK,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,wBAAwB,CAAC,oBAAoB,CAAC,EAAE,CAAC;QAC3E,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC;QAClB,MAAM,EAAC,MAAM,EAAC,GAAG,IAAI,CAAC;QACtB,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YAClB,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACnC,MAAM,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC3C,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YACxD,MAAM,KAAK,GAAkB,EAAC,KAAK,EAAE,EAAC,IAAI,EAAE,MAAM,EAAC,EAAE,GAAG,EAAE,EAAC,IAAI,EAAE,MAAM,EAAC,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,QAAQ,EAAE,EAAE,EAAC,CAAC;YAC/G,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACvB,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACtC,CAAC;aAAM,CAAC;YACN,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC;YAC/B,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,MAAM,IAAI,KAAK,CAAC,8EAA8E,CAAC,CAAC;YAClG,CAAC;YACD,KAAK,CAAC,GAAG,GAAG,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC;YAE3B,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC5B,2EAA2E;gBAC3E,OAAO,EAAC,IAAI,EAAE,KAAK,EAAE,iBAAiB,EAAC,CAAC;YAC1C,CAAC;YACD,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACzD,CAAC;IACH,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;AACvD,CAAC;AAgBD,SAAS,OAAO,CAAC,IAAuD;IACtE,OAAO,MAAM,IAAI,IAAI,CAAC;AACxB,CAAC;AAED,QAAQ,CAAC,CACL,wBAAwB,CAAC,oBAA4B;IAEvD,MAAM,IAAI,GAAG,IAAI,aAAa,CAAC,oBAAoB,CAAC,CAAC;IACrD,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,IAAI,SAAS,GAAG,CAAC,CAAC;IAElB,OAAO,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,IAAI,EAAE,CAAC,CAAE,eAAe;QAC/B,CAAC;QAED,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QACxD,IAAI,IAAI,KAAK,CAAC,IAAI,MAAM,GAAG,UAAU,EAAE,CAAC;YACtC,MAAM,IAAI,KAAK,CAAC,4FAA4F,CAAC,CAAC;QAChH,CAAC;QACD,UAAU,GAAG,MAAM,CAAC;QAEpB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YAC3C,MAAM,CAAC,SAAS,EAAE,EAAE,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;YACpC,SAAS;QACX,CAAC;QAED,MAAM,SAAS,GAA8B;YAC3C,IAAI;YACJ,MAAM;YACN,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE;YACpB,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE;YACrB,SAAS,EAAE,EAAE;SACd,CAAC;QAEF,IAAI,SAAS,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC;YAC1B,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAClC,CAAC;QAED,IAAI,SAAS,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC;YAC1B,OAAO,IAAI,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;gBAC7C,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;YAC3C,CAAC;QACH,CAAC;QAED,MAAM,CAAC,SAAS,EAAE,EAAE,SAAS,CAAC,CAAC;IACjC,CAAC;AACH,CAAC;AAED,MAAM,UAAU,qBAAqB,CACjC,qBAA6B,EAAE,kBAAuC,EAAE,KAAe;IACzF,MAAM,UAAU,GAAqB,EAAE,CAAC;IACxC,MAAM,gBAAgB,GAAG,IAAI,GAAG,EAA8C,CAAC;IAE/E,KAAK,MAAM,IAAI,IAAI,yBAAyB,CAAC,qBAAqB,CAAC,EAAE,CAAC;QACpE,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YACvB,0DAA0D;YAE1D,MAAM,KAAK,GAAmB;gBAC5B,KAAK,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAC;gBAC7C,GAAG,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAC;gBAC3C,MAAM,EAAE,EAAE;gBACV,QAAQ,EAAE,EAAE;aACb,CAAC;YAEF,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;gBACpB,MAAM,EAAC,QAAQ,EAAE,SAAS,EAAC,GAAG,IAAI,CAAC,UAAU,CAAC;gBAC9C,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,CAAC;oBACnC,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;gBAC3C,CAAC;gBACD,MAAM,aAAa,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACpF,IAAI,CAAC,aAAa,EAAE,CAAC;oBACnB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;gBACnD,CAAC;gBACD,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;YACtC,CAAC;YAED,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,MAAM,EAAC,SAAS,EAAE,IAAI,EAAE,MAAM,EAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;gBAChD,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,CAAC;oBACnC,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;gBAC3C,CAAC;gBACD,KAAK,CAAC,QAAQ,GAAG;oBACf,WAAW,EAAE,SAAS;oBACtB,IAAI;oBACJ,MAAM;iBACP,CAAC;YACJ,CAAC;YAED,gBAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAClC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC;aAAM,CAAC;YACN,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC;YAC/B,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,MAAM,IAAI,KAAK,CAAC,8EAA8E,CAAC,CAAC;YAClG,CAAC;YACD,KAAK,CAAC,GAAG,GAAG,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAC,CAAC;YACnD,eAAe,CAAC,KAAK,EAAE,KAAK,EAAE,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,QAAQ,CAAC,CAAC;YAErE,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC5B,2EAA2E;gBAC3E,OAAO,KAAK,CAAC;YACf,CAAC;YACD,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACzD,CAAC;IACH,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;AACxD,CAAC;AAED,SAAS,eAAe,CACpB,KAAqB,EAAE,KAAe,EACtC,kBAAoE;IACtE,IAAI,kBAAkB,KAAK,SAAS,EAAE,CAAC;QACrC,OAAO;IACT,CAAC;IAED,KAAK,CAAC,MAAM,GAAG,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;QAC/C,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC1B,OAAO,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACjD,CAAC;QAED,MAAM,aAAa,GAAmB,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YACV,IAAI,EAAE,EAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAC;YAClD,EAAE,EAAE,EAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAC;YAChD,KAAK,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC;SAC3C,CAAC,CAAC,CAAC;QACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YAC9C,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,EAAC,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,EAAC,CAAC;QACvD,CAAC;QACD,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,EAAC,GAAG,KAAK,CAAC,GAAG,EAAC,CAAC;QAC5D,OAAO,aAAa,CAAC;IACvB,CAAC,CAAC,CAAC;AACL,CAAC;AAgCD,SAAS,YAAY,CAAC,IAAyD;IAC7E,OAAO,OAAO,IAAI,IAAI,CAAC;AACzB,CAAC;AAED,QAAQ,CAAC,CACL,yBAAyB,CAAC,qBAA6B;IAEzD,MAAM,IAAI,GAAG,IAAI,aAAa,CAAC,qBAAqB,CAAC,CAAC;IACtD,IAAI,IAAI,GAAG,CAAC,CAAC;IAEb,2EAA2E;IAC3E,uCAAuC;IACvC,MAAM,KAAK,GAAG;QACZ,IAAI,EAAE,CAAC;QACP,MAAM,EAAE,CAAC;QACT,YAAY,EAAE,CAAC;QACf,WAAW,EAAE,CAAC;QACd,iBAAiB,EAAE,CAAC;QACpB,YAAY,EAAE,CAAC;QACf,cAAc,EAAE,CAAC;KAClB,CAAC;IAEF,OAAO,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;QACtB,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,IAAI,EAAE,CAAC,CAAE,eAAe;YAC7B,EAAE,IAAI,CAAC;YACP,SAAS;QACX,CAAC;aAAM,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YAC/B,IAAI,CAAC,IAAI,EAAE,CAAC,CAAE,eAAe;YAC7B,SAAS;QACX,CAAC;QAED,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACzE,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,IAAI,IAAI,CAAC,OAAO,EAAE,KAAK,IAAI,EAAE,CAAC;YAC5B,MAAM,EAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAC,CAAC;YACnC,SAAS;QACX,CAAC;QAED,MAAM,SAAS,GAA+B;YAC5C,IAAI;YACJ,MAAM,EAAE,KAAK,CAAC,MAAM;YACpB,KAAK,EAAE,IAAI,CAAC,OAAO,EAAE;YACrB,QAAQ,EAAE,EAAE;SACb,CAAC;QAEF,IAAI,SAAS,CAAC,KAAK,kDAA0C,EAAE,CAAC;YAC9D,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAChC,KAAK,CAAC,WAAW,GAAG,QAAQ,GAAG,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzE,KAAK,CAAC,YAAY,IAAI,SAAS,CAAC;YAChC,SAAS,CAAC,UAAU,GAAG;gBACrB,SAAS,EAAE,KAAK,CAAC,YAAY;gBAC7B,QAAQ,EAAE,KAAK,CAAC,WAAW;aAC5B,CAAC;QACJ,CAAC;QAED,IAAI,SAAS,CAAC,KAAK,gDAAwC,EAAE,CAAC;YAC5D,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YACjC,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC5B,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC9B,KAAK,CAAC,cAAc,GAAG,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,IAAI,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3F,KAAK,CAAC,YAAY,GAAG,IAAI,GAAG,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACvE,KAAK,CAAC,iBAAiB,IAAI,SAAS,CAAC;YACrC,SAAS,CAAC,QAAQ,GAAG;gBACnB,SAAS,EAAE,KAAK,CAAC,iBAAiB;gBAClC,IAAI,EAAE,KAAK,CAAC,YAAY;gBACxB,MAAM,EAAE,KAAK,CAAC,cAAc;aAC7B,CAAC;QACJ,CAAC;QAED,OAAO,IAAI,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YACpE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC7B,MAAM,QAAQ,GACV,CAAC,EAAC,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,MAAM,EAAE,OAAO,EAAE,KAAK,EAAC,CAAC,CAAC;YACvE,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAElC,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC/B,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,IAAI,CAAC,CAAC,EAAE,CAAC;gBACtC,8GAA8G;gBAC9G,SAAS;YACX,CAAC;YAED,yGAAyG;YACzG,MAAM,UAAU,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;gBACxC,4BAA4B;gBAC5B,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;gBAC5B,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;gBAC9B,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;gBAE/B,MAAM,QAAQ,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,CAAM,8DAA8D;gBAChH,MAAM,UAAU,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC,CAAC,CAAE,8DAA8D;gBAEhH,QAAQ,CAAC,IAAI,CAAC;oBACZ,IAAI,EAAE,IAAI,GAAG,QAAQ;oBACrB,MAAM,EAAE,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9C,OAAO;iBACR,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAED,MAAM,SAAS,CAAC;IAClB,CAAC;AACH,CAAC;AAED,SAAS,WAAW,CAAC,GAAqB,EAAE,KAAe;IACzD,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC;QACjC,OAAO,SAAS,CAAC;IACnB,CAAC;IACD,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AACpB,CAAC;AAED,SAAS,UAAU,CAAC,IAAY;IAC9B,QAAQ,IAAI,EAAE,CAAC;QACb,KAAK,GAAG;YACN,OAAO,QAAQ,CAAC;QAClB,KAAK,GAAG;YACN,OAAO,UAAU,CAAC;QACpB,KAAK,GAAG;YACN,OAAO,OAAO,CAAC;QACjB,KAAK,GAAG;YACN,OAAO,OAAO,CAAC;QACjB;YACE,MAAM,IAAI,KAAK,CAAC,sBAAsB,IAAI,EAAE,CAAC,CAAC;IAClD,CAAC;AACH,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @fileoverview This file implements the current state of the \"Scopes\" proposal\n * for the source map spec.\n *\n * See https://github.com/tc39/source-map-rfc/blob/main/proposals/scopes.md.\n *\n * The proposal is still being worked on so we expect the implementation details\n * in this file to change frequently.\n */\n\nimport {TokenIterator} from './SourceMap.js';\n\n/**\n * A scope in the authored source.\n */\nexport interface OriginalScope {\n  start: Position;\n  end: Position;\n  kind: ScopeKind;\n  name?: string;\n  variables: string[];\n  children: OriginalScope[];\n}\n\n/**\n * A range (can be a scope) in the generated JavaScript.\n */\nexport interface GeneratedRange {\n  start: Position;\n  end: Position;\n  originalScope?: OriginalScope;\n\n  /**\n   * If this `GeneratedRange` is the result of inlining `originalScope`, then `callsite`\n   * refers to where `originalScope` was called in the original (\"authored\") code.\n   */\n  callsite?: OriginalPosition;\n\n  /**\n   * Expressions that compute the values of the variables of this OriginalScope. The length\n   * of `values` must match the length of `originalScope.variables`.\n   *\n   * For each variable this can either be a single expression (valid for the full `GeneratedRange`),\n   * or an array of `BindingRange`s, e.g. if computing the value requires different expressions\n   * throughout the range or if the variable is only available in parts of the `GeneratedRange`.\n   *\n   * `undefined` denotes that the value of a variable is unavailble in the whole range.\n   * This can happen e.g. if the variable was optimized out and can't be recomputed.\n   */\n  values: (string|undefined|BindingRange[])[];\n  children: GeneratedRange[];\n}\n\nexport type ScopeKind = 'global'|'class'|'function'|'block';\n\nexport interface BindingRange {\n  value?: string;\n  from: Position;\n  to: Position;\n}\n\nexport interface Position {\n  line: number;\n  column: number;\n}\n\nexport interface OriginalPosition extends Position {\n  sourceIndex: number;\n}\n\ninterface OriginalScopeTree {\n  readonly root: OriginalScope;\n  readonly scopeForItemIndex: Map<number, OriginalScope>;\n}\n\nexport function decodeOriginalScopes(encodedOriginalScopes: string[], names: string[]): OriginalScopeTree[] {\n  return encodedOriginalScopes.map(scope => decodeOriginalScope(scope, names));\n}\n\nfunction decodeOriginalScope(encodedOriginalScope: string, names: string[]): OriginalScopeTree {\n  const scopeForItemIndex = new Map<number, OriginalScope>();\n  const scopeStack: OriginalScope[] = [];\n  let line = 0;\n\n  for (const [index, item] of decodeOriginalScopeItems(encodedOriginalScope)) {\n    line += item.line;\n    const {column} = item;\n    if (isStart(item)) {\n      const kind = decodeKind(item.kind);\n      const name = resolveName(item.name, names);\n      const variables = item.variables.map(idx => names[idx]);\n      const scope: OriginalScope = {start: {line, column}, end: {line, column}, kind, name, variables, children: []};\n      scopeStack.push(scope);\n      scopeForItemIndex.set(index, scope);\n    } else {\n      const scope = scopeStack.pop();\n      if (!scope) {\n        throw new Error('Scope items not nested properly: encountered \"end\" item without \"start\" item');\n      }\n      scope.end = {line, column};\n\n      if (scopeStack.length === 0) {\n        // We are done. There might be more top-level scopes but we only allow one.\n        return {root: scope, scopeForItemIndex};\n      }\n      scopeStack[scopeStack.length - 1].children.push(scope);\n    }\n  }\n  throw new Error('Malformed original scope encoding');\n}\n\ninterface EncodedOriginalScopeStart {\n  line: number;\n  column: number;\n  kind: number;\n  flags: number;\n  name?: number;\n  variables: number[];\n}\n\ninterface EncodedOriginalScopeEnd {\n  line: number;\n  column: number;\n}\n\nfunction isStart(item: EncodedOriginalScopeStart|EncodedOriginalScopeEnd): item is EncodedOriginalScopeStart {\n  return 'kind' in item;\n}\n\nfunction*\n    decodeOriginalScopeItems(encodedOriginalScope: string):\n        Generator<[number, EncodedOriginalScopeStart | EncodedOriginalScopeEnd]> {\n  const iter = new TokenIterator(encodedOriginalScope);\n  let prevColumn = 0;\n  let itemCount = 0;\n\n  while (iter.hasNext()) {\n    if (iter.peek() === ',') {\n      iter.next();  // Consume ','.\n    }\n\n    const [line, column] = [iter.nextVLQ(), iter.nextVLQ()];\n    if (line === 0 && column < prevColumn) {\n      throw new Error('Malformed original scope encoding: start/end items must be ordered w.r.t. source positions');\n    }\n    prevColumn = column;\n\n    if (!iter.hasNext() || iter.peek() === ',') {\n      yield [itemCount++, {line, column}];\n      continue;\n    }\n\n    const startItem: EncodedOriginalScopeStart = {\n      line,\n      column,\n      kind: iter.nextVLQ(),\n      flags: iter.nextVLQ(),\n      variables: [],\n    };\n\n    if (startItem.flags & 0x1) {\n      startItem.name = iter.nextVLQ();\n    }\n\n    if (startItem.flags & 0x2) {\n      while (iter.hasNext() && iter.peek() !== ',') {\n        startItem.variables.push(iter.nextVLQ());\n      }\n    }\n\n    yield [itemCount++, startItem];\n  }\n}\n\nexport function decodeGeneratedRanges(\n    encodedGeneratedRange: string, originalScopeTrees: OriginalScopeTree[], names: string[]): GeneratedRange {\n  const rangeStack: GeneratedRange[] = [];\n  const rangeToStartItem = new Map<GeneratedRange, EncodedGeneratedRangeStart>();\n\n  for (const item of decodeGeneratedRangeItems(encodedGeneratedRange)) {\n    if (isRangeStart(item)) {\n      // TODO(crbug.com/40277685): Decode callsite and bindings.\n\n      const range: GeneratedRange = {\n        start: {line: item.line, column: item.column},\n        end: {line: item.line, column: item.column},\n        values: [],\n        children: [],\n      };\n\n      if (item.definition) {\n        const {scopeIdx, sourceIdx} = item.definition;\n        if (!originalScopeTrees[sourceIdx]) {\n          throw new Error('Invalid source index!');\n        }\n        const originalScope = originalScopeTrees[sourceIdx].scopeForItemIndex.get(scopeIdx);\n        if (!originalScope) {\n          throw new Error('Invalid original scope index!');\n        }\n        range.originalScope = originalScope;\n      }\n\n      if (item.callsite) {\n        const {sourceIdx, line, column} = item.callsite;\n        if (!originalScopeTrees[sourceIdx]) {\n          throw new Error('Invalid source index!');\n        }\n        range.callsite = {\n          sourceIndex: sourceIdx,\n          line,\n          column,\n        };\n      }\n\n      rangeToStartItem.set(range, item);\n      rangeStack.push(range);\n    } else {\n      const range = rangeStack.pop();\n      if (!range) {\n        throw new Error('Range items not nested properly: encountered \"end\" item without \"start\" item');\n      }\n      range.end = {line: item.line, column: item.column};\n      resolveBindings(range, names, rangeToStartItem.get(range)?.bindings);\n\n      if (rangeStack.length === 0) {\n        // We are done. There might be more top-level scopes but we only allow one.\n        return range;\n      }\n      rangeStack[rangeStack.length - 1].children.push(range);\n    }\n  }\n  throw new Error('Malformed generated range encoding');\n}\n\nfunction resolveBindings(\n    range: GeneratedRange, names: string[],\n    bindingsForAllVars: EncodedGeneratedRangeStart['bindings']|undefined): void {\n  if (bindingsForAllVars === undefined) {\n    return;\n  }\n\n  range.values = bindingsForAllVars.map(bindings => {\n    if (bindings.length === 1) {\n      return resolveName(bindings[0].nameIdx, names);\n    }\n\n    const bindingRanges: BindingRange[] = bindings.map(binding => ({\n                                                         from: {line: binding.line, column: binding.column},\n                                                         to: {line: binding.line, column: binding.column},\n                                                         value: resolveName(binding.nameIdx, names),\n                                                       }));\n    for (let i = 1; i < bindingRanges.length; ++i) {\n      bindingRanges[i - 1].to = {...bindingRanges[i].from};\n    }\n    bindingRanges[bindingRanges.length - 1].to = {...range.end};\n    return bindingRanges;\n  });\n}\n\ninterface EncodedGeneratedRangeStart {\n  line: number;\n  column: number;\n  flags: number;\n  definition?: {\n    sourceIdx: number,\n    scopeIdx: number,\n  };\n  callsite?: {\n    sourceIdx: number,\n    line: number,\n    column: number,\n  };\n  bindings: {\n    line: number,\n    column: number,\n    nameIdx: number,\n  }[][];\n}\n\ninterface EncodedGeneratedRangeEnd {\n  line: number;\n  column: number;\n}\n\nexport const enum EncodedGeneratedRangeFlag {\n  HasDefinition = 0x1,\n  HasCallsite = 0x2,\n}\n\nfunction isRangeStart(item: EncodedGeneratedRangeStart|EncodedGeneratedRangeEnd): item is EncodedGeneratedRangeStart {\n  return 'flags' in item;\n}\n\nfunction*\n    decodeGeneratedRangeItems(encodedGeneratedRange: string):\n        Generator<EncodedGeneratedRangeStart|EncodedGeneratedRangeEnd> {\n  const iter = new TokenIterator(encodedGeneratedRange);\n  let line = 0;\n\n  // The state are the fields of the last produced item, tracked because many\n  // are relative to the preceeding item.\n  const state = {\n    line: 0,\n    column: 0,\n    defSourceIdx: 0,\n    defScopeIdx: 0,\n    callsiteSourceIdx: 0,\n    callsiteLine: 0,\n    callsiteColumn: 0,\n  };\n\n  while (iter.hasNext()) {\n    if (iter.peek() === ';') {\n      iter.next();  // Consume ';'.\n      ++line;\n      continue;\n    } else if (iter.peek() === ',') {\n      iter.next();  // Consume ','.\n      continue;\n    }\n\n    state.column = iter.nextVLQ() + (line === state.line ? state.column : 0);\n    state.line = line;\n    if (iter.peekVLQ() === null) {\n      yield {line, column: state.column};\n      continue;\n    }\n\n    const startItem: EncodedGeneratedRangeStart = {\n      line,\n      column: state.column,\n      flags: iter.nextVLQ(),\n      bindings: [],\n    };\n\n    if (startItem.flags & EncodedGeneratedRangeFlag.HasDefinition) {\n      const sourceIdx = iter.nextVLQ();\n      const scopeIdx = iter.nextVLQ();\n      state.defScopeIdx = scopeIdx + (sourceIdx === 0 ? state.defScopeIdx : 0);\n      state.defSourceIdx += sourceIdx;\n      startItem.definition = {\n        sourceIdx: state.defSourceIdx,\n        scopeIdx: state.defScopeIdx,\n      };\n    }\n\n    if (startItem.flags & EncodedGeneratedRangeFlag.HasCallsite) {\n      const sourceIdx = iter.nextVLQ();\n      const line = iter.nextVLQ();\n      const column = iter.nextVLQ();\n      state.callsiteColumn = column + (line === 0 && sourceIdx === 0 ? state.callsiteColumn : 0);\n      state.callsiteLine = line + (sourceIdx === 0 ? state.callsiteLine : 0);\n      state.callsiteSourceIdx += sourceIdx;\n      startItem.callsite = {\n        sourceIdx: state.callsiteSourceIdx,\n        line: state.callsiteLine,\n        column: state.callsiteColumn,\n      };\n    }\n\n    while (iter.hasNext() && iter.peek() !== ';' && iter.peek() !== ',') {\n      const value = iter.nextVLQ();\n      const bindings: EncodedGeneratedRangeStart['bindings'][number] =\n          [{line: startItem.line, column: startItem.column, nameIdx: value}];\n      startItem.bindings.push(bindings);\n\n      const nextVlq = iter.peekVLQ();\n      if (nextVlq === null || nextVlq >= -1) {\n        // Variable is available under the same expression in the whole range, or it's unavailable in the whole range.\n        continue;\n      }\n\n      // Variable is available under different expressions in this range or unavailable in parts of this range.\n      const rangeCount = -iter.nextVLQ();\n      for (let i = 0; i < rangeCount - 1; ++i) {\n        // line, column, valueOffset\n        const line = iter.nextVLQ();\n        const column = iter.nextVLQ();\n        const nameIdx = iter.nextVLQ();\n\n        const lastLine = bindings.at(-1)?.line ?? 0;      // Only to make TS happy. `bindings` has one entry guaranteed.\n        const lastColumn = bindings.at(-1)?.column ?? 0;  // Only to make TS happy. `bindings` has one entry guaranteed.\n\n        bindings.push({\n          line: line + lastLine,\n          column: column + (line === 0 ? lastColumn : 0),\n          nameIdx,\n        });\n      }\n    }\n\n    yield startItem;\n  }\n}\n\nfunction resolveName(idx: number|undefined, names: string[]): string|undefined {\n  if (idx === undefined || idx < 0) {\n    return undefined;\n  }\n  return names[idx];\n}\n\nfunction decodeKind(kind: number): ScopeKind {\n  switch (kind) {\n    case 0x1:\n      return 'global';\n    case 0x2:\n      return 'function';\n    case 0x3:\n      return 'class';\n    case 0x4:\n      return 'block';\n    default:\n      throw new Error(`Unknown scope kind ${kind}`);\n  }\n}\n"]}