{"version":3,"file":"TraceLoader.js","sourceRoot":"","sources":["../../../../../front_end/testing/TraceLoader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../generated/protocol.js';\nimport * as TraceEngine from '../models/trace/trace.js';\nimport * as ModificationsManager from '../services/modifications_manager/modifications_manager.js';\nimport * as TraceBounds from '../services/trace_bounds/trace_bounds.js';\n\n// We maintain two caches:\n// 1. The file contents JSON.parsed for a given trace file.\n// 2. The trace engine models for a given file (used by the traceEngine function)\n// Both the file contents and the model data are not expected to change during\n// the lifetime of an instance of DevTools, so they are safe to cache and\n// re-use across tests to avoid extra time spent loading and parsing the same\n// inputs.\n// In the future once the data layer migration is complete, we can hopefully\n// simplify this into one method that loads the new engine and none of the old\n// ones.\nconst fileContentsCache = new Map<string, TraceEngine.Types.File.Contents>();\n\n// The new engine cache is a map of maps of:\n// trace file name => trace engine configuration => trace data\n//\n// The first map is a Map of string (which is the name of the trace file) to a\n// new map, where the key is the trace engine configuration stringified.\n// This ensures that we cache as much as we can, but if you load the same trace\n// file with different trace engine configurations, we will not use the cache\n// and will reparse. This is required as some of the settings and experiments\n// change if events are kept and dropped.\nconst traceEngineCache = new Map<\n    string,\n    Map<string, {traceParsedData: TraceEngine.Handlers.Types.TraceParseData, model: TraceEngine.TraceModel.Model}>>();\n\nexport interface TraceEngineLoaderOptions {\n  initTraceBounds: boolean;\n}\n\n/**\n * Loads trace files defined as fixtures in front_end/panels/timeline/fixtures/traces.\n *\n * Will automatically cache the results to save time processing the same trace\n * multiple times in a run of the test suite.\n **/\nexport class TraceLoader {\n  /**\n   * Parsing some trace files easily takes up more than our default Mocha timeout\n   * which is 2seconds. So for most tests that include parsing a trace, we have to\n   * increase the timeout. We use this function to ensure we set a consistent\n   * timeout across all trace model tests.\n   * The context might be null when we only render a component example.\n   **/\n  static setTestTimeout(context: Mocha.Context|Mocha.Suite|null): void {\n    if (!context || context.timeout() >= 10_000) {\n      return;\n    }\n    context?.timeout(10_000);\n  }\n\n  /**\n   * Loads a trace file into memory and returns its contents after\n   * JSON.parse-ing them\n   *\n   **/\n  static async fixtureContents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<TraceEngine.Types.File.Contents> {\n    TraceLoader.setTestTimeout(context);\n    const cached = fileContentsCache.get(name);\n    if (cached) {\n      return cached;\n    }\n    // Required URLs differ across the component server and the unit tests, so try both.\n    const urlForTest = new URL(`../front_end/panels/timeline/fixtures/traces/${name}`, window.location.origin);\n    const urlForComponentExample =\n        new URL(`../front_end/panels/timeline/fixtures/traces/${name}`, window.location.origin);\n\n    if (window.location.pathname.includes('ui/components/docs') ||\n        window.location.pathname.includes('ui\\\\components\\\\docs')) {\n      const contents = await loadTraceFileFromURL(urlForComponentExample);\n      fileContentsCache.set(name, contents);\n      return contents;\n    }\n    const contents = await loadTraceFileFromURL(urlForTest);\n    fileContentsCache.set(name, contents);\n    return contents;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from TraceEngine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawEvents(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<readonly TraceEngine.Types.TraceEvents.TraceEventData[]> {\n    const contents = await TraceLoader.fixtureContents(context, name);\n\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    TraceEngine.Helpers.SyntheticEvents.SyntheticEventsManager.initSyntheticEventsManagerForTrace(events);\n    return events;\n  }\n\n  /**\n   * Load an array of raw events from the trace file.\n   * Will default to typing those events using the types from TraceEngine, but\n   * can be overriden by passing the legacy EventPayload type as the generic.\n   **/\n  static async rawCPUProfile(context: Mocha.Context|Mocha.Suite|null, name: string):\n      Promise<Protocol.Profiler.Profile> {\n    const contents = await TraceLoader.fixtureContents(context, name) as unknown as Protocol.Profiler.Profile;\n    return contents;\n  }\n\n  /**\n   * Executes only the new trace engine on the fixture and returns the resulting parsed data.\n   *\n   * @param context The Mocha test context. |allModelsFromFile| function easily\n   * takes up more than our default Mocha timeout, which is 2s. So we have to\n   * increase this test's timeout. It might be null when we only render a\n   * component example.\n   *\n   * @param file The name of the trace file to be loaded.\n   * The trace file should be in ../panels/timeline/fixtures/traces folder.\n   *\n   * @param options Additional trace options.\n   * @param options.initTraceBounds (defaults to `true`) after the trace is\n   * loaded, the TraceBounds manager will automatically be initialised using\n   * the bounds from the trace.\n   *\n   * @param config The config the new trace engine should run with. Optional,\n   * will fall back to the Default config if not provided.\n   */\n  static async traceEngine(\n      context: Mocha.Context|Mocha.Suite|null, name: string, options: TraceEngineLoaderOptions = {\n        initTraceBounds: true,\n      },\n      config: TraceEngine.Types.Configuration.Configuration = TraceEngine.Types.Configuration.defaults()):\n      Promise<TraceEngine.Handlers.Types.TraceParseData> {\n    // Force the TraceBounds to be reset to empty. This ensures that in\n    // tests where we are using the new engine data we don't accidentally\n    // rely on the fact that a previous test has set the BoundsManager.\n    TraceBounds.TraceBounds.BoundsManager.instance({forceNew: true});\n\n    const configCacheKey = TraceEngine.Types.Configuration.configToCacheKey(config);\n\n    const fromCache = traceEngineCache.get(name)?.get(configCacheKey);\n    if (fromCache) {\n      ModificationsManager.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(\n          fromCache.model, 0);\n      if (options.initTraceBounds) {\n        TraceLoader.initTraceBoundsManager(fromCache.traceParsedData);\n      }\n      return fromCache.traceParsedData;\n    }\n    const fileContents = await TraceLoader.fixtureContents(context, name);\n    const traceEngineData =\n        await TraceLoader.executeTraceEngineOnFileContents(fileContents, /* emulate fresh recording */ false, config);\n\n    const cacheByName = traceEngineCache.get(name) ||\n        new Map<string,\n                {traceParsedData: TraceEngine.Handlers.Types.TraceParseData, model: TraceEngine.TraceModel.Model}>();\n    cacheByName.set(configCacheKey, traceEngineData);\n    traceEngineCache.set(name, cacheByName);\n    ModificationsManager.ModificationsManager.ModificationsManager.initAndActivateModificationsManager(\n        traceEngineData.model, 0);\n    if (options.initTraceBounds) {\n      TraceLoader.initTraceBoundsManager(traceEngineData.traceParsedData);\n    }\n    return traceEngineData.traceParsedData;\n  }\n\n  /**\n   * Initialise the BoundsManager with the bounds from a trace.\n   * This isn't always required, but some of our code - particularly at the UI\n   * level - rely on this being set. This is always set in the actual panel, but\n   * parsing a trace in a test does not automatically set it.\n   **/\n  static initTraceBoundsManager(data: TraceEngine.Handlers.Types.TraceParseData): void {\n    TraceBounds.TraceBounds.BoundsManager\n        .instance({\n          forceNew: true,\n        })\n        .resetWithNewBounds(data.Meta.traceBounds);\n  }\n\n  static async executeTraceEngineOnFileContents(\n      contents: TraceEngine.Types.File.Contents, emulateFreshRecording = false,\n      traceEngineConfig?: TraceEngine.Types.Configuration.Configuration): Promise<{\n    model: TraceEngine.TraceModel.Model,\n    metadata: TraceEngine.Types.File.MetaData,\n    traceParsedData: TraceEngine.Handlers.Types.TraceParseData,\n  }> {\n    const events = 'traceEvents' in contents ? contents.traceEvents : contents;\n    const metadata = 'metadata' in contents ? contents.metadata : {};\n    return new Promise((resolve, reject) => {\n      const model = TraceEngine.TraceModel.Model.createWithAllHandlers(traceEngineConfig);\n      model.addEventListener(TraceEngine.TraceModel.ModelUpdateEvent.eventName, (event: Event) => {\n        const {data} = event as TraceEngine.TraceModel.ModelUpdateEvent;\n\n        // When we receive the final update from the model, update the recording\n        // state back to waiting.\n        if (TraceEngine.TraceModel.isModelUpdateDataComplete(data)) {\n          const metadata = model.metadata(0);\n          const traceParsedData = model.traceParsedData(0);\n          if (metadata && traceParsedData) {\n            resolve({\n              model,\n              metadata,\n              traceParsedData,\n            });\n          } else {\n            reject(new Error('Unable to load trace'));\n          }\n        }\n      });\n\n      void model.parse(events, {metadata, isFreshRecording: emulateFreshRecording}).catch(e => console.error(e));\n    });\n  }\n}\n\n// Below this point are private methods used in the TraceLoader class. These\n// are purposefully not exported, you should use one of the static methods\n// defined above.\n\nasync function loadTraceFileFromURL(url: URL): Promise<TraceEngine.Types.File.Contents> {\n  const response = await fetch(url);\n  if (response.status !== 200) {\n    throw new Error(`Unable to load ${url}`);\n  }\n\n  const contentType = response.headers.get('content-type');\n  const isGzipEncoded = contentType !== null && contentType.includes('gzip');\n  let buffer = await response.arrayBuffer();\n  if (isGzipEncoded) {\n    buffer = await decodeGzipBuffer(buffer);\n  }\n  const decoder = new TextDecoder('utf-8');\n  const contents = JSON.parse(decoder.decode(buffer)) as TraceEngine.Types.File.Contents;\n  return contents;\n}\n\ninterface CompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ninterface DecompressionStream extends ReadableWritablePair<Uint8Array, Uint8Array> {}\ndeclare const CompressionStream: {\n  prototype: CompressionStream,\n  new (type: string): CompressionStream,\n};\n\ndeclare const DecompressionStream: {\n  prototype: DecompressionStream,\n  new (type: string): DecompressionStream,\n};\n\nfunction codec(buffer: ArrayBuffer, codecStream: CompressionStream|DecompressionStream): Promise<ArrayBuffer> {\n  const {readable, writable} = new TransformStream();\n  const codecReadable = readable.pipeThrough(codecStream);\n\n  const writer = writable.getWriter();\n  void writer.write(buffer);\n  void writer.close();\n\n  // Wrap in a response for convenience.\n  const response = new Response(codecReadable);\n  return response.arrayBuffer();\n}\n\nfunction decodeGzipBuffer(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  return codec(buffer, new DecompressionStream('gzip'));\n}\n"]}