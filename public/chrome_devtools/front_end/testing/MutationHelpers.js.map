{"version":3,"file":"MutationHelpers.js","sourceRoot":"","sources":["../../../../../front_end/testing/MutationHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum MutationType {\n  ADD = 'ADD',\n  REMOVE = 'REMOVE',\n  TEXT_UPDATE = 'TEXT_UPDATE',\n}\n\nexport const TEXT_NODE = 'TEXT_NODE';\n\ninterface ExpectedMutation {\n  max?: number;\n  target: keyof HTMLElementTagNameMap|typeof TEXT_NODE;\n  type?: MutationType;\n}\n\nconst nodeShouldBeIgnored = (node: Node): boolean => {\n  const isCommentNode = node.nodeType === Node.COMMENT_NODE;\n  const isTextNode = node.nodeType === Node.TEXT_NODE;\n\n  if (isCommentNode) {\n    return true;\n  }\n\n  if (isTextNode) {\n    // We ignore textNode changes where the trimmed text is empty - these are\n    // most likely whitespace changes from LitHtml and not important.\n    return (node.textContent || '').trim() === '';\n  }\n\n  return false;\n};\n\nconst observedMutationsThatMatchExpected =\n    (expectedMutation: ExpectedMutation, observedMutations: ObservedMutation[]): ObservedMutation[] => {\n      const matching: ObservedMutation[] = [];\n\n      for (const mutation of observedMutations) {\n        if (expectedMutation.target === TEXT_NODE) {\n          if (mutation.target === TEXT_NODE) {\n            matching.push(mutation);\n          }\n        } else if (expectedMutation.target === mutation.target) {\n          if (!expectedMutation.type) {\n            matching.push(mutation);\n          } else if (expectedMutation.type === mutation.type) {\n            matching.push(mutation);\n          }\n        }\n      }\n      return matching;\n    };\n\ninterface MutationCount {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  ADD: number;\n  REMOVE: number;\n  TEXT_UPDATE: number;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nconst getMutationsForTagName = (trackedMutations: Map<string, MutationCount>, tagName: string): MutationCount => {\n  return trackedMutations.get(tagName) || {ADD: 0, REMOVE: 0, TEXT_UPDATE: 0};\n};\n\nconst getAllMutationCounts = (observedMutations: ObservedMutation[]): Map<string, MutationCount> => {\n  const trackedMutations = new Map<string, MutationCount>();\n\n  for (const mutation of observedMutations) {\n    if (mutation.target === TEXT_NODE) {\n      const mutationsForTagName = getMutationsForTagName(trackedMutations, TEXT_NODE);\n      mutationsForTagName.TEXT_UPDATE++;\n      trackedMutations.set(TEXT_NODE, mutationsForTagName);\n    }\n\n    const tagName = mutation.target;\n    if (mutation.type === MutationType.ADD) {\n      const mutationsForTagName = getMutationsForTagName(trackedMutations, tagName);\n      mutationsForTagName.ADD++;\n      trackedMutations.set(tagName, mutationsForTagName);\n    } else if (mutation.type === MutationType.REMOVE) {\n      const mutationsForTagName = getMutationsForTagName(trackedMutations, tagName);\n      mutationsForTagName.REMOVE++;\n      trackedMutations.set(tagName, mutationsForTagName);\n    }\n  }\n\n  return trackedMutations;\n};\n\ntype ObservedMutation = {\n  target: keyof HTMLElementTagNameMap,\n  type: MutationType,\n}|{target: typeof TEXT_NODE, type: MutationType.TEXT_UPDATE};\n\nconst storeRelevantMutationEntries = (entries: MutationRecord[], storageArray: ObservedMutation[]) => {\n  for (const entry of entries) {\n    if (entry.type === 'characterData') {\n      storageArray.push({\n        target: TEXT_NODE,\n        type: MutationType.TEXT_UPDATE,\n      });\n    }\n\n    for (const added of entry.addedNodes) {\n      if (!nodeShouldBeIgnored(added)) {\n        storageArray.push({\n          target: added.nodeName.toLowerCase() as keyof HTMLElementTagNameMap,\n          type: MutationType.ADD,\n        });\n      }\n    }\n\n    for (const removed of entry.removedNodes) {\n      if (!nodeShouldBeIgnored(removed)) {\n        storageArray.push({\n          target: removed.nodeName.toLowerCase() as keyof HTMLElementTagNameMap,\n          type: MutationType.REMOVE,\n        });\n      }\n    }\n  }\n};\n\nconst generateOutputForMutationList = (observedMutations: ObservedMutation[]): string => {\n  const debugOutput: string[] = [];\n  const mutationCounts = getAllMutationCounts(observedMutations);\n  const allMutations = Array.from(mutationCounts.entries());\n  for (const [elem, mutations] of allMutations) {\n    const output = `${elem}: `;\n    const mutationOutput: string[] = [];\n    const addMutations = mutations.ADD;\n    if (addMutations) {\n      mutationOutput.push(`${addMutations} ${pluralize(addMutations, 'addition', 'additions')}`);\n    }\n    const removeMutations = mutations.REMOVE;\n    if (removeMutations) {\n      mutationOutput.push(`${removeMutations} ${pluralize(removeMutations, 'removal', 'removals')}`);\n    }\n    const updateMutations = mutations.TEXT_UPDATE;\n    if (updateMutations) {\n      mutationOutput.push(`${updateMutations} ${pluralize(updateMutations, 'update', 'updates')}`);\n    }\n    debugOutput.push(output + mutationOutput.join(', '));\n  }\n\n  return debugOutput.join('\\n');\n};\n\nconst errorMessageWhenExpectingNoMutations = (observedMutations: ObservedMutation[]) => {\n  const debugOutput = generateOutputForMutationList(observedMutations);\n  assert.fail(`Expected no mutations, but got ${observedMutations.length}: \\n${debugOutput}`);\n};\n\nfunction pluralize(count: number, singular: string, plural: string): string {\n  return count === 1 ? singular : plural;\n}\n\nconst DEFAULT_MAX_MUTATIONS_LIMIT = 10;\n/**\n * Check that a given component causes the expected amount of mutations. Useful\n * when testing a component to ensure it's updating the DOM performantly and not\n * unnecessarily.\n */\nexport const withMutations = async<T extends Node>(\n    expectedMutations: ExpectedMutation[], shadowRoot: T, functionToObserve: (shadowRoot: T) => void) => {\n  const observedMutations: ObservedMutation[] = [];\n  const mutationObserver = new MutationObserver(entries => {\n    storeRelevantMutationEntries(entries, observedMutations);\n  });\n\n  mutationObserver.observe(shadowRoot, {\n    subtree: true,\n    attributes: true,\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n  });\n\n  await functionToObserve(shadowRoot);\n\n  /* We takeRecords() here to flush any observed mutations that have been seen\n  but not yet fed back into the callback we passed when we instantiated the\n  observer. This ensures we've got every mutation before we disconnect the\n  observer. */\n  const records = mutationObserver.takeRecords();\n  storeRelevantMutationEntries(records, observedMutations);\n  mutationObserver.disconnect();\n\n  if (expectedMutations.length === 0) {\n    if (observedMutations.length !== 0) {\n      errorMessageWhenExpectingNoMutations(observedMutations);\n      return;\n    }\n  }\n\n  const mutationsMatchedToExpected = new Set<ObservedMutation>();\n  for (const expectedMutation of expectedMutations) {\n    // Gather all observed mutations that match the given expectation. e.g. if\n    // the expected mutation is { target: 'div' } this will gather all observed\n    // mutations with a target of `div`.\n    const matchingMutations = observedMutationsThatMatchExpected(expectedMutation, observedMutations);\n    for (const matched of matchingMutations) {\n      mutationsMatchedToExpected.add(matched);\n    }\n\n    const amountOfMatchingMutations = matchingMutations.length;\n    // Make sure we check for undefined, not truthyness, as the user could\n    // supply a max of 0.\n    const maxMutationsAllowed = expectedMutation.max === undefined ? DEFAULT_MAX_MUTATIONS_LIMIT : expectedMutation.max;\n\n    if (amountOfMatchingMutations > maxMutationsAllowed) {\n      assert.fail(`Expected no more than ${maxMutationsAllowed} mutations for ${\n          expectedMutation.type || 'ADD/REMOVE'} ${expectedMutation.target}, but got ${amountOfMatchingMutations}`);\n    } else if (amountOfMatchingMutations === 0 && maxMutationsAllowed > 0) {\n      assert.fail(`Expected at least one mutation for ${expectedMutation.type || 'ADD/REMOVE'} ${\n          expectedMutation.target}, but got ${amountOfMatchingMutations}`);\n    }\n  }\n\n  // These are mutations that happened but the user did not explicitly list as\n  // expected, so we want to fail the test on them.\n  const unmatchedMutations = observedMutations.filter(mutation => !mutationsMatchedToExpected.has(mutation));\n\n  if (unmatchedMutations.length > 0) {\n    const unexpectedOutput = generateOutputForMutationList(unmatchedMutations);\n    assert.fail(`Additional unexpected mutations were detected:\\n${unexpectedOutput}`);\n  }\n};\n\n/**\n * Ensure that a code block runs whilst making no mutations to the DOM. Given an\n * element and a callback, it will execute th e callback function and ensure\n * afterwards that a MutatonObserver saw no changes.\n */\nexport const withNoMutations = async<T extends Node>(element: T, fn: (shadowRoot: T) => void) => {\n  return await withMutations([], element, fn);\n};\n\nexport const someMutations = async<T extends Node>(element: T) => {\n  return new Promise<void>(resolve => {\n    const observer = new MutationObserver(() => {\n      resolve();\n      observer.disconnect();\n    });\n    observer.observe(element, {attributes: true, childList: true, subtree: true});\n  });\n};\n"]}