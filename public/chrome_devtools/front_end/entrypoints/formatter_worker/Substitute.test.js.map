{"version":3,"file":"Substitute.test.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/formatter_worker/Substitute.test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as FormatterWorker from './formatter_worker.js';\n\nconst mapping = new Map<string, string|null>([\n  ['varX', 'x'],\n  ['varY', 'y'],\n  ['varZ', 'z'],\n  ['this', 'this_1'],\n  ['rename_to_this', 'this'],\n  ['rename_to_arguments', 'arguments'],\n  ['varQ', null],\n]);\n\nfunction substitute(expression: string): string {\n  return FormatterWorker.Substitute.substituteExpression(expression, mapping);\n}\n\ndescribe('Substitute', () => {\n  it('Preserves unrelated variable', () => {\n    assert.strictEqual(substitute('x'), 'x');\n  });\n\n  it('Substitutes single variable', () => {\n    assert.strictEqual(substitute('varY'), 'y');\n  });\n\n  it('Substitutes await', () => {\n    assert.strictEqual(substitute('await varX'), 'await x');\n  });\n\n  it('Substitutes array elements', () => {\n    assert.strictEqual(substitute('[0, varY, varZ]'), '[0, y, z]');\n    assert.strictEqual(substitute('[0, varY, ...varZ]'), '[0, y, ...z]');\n  });\n\n  it('Substitutes binary expressions, assignments, sequences', () => {\n    assert.strictEqual(substitute('varX + varY'), 'x + y');\n    assert.strictEqual(substitute('varX, varY'), 'x, y');\n    assert.strictEqual(substitute('varX = varZ'), 'x = z');\n    assert.strictEqual(substitute('varX += varZ'), 'x += z');\n  });\n\n  it('Substitutes arrow functions', () => {\n    assert.strictEqual(substitute('(a) => a + varX'), '(a) => a + x');\n    assert.strictEqual(substitute('(varX) => a + varX'), '(varX) => a + varX');\n    // Capture avoiding substitution.\n    assert.strictEqual(substitute('(x) => x + varX'), '(x_1) => x_1 + x');\n    assert.strictEqual(substitute('(x) => (x) => x + varX'), '(x_2) => (x_1) => x_1 + x');\n    assert.strictEqual(substitute('(x) => (x_1) => x + varX'), '(x_2) => (x_1) => x_2 + x');\n  });\n\n  it('Substitutes in blocks', () => {\n    assert.strictEqual(substitute('{console.log(varY)}'), '{console.log(y)}');\n    assert.strictEqual(substitute('{var y; console.log(varY + y)}'), '{var y_1; console.log(y + y_1)}');\n\n    // Technically it would be correct to rename all instances of y to y_1,\n    // but let us check we treat the let variables independently.\n    assert.strictEqual(\n        substitute('var y; {let y; console.log(varY + y)}; y'), 'var y_2; {let y_1; console.log(y + y_1)}; y_2');\n    // Var hoisting out of blocks.\n    assert.strictEqual(substitute('{var y; console.log(varY + y)}; y'), '{var y_1; console.log(y + y_1)}; y_1');\n    assert.strictEqual(\n        substitute('{let varY; console.log(varX + varY)}; varY'), '{let varY; console.log(x + varY)}; y');\n    assert.strictEqual(\n        substitute('{const varY = 1; console.log(varX + varY)}; varY'), '{const varY = 1; console.log(x + varY)}; y');\n    assert.strictEqual(\n        substitute('{var varY; console.log(varX + varY)}; varY'), '{var varY; console.log(x + varY)}; varY');\n  });\n\n  it('Substitutes in member expressions', () => {\n    assert.strictEqual(substitute('varY.varX?.varZ'), 'y.varX?.varZ');\n  });\n\n  it('Substitutes in conditionals', () => {\n    assert.strictEqual(substitute('varX ? varY : varZ'), 'x ? y : z');\n    assert.strictEqual(substitute('if (varX) varY; else varZ;'), 'if (x) y; else z;');\n  });\n\n  it('Substitutes in loops', () => {\n    assert.strictEqual(substitute('do { console.log(varX) } while (varY);'), 'do { console.log(x) } while (y);');\n    assert.strictEqual(substitute('for (varX in varY) console.log(varZ);'), 'for (x in y) console.log(z);');\n    assert.strictEqual(\n        substitute('for (let varX in varY) console.log(varZ + varX);'), 'for (let varX in y) console.log(z + varX);');\n    assert.strictEqual(\n        substitute('for (let varX of varY) console.log(varZ + varX);'), 'for (let varX of y) console.log(z + varX);');\n    assert.strictEqual(\n        substitute('for (let x of varY) console.log(x + varX);'), 'for (let x_1 of y) console.log(x_1 + x);');\n    assert.strictEqual(\n        substitute('for (varX = 1; varX < 100; varX++) console.log(varX);'),\n        'for (x = 1; x < 100; x++) console.log(x);');\n    assert.strictEqual(\n        substitute('for (var varX = 1; varX < 100; varX++) console.log(varX);'),\n        'for (var varX = 1; varX < 100; varX++) console.log(varX);');\n    assert.strictEqual(substitute('while (varX) { varY; }'), 'while (x) { y; }');\n  });\n\n  it('Substitutes in functions', () => {\n    assert.strictEqual(substitute('function f(a) { a + varX; }'), 'function f(a) { a + x; }');\n    assert.strictEqual(substitute('function f(varX) { a + varX; }'), 'function f(varX) { a + varX; }');\n    // Capture avoiding substitution.\n    assert.strictEqual(\n        substitute('function f(x) { return (x_1) => x + varX; }'), 'function f(x_2) { return (x_1) => x_2 + x; }');\n    assert.strictEqual(substitute('function f(...varX) { varX[0] }'), 'function f(...varX) { varX[0] }');\n    assert.strictEqual(substitute('function f(...x) { varX[0] }'), 'function f(...x_1) { x[0] }');\n    assert.strictEqual(substitute('function f() { this; }; this'), 'function f() { this; }; this_1');\n  });\n\n  it('Substitutes in object literals', () => {\n    assert.strictEqual(substitute('{ varX: varX }'), '{ varX: x }');\n    assert.strictEqual(substitute('({ [varY]: varX })'), '({ [y]: x })');\n    assert.strictEqual(substitute('({ ...varX })'), '({ ...x })');\n    assert.strictEqual(substitute('({ varX })'), '({ varX: x })');\n  });\n\n  it('Substitutes in switch', () => {\n    assert.strictEqual(substitute('switch (varX) { case varY: varZ; }'), 'switch (x) { case y: z; }');\n    assert.strictEqual(\n        substitute('switch (varY) { case varZ: varX; case 2: let x = 1; }'),\n        'switch (y) { case z: x; case 2: let x_1 = 1; }');\n  });\n\n  it('Substitutes in generators', () => {\n    assert.strictEqual(substitute('function* f(x) { yield varX + x; }'), 'function* f(x_1) { yield x + x_1; }');\n  });\n\n  it('Substitutes in template literals', () => {\n    assert.strictEqual(substitute('`${varX}`'), '`${x}`');\n    assert.strictEqual(substitute('varY`${varX} varZ`'), 'y`${x} varZ`');\n  });\n\n  it('Substitutes in patterns', () => {\n    assert.strictEqual(substitute('[varX, varY] = [varZ, 1]'), '[x, y] = [z, 1]');\n    assert.strictEqual(substitute('[varX[varY]] = [3]'), '[x[y]] = [3]');\n    assert.strictEqual(substitute('[varX.varY] = [3]'), '[x.varY] = [3]');\n    assert.strictEqual(substitute('({varX: varZ} = {varX: 3})'), '({varX: z} = {varX: 3})');\n    assert.strictEqual(substitute('[varX = varY] = []'), '[x = y] = []');\n    assert.strictEqual(substitute('({varX: varZ.x} = {varX: 3})'), '({varX: z.x} = {varX: 3})');\n\n    assert.strictEqual(substitute('let [varX, varY] = [varZ, 1]; varX'), 'let [varX, varY] = [z, 1]; varX');\n    assert.strictEqual(substitute('let [varX = varY] = []'), 'let [varX = y] = []');\n    assert.strictEqual(substitute('var {varX: varZ} = {varX: 3}; varZ'), 'var {varX: varZ} = {varX: 3}; varZ');\n\n    // Avoid captures.\n    assert.strictEqual(substitute('let [y, x] = [varX, varY]; x'), 'let [y_1, x_1] = [x, y]; x_1');\n    assert.strictEqual(substitute('var {varX: x} = {varX}; x'), 'var {varX: x_1} = {varX: x}; x_1');\n  });\n\n  it('Does not substitute in strings', () => {\n    assert.strictEqual(substitute('\\'varX\\''), '\\'varX\\'');\n    assert.strictEqual(substitute('\\\"varX\\\"'), '\\\"varX\\\"');\n    assert.strictEqual(substitute('\\`varX\\`'), '\\`varX\\`');\n  });\n\n  it('Does not substitute in comments', () => {\n    assert.strictEqual(substitute('/* varX */'), '/* varX */');\n    assert.strictEqual(substitute('// varX'), '// varX');\n  });\n\n  it('Throws on to-be-captured \"this\" and \"arguments\" bound by a function', () => {\n    assert.throws(() => substitute('function f() { return rename_to_this; }'), 'Cannot avoid capture of \\'this\\'');\n    assert.throws(\n        () => substitute('function f() { return rename_to_arguments; }'), 'Cannot avoid capture of \\'arguments\\'');\n  });\n\n  it('Throws on parse error', () => {\n    assert.throws(() => substitute('('), SyntaxError);\n  });\n\n  it('Throws if the renamed variable is unavailable', () => {\n    assert.throws(() => substitute('varQ'), Error);\n  });\n});\n"]}